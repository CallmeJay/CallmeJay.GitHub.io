<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-big-counter.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ES6," />





  <link rel="alternate" href="/atom.xml" title="Jay's Blog" type="application/atom+xml" />






<meta name="description" content="ES6简介​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​由于ES6是在2015年发布的，所以也叫ES2015">
<meta name="keywords" content="ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6新特性">
<meta property="og:url" content="https://callmejay.github.io/2017/06/28/ES6新特性/index.html">
<meta property="og:site_name" content="Jay&#39;s Blog">
<meta property="og:description" content="ES6简介​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​由于ES6是在2015年发布的，所以也叫ES2015">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-02-10T09:29:37.030Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6新特性">
<meta name="twitter:description" content="ES6简介​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​由于ES6是在2015年发布的，所以也叫ES2015">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://callmejay.github.io/2017/06/28/ES6新特性/"/>





  <title>ES6新特性 | Jay's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">知其然，知其所以然。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://callmejay.github.io/2017/06/28/ES6新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jay Bein">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jay's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">ES6新特性</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T22:28:04+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="ES6简介"><a href="#ES6简介" class="headerlink" title="ES6简介"></a>ES6简介</h2><p>​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。<br>​由于ES6是在2015年发布的，所以也叫ES2015。<br>​以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….<br><a id="more"></a></p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><blockquote>
<p>在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。</p>
</blockquote>
<p>块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：</p>
<ul>
<li>函数内部</li>
<li>在代码块（即 { }）内部</li>
</ul>
<h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><blockquote>
<p>使用let声明变量的语法和使用var声明的语法是一样的。<strong>但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//由于b是在if块中使用let声明的，所以此处无法访问到。（报错）</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问<br>2.用let声明的变量也没有声明提前这一特性。<br>3.在同一个块中，let声明的变量也不能重复声明。<br>4.在声明变量的时候尽量使用let，慢慢的抛弃var</p>
<h3 id="const声明-Constant-Declarations"><a href="#const声明-Constant-Declarations" class="headerlink" title="const声明(Constant Declarations)"></a>const声明(Constant Declarations)</h3><blockquote>
<p>在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">20</span>;</span><br><span class="line">    b = <span class="number">30</span>;  <span class="comment">//错误! 常量不能重新赋值</span></span><br><span class="line">    <span class="keyword">const</span> c; <span class="comment">//错误！ 常量声明的同时必须赋值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>1.const的特性除了声明的是常量为，其他与let一样。<br>2.在let和const声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。<br>3.使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。</p>
<h3 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h3><blockquote>
<p>使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123; <span class="comment">// 循环结束之后会立即销毁 i</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//此处无法访问到 i 。</span></span><br></pre></td></tr></table></figure>
<h3 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h3><blockquote>
<p>看下面的代码，是输出10个10，而不是0，1，2，…</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 输出 "10" 共10次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决办法需要使用函数的自执行特性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)));</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 输出 0，1，2 ... 9</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 输出 0，1，2 ... 9</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>说明：<br>let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。</p>
<h2 id="函数的新增特性"><a href="#函数的新增特性" class="headerlink" title="函数的新增特性"></a>函数的新增特性</h2><h3 id="带默认参数的函数"><a href="#带默认参数的函数" class="headerlink" title="带默认参数的函数"></a>带默认参数的函数</h3><blockquote>
<p>JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    timeout = timeout || <span class="number">2000</span>;</span><br><span class="line">    callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.</p>
<blockquote>
<p>ES6从语言层面面上增加了<strong>默认值的</strong>支持。看下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认参数对-arguments-对象的影响"><a href="#默认参数对-arguments-对象的影响" class="headerlink" title="默认参数对 arguments 对象的影响"></a>默认参数对 arguments 对象的影响</h3><blockquote>
<p>在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//非严格模式</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ES5的严格模式下，arguments只反映参数的初始值，而不再反映命名参数的变化！</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//严格模式</span></span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//false。  修改a的值不会影响到arguments[0]的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b = <span class="number">30</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]  === a); <span class="comment">//false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//false。  b使用了默认值，所以表现的和严格模式一样。</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。</p>
</blockquote>
<h3 id="默认参数表达式-Default-Parameter-Expressions"><a href="#默认参数表达式-Default-Parameter-Expressions" class="headerlink" title="默认参数表达式 (Default Parameter Expressions)"></a>默认参数表达式 (Default Parameter Expressions)</h3><blockquote>
<p>参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123; <span class="comment">//表示使用getValue这个函数的返回值作为second的默认值。</span></span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。<br>由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;  <span class="comment">// 使用第一个参数作为第二个参数的默认值</span></span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。</p>
</blockquote>
<h3 id="未命名参数问题"><a href="#未命名参数问题" class="headerlink" title="未命名参数问题"></a>未命名参数问题</h3><blockquote>
<p>Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>])  <span class="comment">//取得传入的多余的参数。</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">&gt;ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数( Rest Parameters)**</span></span><br><span class="line"><span class="string">语法：function a(a, … b)&#123; &#125;</span></span><br><span class="line"><span class="string">剩余参数使用三个点( … )和变量名来表示。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, ...b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">//true  .多余的参数都被放入了b中。b其实就是一个数组。</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：1.函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。<br>2.虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。<br>3.剩余参数是在函数声明的时候出现的。</p>
</blockquote>
<h3 id="函数中的扩展运算符"><a href="#函数中的扩展运算符" class="headerlink" title="函数中的扩展运算符"></a>函数中的扩展运算符</h3><blockquote>
<p>例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用apply方法。</p>
</blockquote>
<p>看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]    </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values));  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上面这种方法虽然可行，但是总是不是那么直观<br>使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));  <span class="comment">//使用扩展运算符。相当于拆解了数组了。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">200</span>));  <span class="comment">//也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。<br>剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面<br>扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。</p>
</blockquote>
<h2 id="全新的函数：箭头函数（-gt-）"><a href="#全新的函数：箭头函数（-gt-）" class="headerlink" title="全新的函数：箭头函数（=&gt;）"></a>全新的函数：箭头函数（=&gt;）</h2><h3 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h3><blockquote>
<p>基本语法如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(形参列表)=&gt;&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">//前面的箭头函数等同于下面的传统函数</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。<br>如果函数体内有多条语句，则 {} 不能省略。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">//前面的箭头函数等同于下面的传统函数</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这一行代码是没有返回值的，则方法的返回自也是undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">3</span>,<span class="number">4</span>));  <span class="comment">//这个地方的返回值就是undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。<strong>当然如果不传入参数也不可以省略</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span>=&gt;</span> a+<span class="number">3</span>; <span class="comment">//因为只有一个参数，所以()可以省略</span></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">4</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 ()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span>=&gt;</span>(&#123;<span class="attr">name</span>:<span class="string">"lisi"</span>, <span class="attr">age</span>:<span class="number">30</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="comment">//等同于下面的；</span></span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:<span class="string">"lisi"</span>,</span><br><span class="line">        age : <span class="number">30</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用箭头函数实现函数自执行"><a href="#使用箭头函数实现函数自执行" class="headerlink" title="使用箭头函数实现函数自执行"></a>使用箭头函数实现函数自执行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = (<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: name,</span><br><span class="line">            age: <span class="number">30</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)(<span class="string">"zs"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数中无this绑定-No-this-Binding"><a href="#箭头函数中无this绑定-No-this-Binding" class="headerlink" title="箭头函数中无this绑定(No this Binding)"></a>箭头函数中无this绑定(No this Binding)</h3><blockquote>
<p>在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。<br><strong>在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式</strong><br>箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。<strong>如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</span><br><span class="line">            event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>); <span class="comment">// 在此处this的和init函数内的this相同。</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">PageHandler.init();</span><br></pre></td></tr></table></figure>
<p>看下面的一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    foo:<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>)   <span class="comment">//此处this为window</span></span><br><span class="line">&#125;</span><br><span class="line">p.foo();  <span class="comment">//输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。</span></span><br><span class="line"><span class="comment">//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。<br>2.由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。</p>
</blockquote>
<h3 id="无arguments绑定"><a href="#无arguments绑定" class="headerlink" title="无arguments绑定"></a>无arguments绑定</h3><blockquote>
<p>虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">arguments</span>[<span class="number">0</span>]; <span class="comment">//箭头函数的返回值是foo函数的第一个参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrow = foo(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrow()); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="对象功能的扩展"><a href="#对象功能的扩展" class="headerlink" title="对象功能的扩展"></a>对象功能的扩展</h2><blockquote>
<p>在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。</p>
</blockquote>
<h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><blockquote>
<p>ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括：</p>
</blockquote>
<ul>
<li>普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。</li>
<li>特异对象（exotic object）的某些内部行为和默认的有所差异。</li>
<li>标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。</li>
<li>内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。</li>
</ul>
<h3 id="对象字面量的语法扩展"><a href="#对象字面量的语法扩展" class="headerlink" title="对象字面量的语法扩展"></a>对象字面量的语法扩展</h3><h4 id="简写的属性初始化"><a href="#简写的属性初始化" class="headerlink" title="简写的属性初始化"></a>简写的属性初始化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个对象：属性名和参数名相同。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:name,</span><br><span class="line">        age:age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createPerson(<span class="string">"lisi"</span>, <span class="number">30</span>)); <span class="comment">// &#123;name:"lisi", age:30&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES6中，上面的写法可以简化成如下形式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个对象：属性名和参数名相同。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,  <span class="comment">//当对象属性名和本地变量名相同时，可以省略冒号和值</span></span><br><span class="line">        age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(createPerson(<span class="string">"lisi"</span>, <span class="number">30</span>)); <span class="comment">// &#123;name:"lisi", age:30&#125;</span></span><br></pre></td></tr></table></figure>
<p><em>当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。</em></p>
<h4 id="简写的方法声明"><a href="#简写的方法声明" class="headerlink" title="简写的方法声明"></a>简写的方法声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'lisi'</span>,</span><br><span class="line">    sayHell:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我的名字是："</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHell()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ES6中，上面的写法可以简化成如下的形式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">'李四'</span>,</span><br><span class="line">    sayHell() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我的名字是："</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayHell()</span><br></pre></td></tr></table></figure>
<h4 id="在字面量中动态计算属性名"><a href="#在字面量中动态计算属性名" class="headerlink" title="在字面量中动态计算属性名"></a>在字面量中动态计算属性名</h4><blockquote>
<p>在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    name : <span class="string">'李四'</span>,</span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> attName = <span class="string">'name'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p[attName]) <span class="comment">//这里 attName表示的是一个变量名。</span></span><br></pre></td></tr></table></figure></p>
<p>而下面的方式使用时没有办法访问到attName这个变量的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attName = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    attName : <span class="string">'李四'</span>,  <span class="comment">// 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。</span></span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p[attName])  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attName = <span class="string">'name'</span>;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    [attName] : <span class="string">'李四'</span>,  <span class="comment">// 引用了变量attName。相当于添加了一个属性名为name的属性</span></span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p[attName])  <span class="comment">// 李四</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="新增的方法"><a href="#新增的方法" class="headerlink" title="新增的方法"></a>新增的方法</h3><blockquote>
<p>ECMAScript从第五版开始避免在Object.prototype上添加新的全局函数或方法，转而去考虑具体的对象类型（如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。<br>ES6 在全局Object上添加了几个新的方法来轻松地完成一些特定任务。</p>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。<br>ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>);              <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>);             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>));     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);           <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>);              <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>);             <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>));     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><em>很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 <em>认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的</em>。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。</em></p>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><blockquote>
<p>使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。<br>assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    name : <span class="string">"lisi"</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line">    friends : [<span class="string">'张三'</span>, <span class="string">'李四'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(p1, p); <span class="comment">//则p1中就有了与p相同的属性和方法.  p1是接受者，p是提供者</span></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="comment">//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.friends == p.friends);  <span class="comment">//true    p1和p的friends同事指向了同一个数组。</span></span><br><span class="line">p.friends.push(<span class="string">"王五"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.friends); <span class="comment">//['张三', '李四', '王五']</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>assign方法可以接受任意多的提供者。意味着后面提供者的同名属性会覆盖前面提供者的属性值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    name : <span class="string">"lisi"</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line">    friends : [<span class="string">'张三'</span>, <span class="string">'李四'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = &#123;</span><br><span class="line">    name : <span class="string">'zs'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(p2, p, p1); <span class="comment">//p和p1都是提供者</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name); <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串功能的增强"><a href="#字符串功能的增强" class="headerlink" title="字符串功能的增强"></a>字符串功能的增强</h2><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><blockquote>
<p>在以前在字符串中查找字符串的时候，都是使用indexOf方法。<br>ES6新增了三个方法来查找字符串。</p>
<ul>
<li>includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。</li>
<li>startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。</li>
<li>endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。</li>
</ul>
<p>每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"!"</span>));             <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>));             <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>));           <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>));        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"x"</span>));             <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>, <span class="number">4</span>));        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="repeat方法"><a href="#repeat方法" class="headerlink" title="repeat方法"></a>repeat方法</h3><blockquote>
<p>ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span>.repeat(<span class="number">3</span>));         <span class="comment">// "xxx"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.repeat(<span class="number">2</span>));     <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"abc"</span>.repeat(<span class="number">4</span>));       <span class="comment">// "abcabcabcabc"</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串模板字面量"><a href="#字符串模板字面量" class="headerlink" title="字符串模板字面量"></a>字符串模板字面量</h3><blockquote>
<p>模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应：</p>
<ul>
<li>多行字符串 针对多行字符串的形式概念（formal concept）。</li>
<li>基本的字符串格式化 将字符串中的变量置换为值的能力。</li>
<li>转义 HTML 能将字符串进行转义并使其安全地插入到 HTML 的能力。</li>
</ul>
<p>模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。</p>
</blockquote>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><blockquote>
<p>使用一对反引号 ``(tab正上方的按键)来表示模板字面量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello world!`</span>;   <span class="comment">//使用模板字面量创建了一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);               <span class="comment">// "Hello world!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);        <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(message.length);        <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><blockquote>
<p>在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"abc \</span></span><br><span class="line"><span class="string">aaaaaa"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">//但是输出的结果中不包括换行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">`abc</span></span><br><span class="line"><span class="string">aaaaa</span></span><br><span class="line"><span class="string">dsalfja</span></span><br><span class="line"><span class="string">dfadfja`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是要注意： 反引号中的所有空格和缩进都是有效字符。</p>
</blockquote>
<h4 id="字符串置换"><a href="#字符串置换" class="headerlink" title="字符串置换"></a>字符串置换</h4><blockquote>
<p>置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。<br>语法：<strong>${变量名、表达式、任意运算、方法调用等}</strong><br>可以嵌入任何有效的JavaScript代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"李四"</span>;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">`欢迎你<span class="subst">$&#123;name&#125;</span>同学`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br></pre></td></tr></table></figure>
<h4 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h4><h5 id="什么是模板标签"><a href="#什么是模板标签" class="headerlink" title="什么是模板标签"></a>什么是模板标签</h5><blockquote>
<p>模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = myTag<span class="string">`Hello world`</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的代码中，myTag就是模板标签。<br>myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。</p>
</blockquote>
<h5 id="定义模板标签"><a href="#定义模板标签" class="headerlink" title="定义模板标签"></a>定义模板标签</h5><blockquote>
<p>一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。<br>标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'张三'</span>,</span><br><span class="line">    age = <span class="number">20</span>,</span><br><span class="line">    message = show<span class="string">`我来给大家介绍<span class="subst">$&#123;name&#125;</span>的年龄是<span class="subst">$&#123;age&#125;</span>.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应该定义一个函数show：</span></span><br><span class="line"><span class="comment">    参数1：一个字符串数组。在本例中包含三个元素。</span></span><br><span class="line"><span class="comment">            0:"我来给大家介绍"</span></span><br><span class="line"><span class="comment">            1:"的年龄是"</span></span><br><span class="line"><span class="comment">            2:"."</span></span><br><span class="line"><span class="comment">    参数2和参数3：表示需要置换的字符串的值。  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">stringArr, value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stringArr); <span class="comment">//</span></span><br><span class="line">    <span class="built_in">console</span>.log(value1);  <span class="comment">// 张三</span></span><br><span class="line">    <span class="built_in">console</span>.log(value2);  <span class="comment">// 20</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">//abc</span></span><br></pre></td></tr></table></figure></p>
<p>为了简化书写，一般把Value1和Value2写成剩余字符串的形式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// blabla...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构的实用性"><a href="#解构的实用性" class="headerlink" title="解构的实用性"></a>解构的实用性</h3><blockquote>
<p>在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">        repeat: <span class="literal">true</span>,</span><br><span class="line">        save: <span class="literal">false</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从对象中提取数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> repeat = options.repeat,</span><br><span class="line">    save = options.save;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。</p>
<p>这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。</p>
</blockquote>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><h4 id="对象解构的基本形式"><a href="#对象解构的基本形式" class="headerlink" title="对象解构的基本形式"></a>对象解构的基本形式</h4><blockquote>
<p>对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">        type: <span class="string">"Identifier"</span>,</span><br><span class="line">        name: <span class="string">"foo"</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//这里就相当于声明了两个变量： type = node.type;  name:node.name</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的结构中必须要初始化。否则会出现语法错误。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">var</span> &#123; type, name &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">const</span> &#123; type, name &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解构赋值表达式"><a href="#解构赋值表达式" class="headerlink" title="解构赋值表达式"></a>解构赋值表达式</h4><blockquote>
<p>如果声明的变量想改变他们的值，也可以使用解构表达式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;,</span><br><span class="line">type = <span class="string">"Literal"</span>,</span><br><span class="line">name = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：此处必须要在圆括号内才能使用解构表达式</span></span><br><span class="line">(&#123;type, name&#125; = node);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo""</span></span><br></pre></td></tr></table></figure>
<h4 id="对象解构时的默认值"><a href="#对象解构时的默认值" class="headerlink" title="对象解构时的默认值"></a>对象解构时的默认值</h4><blockquote>
<p>如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">        type: <span class="string">"Identifier"</span>,</span><br><span class="line">        name: <span class="string">"foo"</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//因为node中没有叫value的属性，所以valued的值将会是undefined</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手动添加value的默认值为3</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="number">3</span>&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值给不同的变量名"><a href="#赋值给不同的变量名" class="headerlink" title="赋值给不同的变量名"></a>赋值给不同的变量名</h4><blockquote>
<p>在前面的操作中，都是把对象的属性值，赋值给同名变量。<br>其实也可以赋值给不同名的变量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// localType才是要定义的新的变量。  type是node的属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><h4 id="数组解构基本语法"><a href="#数组解构基本语法" class="headerlink" title="数组解构基本语法"></a>数组解构基本语法</h4><blockquote>
<p>数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只想取数组中的某一项，则可以不用命名。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="comment">//只取数组中的第三项。</span></span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thirdColor);        <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>
<h4 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h4><blockquote>
<p>你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</span><br><span class="line">    firstColor = <span class="string">"black"</span>,</span><br><span class="line">    secondColor = <span class="string">"purple"</span>;</span><br><span class="line"></span><br><span class="line">[ firstColor, secondColor ] = colors;  <span class="comment">//可以不用加括号。当然添加也不犯法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>,</span><br><span class="line">    b = <span class="number">4</span>,</span><br><span class="line">    temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>,</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。</span></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<h2 id="新的基本类型：Symbol"><a href="#新的基本类型：Symbol" class="headerlink" title="新的基本类型：Symbol"></a>新的基本类型：Symbol</h2><blockquote>
<p>以前我们有5种基本数据类型：Number、String、Boolean、Null、Undefined<br>ES6新增了一种新的数据类型：Symbol<br>在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。</p>
<h3 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h3><p>Symbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。<br>我们可以使用symbol全局函数来创建Symbol。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();   <span class="comment">//创建一个Symbol</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">person[firstName] = <span class="string">"张三"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]);     <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure>
<p>说明：上面的代码中，firstName作为symbol类型被创建并赋值给 person对象以作其属性。每次访问这个属性时必须使用该 symbol。</p>
<blockquote>
<p>在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1 == s2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。</p>
</blockquote>
<h3 id="识别Symbol"><a href="#识别Symbol" class="headerlink" title="识别Symbol"></a>识别Symbol</h3><blockquote>
<p>既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol);         <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol作为属性名"><a href="#Symbol作为属性名" class="headerlink" title="Symbol作为属性名"></a>Symbol作为属性名</h3><p>​由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br>1,symbol作为对象的属性的时候，只能使用[ ]去访问，不能使用点去访问。<br>2,symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。</p>
<h3 id="Symbol属性名的遍历"><a href="#Symbol属性名的遍历" class="headerlink" title="Symbol属性名的遍历"></a>Symbol属性名的遍历</h3><p>​ Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol属性名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"><span class="comment">// 返回obj对象所有Symbol类型的属性名组成的数组。</span></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)  <span class="comment">//[Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>看下面代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line">obj[foo] = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出 。   因为遍历不到Symbol型的属性 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj);<span class="comment">// []   只能拿到非Symbol类型的属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">//[Symbol(foo)]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。<br>Reflect.ownKeys()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj);<span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>
<p>说明：由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<h3 id="Symbol-for-字符串-和Symbol-keyFor-symbol类型的值"><a href="#Symbol-for-字符串-和Symbol-keyFor-symbol类型的值" class="headerlink" title="Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)"></a>Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)</h3><blockquote>
<p>Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个symbol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="comment">//第二次搜到上次创建的</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);  <span class="comment">//因为两次搜到的是同一个Symbol，所以此处是true</span></span><br></pre></td></tr></table></figure>
<p>Symbol.for()和Symbol()都可以创建Symbol类型的数据。<br>二者区别：<br>1，Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。<br>2，Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(a)); <span class="comment">// undefined.   因为a没有想全局环境中登记，所以是undefinded</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(b)); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<h2 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h2><p>​JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。</p>
<p>​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。</p>
<blockquote>
<p>Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set中的元素不能重复，而数组中的元素可以重复。</p>
<p>一句话总结：Set类型是一个包含无重复元素的有序列表</p>
</blockquote>
<h3 id="创建Set和并添加元素"><a href="#创建Set和并添加元素" class="headerlink" title="创建Set和并添加元素"></a>创建Set和并添加元素</h3><blockquote>
<p>Set本身是一个构造函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Set数据结构对象。</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">//调用set对象的add方法，向set中添加元素</span></span><br><span class="line">s.add(<span class="string">"a"</span>);</span><br><span class="line">s.add(<span class="string">"c"</span>);</span><br><span class="line">s.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="comment">//set的size属性可以获取set中元素的个数</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size)</span><br></pre></td></tr></table></figure>
<h3 id="Set中不能添加重复元素"><a href="#Set中不能添加重复元素" class="headerlink" title="Set中不能添加重复元素"></a>Set中不能添加重复元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="string">"a"</span>);</span><br><span class="line">s.add(<span class="string">"c"</span>);</span><br><span class="line">s.add(<span class="string">"b"</span>);</span><br><span class="line">s.add(<span class="string">"a"</span>);  <span class="comment">//重复，所以添加失败。注意这个地方并不会保存。</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 长度是3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看下面代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(<span class="number">5</span>);</span><br><span class="line">s.add(<span class="string">"5"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 长度是2</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，数字5和字符串5都会添加成功。为什么呢？</p>
<blockquote>
<p>Set是使用什么机制来判断两个元素是否相等的呢？<br><strong>是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。</strong><br>回忆一下：这个方法除了 +0和-0、NaN和NaN认为相等，其余和三个 === 是完全一样的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.add(+<span class="number">0</span>);</span><br><span class="line">s.add(<span class="number">-0</span>);  <span class="comment">//重复添加不进去</span></span><br><span class="line">s.add(<span class="literal">NaN</span>);</span><br><span class="line">s.add(<span class="literal">NaN</span>); <span class="comment">//重复添加不进去</span></span><br><span class="line">s.add([]);</span><br><span class="line">s.add([]);  <span class="comment">//两个空数组不相等，所以可以添加进去</span></span><br><span class="line">s.add(&#123;&#125;);</span><br><span class="line">s.add(&#123;&#125;);  <span class="comment">// 两个空对象也不重复，所以也可以添加进去</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 长度是6</span></span><br></pre></td></tr></table></figure>
<h3 id="使用数组初始化Set"><a href="#使用数组初始化Set" class="headerlink" title="使用数组初始化Set"></a>使用数组初始化Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.size);</span><br></pre></td></tr></table></figure>
<h3 id="判断一个值是否在Set中"><a href="#判断一个值是否在Set中" class="headerlink" title="判断一个值是否在Set中"></a>判断一个值是否在Set中</h3><blockquote>
<p>使用Set的 has() 方法可以判断一个值是否在这个set中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">5</span>);</span><br><span class="line">set.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">6</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="移除Set中的元素"><a href="#移除Set中的元素" class="headerlink" title="移除Set中的元素"></a>移除Set中的元素</h3><blockquote>
<p>delete(要删除的值) ：删除单个值<br>clear()：清空所有的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">5</span>);</span><br><span class="line">set.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">set.delete(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="string">"5"</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h3><blockquote>
<p>数组有个方法forEach可以遍历数组。<br>Set也有forEach可以遍历Set。<br>使用Set的forEach遍历时的回调函数有三个参数：<br>function (value, key, ownerSet){</p>
<p>}<br>参数1：遍历到的元素的值<br>参数2：对set集合来说，参数2的值和参数1的值是完全一样的。<br>参数3：这个set自己</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">v, k, s</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v + <span class="string">"   "</span> + (v === k) + <span class="string">"  "</span> + (s === set));   <span class="comment">// 永远是true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="将Set转换为数组"><a href="#将Set转换为数组" class="headerlink" title="将Set转换为数组"></a>将Set转换为数组</h3><blockquote>
<p>将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。<br>把Set转换为数组使用前面讲到的扩展运算符也很容易</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]),</span><br><span class="line">    arr = [...set];  <span class="comment">//使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);             <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种情况在需要去数组中重复元素的时候非常好用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(items)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="comment">//返回的是新的没有重复元素的数组。</span></span><br><span class="line">    noDuplicates = eliminateDuplicates(numbers);</span><br><span class="line"><span class="built_in">console</span>.log(noDuplicates);      <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><em>Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map.</em></p>
<h2 id="Map数据结构"><a href="#Map数据结构" class="headerlink" title="Map数据结构"></a>Map数据结构</h2><p>​ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。</p>
<p>​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。</p>
<p>​这和使用对象属性做为值的方法大相径庭，因为 对象的属性会被强制转换为字符串类型。</p>
<h3 id="创建Map对象和Map的基本的存取操作"><a href="#创建Map对象和Map的基本的存取操作" class="headerlink" title="创建Map对象和Map的基本的存取操作"></a>创建Map对象和Map的基本的存取操作</h3><blockquote>
<p>Map创建也是使用Map构造函数<br>向Map存储键值对使用set(key, value);方法<br>可以使用get(key),来获取指定key对应的value</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">"a"</span>, <span class="string">"lisi"</span>);</span><br><span class="line">map.set(<span class="string">"b"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">map.set(<span class="string">"b"</span>, <span class="string">"zhangsan222"</span>);  <span class="comment">// 第二次添加，新的value会替换掉旧的</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"a"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"b"</span>));   <span class="comment">//zhangsan222</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"c"</span>)); <span class="comment">//undefined.如果key不存在，则返回undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h3 id="Map与Set类似的3个方法"><a href="#Map与Set类似的3个方法" class="headerlink" title="Map与Set类似的3个方法"></a>Map与Set类似的3个方法</h3><ul>
<li>has(key) - 判断给定的 key 是否在 map 中存在</li>
<li>delete(key) - 移除 map 中的 key 及对应的值</li>
<li>clear() - 移除 map 中所有的键值对</li>
</ul>
<h3 id="初始化Map"><a href="#初始化Map" class="headerlink" title="初始化Map"></a>初始化Map</h3><blockquote>
<p>创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。<br>也就是传入的实际是一个二维数组！</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map接受一个二维数组</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    <span class="comment">//每一个数组中，第一个是map的key，第二个是map的value。如果只有第一个，则值是undefined</span></span><br><span class="line">    [<span class="string">"name"</span>, <span class="string">"lisi"</span>],  </span><br><span class="line">    [<span class="string">"age"</span>, <span class="number">20</span>],</span><br><span class="line">    [<span class="string">"sex"</span>, <span class="string">"nan"</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">console</span>.log(map.size);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Map的forEach方法"><a href="#Map的forEach方法" class="headerlink" title="Map的forEach方法"></a>Map的forEach方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">"name"</span>, <span class="string">"李四"</span>],</span><br><span class="line">    [<span class="string">"age"</span>, <span class="number">20</span>],</span><br><span class="line">    [<span class="string">"sex"</span>, <span class="string">"nan"</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    回调函数有三个参数：</span></span><br><span class="line"><span class="comment">    参数1：键值对的value</span></span><br><span class="line"><span class="comment">    参数2：键值对的key</span></span><br><span class="line"><span class="comment">    参数3：map对象本身</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, ownMap</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`key=<span class="subst">$&#123;key&#125;</span> ,vlue=<span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="迭代器和for…of循环"><a href="#迭代器和for…of循环" class="headerlink" title="迭代器和for…of循环"></a>迭代器和for…of循环</h2><h3 id="循环问题"><a href="#循环问题" class="headerlink" title="循环问题"></a>循环问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = colors.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(colors[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。<br>迭代器就是为了解决这个问题的。</p>
</blockquote>
<h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>​ 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。</p>
<p>​ 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。</p>
<blockquote>
<p>我们可以使用ES5知识创建一个迭代器</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= items.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个可以在指定数组上面迭代的迭代器对象。</span></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for all further calls</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<p>从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。<br>幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。</p>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><blockquote>
<p><strong>生成器函数就是返回迭代器的函数！</strong><br>生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。<br>看下面代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成器函数。  注意中间的 * 不能丢</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每个yield的后面的值表示我们迭代到的值。   yield也定义了我们迭代的顺序。</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = createIterator();</span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);   <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。</strong><br>每调用一次迭代器的next方法，如果碰到yield都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用next方法，会从上次停止的地方继续执行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      <span class="comment">//每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125;</span></span><br><span class="line">        <span class="keyword">yield</span> items[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步调用</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。</p>
</blockquote>
<h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><blockquote>
<p>你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步调用</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：无法使用箭头函数来创建生成器。</p>
</blockquote>
<h3 id="可迭代类型和for-of迭代循环"><a href="#可迭代类型和for-of迭代循环" class="headerlink" title="可迭代类型和for-of迭代循环"></a>可迭代类型和for-of迭代循环</h3><blockquote>
<p>迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。</p>
</blockquote>
<p>​与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。<br>​该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。<br>​换句话说，默认情况下只有 数组、set、Map和字符串才可以使用迭代器去迭代。 (也就可以使用for…of了)<br>​for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！</p>
<blockquote>
<p>使用 for…of 迭代数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 for…of 迭代Set:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> set)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 for…of 迭代Map：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>, <span class="string">"lisi"</span>],[<span class="string">"sex"</span>, <span class="string">"男"</span>],[<span class="string">"age"</span>, <span class="number">20</span>]]);</span><br><span class="line">map.set(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);  <span class="comment">//注意：这里迭代到的是由key和value组成的数组。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用for … of迭代字符串</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> s)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常。</p>
</blockquote>
<p>说明：以数组为例。</p>
<p>​ for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。</p>
<p>​ 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。</p>
<h3 id="访问可迭代类型的默认迭代器"><a href="#访问可迭代类型的默认迭代器" class="headerlink" title="访问可迭代类型的默认迭代器"></a>访问可迭代类型的默认迭代器</h3><blockquote>
<p>Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">let</span> it = s[<span class="built_in">Symbol</span>.iterator]();  <span class="comment">//调用字符串的Symbol.iterator方法</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());  <span class="comment">//返回迭代器迭代到的第一个对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(&#123;<span class="string">"name"</span>:<span class="string">"李四"</span>&#125;)); <span class="comment">// false。普通对象不可迭代</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义可迭代类型"><a href="#自定义可迭代类型" class="headerlink" title="自定义可迭代类型"></a>自定义可迭代类型</h3><blockquote>
<p>开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items: [],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">collection.items.push(<span class="number">1</span>);</span><br><span class="line">collection.items.push(<span class="number">2</span>);</span><br><span class="line">collection.items.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote>
<p>和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。<br>这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。<br>尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。</p>
</blockquote>
<h3 id="ES5之前的模拟的类"><a href="#ES5之前的模拟的类" class="headerlink" title="ES5之前的模拟的类"></a>ES5之前的模拟的类</h3><p>​在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">"Nicholas"</span>);</span><br><span class="line">person.sayName();   <span class="comment">// 输出 "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>说明：前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。</p>
<h3 id="ES6中基本的类声明"><a href="#ES6中基本的类声明" class="headerlink" title="ES6中基本的类声明"></a>ES6中基本的类声明</h3><blockquote>
<p>在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class关键字必须是小写。   后面就是跟的类名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等效于 PersonType 构造函数。</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;  <span class="comment">//这个表示类的构造函数。constuctor也是关键字必须小写。</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;  <span class="comment">//创建属性。  也叫当前类型的自有属性。</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName.   这里的sayName使用了我们前面的简写的方式。</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</span><br><span class="line">person.sayName();   <span class="comment">// 输出 "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);                    <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);  <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>
<p>说明：<br>1，自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。<br>2，类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。</p>
<p><strong>虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记:</strong><br>1，类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。<br>2，类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。<br>3，所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。<br>4，所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。<br>5，不使用 new 来调用类构造函数会抛出错误。也就是 必须使用new 类() 的方式使用<br>6，试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的）</p>
<h3 id="匿名类表达式"><a href="#匿名类表达式" class="headerlink" title="匿名类表达式"></a>匿名类表达式</h3><blockquote>
<p>函数有函数表达式，类也有类表达式。<br>类表达式的功能和前面的类的声明是一样的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等效于 PersonType 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</span><br><span class="line">person.sayName();   <span class="comment">// 输出 "Nicholas"</span></span><br></pre></td></tr></table></figure>
<h3 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效于 PersonType 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的.</p>
</blockquote>
<h3 id="作为一等公民的类型"><a href="#作为一等公民的类型" class="headerlink" title="作为一等公民的类型"></a>作为一等公民的类型</h3><blockquote>
<p>在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。<br>类也是一等公民。</p>
</blockquote>
<p>类可以作为参数传递<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">classDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.sayHi();        <span class="comment">// "Hi!"</span></span><br></pre></td></tr></table></figure></p>
<p>立即调用类构造函数，创建单例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;(<span class="string">"Nicholas"</span>);</span><br><span class="line"></span><br><span class="line">person.sayName();       <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="动态计算类成员的命名"><a href="#动态计算类成员的命名" class="headerlink" title="动态计算类成员的命名"></a>动态计算类成员的命名</h3><blockquote>
<p>类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">"sayName"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</span><br><span class="line">me.sayName();           <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><blockquote>
<p>在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法。  直接添加到构造方法上。  (其实是把构造函数当做一个普通的对象来用。)</span></span><br><span class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">"Nicholas"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的create方法在其他语言中一般都是作为静态方法来使用的。<br>ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效于 PersonType 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等效于 PersonType.create。</span></span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">"Nicholas"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：静态成员通过实例对象不能访问，只能通过类名访问！！！</p>
</blockquote>
<h3 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a>ES6中的继承</h3><blockquote>
<p>在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="string">"儿子"</span>, <span class="number">20</span>);</span><br><span class="line">son1.sayAge();  <span class="comment">//20</span></span><br><span class="line">son1.sayName(); <span class="comment">//儿子</span></span><br></pre></td></tr></table></figure>
<h4 id="继承的基本写法"><a href="#继承的基本写法" class="headerlink" title="继承的基本写法"></a>继承的基本写法</h4><blockquote>
<p>如果在ES6通过类的方式完成继承就简单了很多。<br>需要用到一个新的关键字：extends</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  <span class="comment">//extents后面跟表示要继承的类型</span></span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);  <span class="comment">//相当于以前的：Father.call(this, name);</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类独有的方法</span></span><br><span class="line">    sayAge()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="string">"李四"</span>, <span class="number">30</span>);</span><br><span class="line">son1.sayAge();</span><br><span class="line">son1.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(son1 <span class="keyword">instanceof</span> Son);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(son1 <span class="keyword">instanceof</span> Father);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><em>这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。</em><br><strong>关于super的使用，有几点需要注意：</strong><br>1，你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。<br>2，你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。<br>3，在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。</p>
<h4 id="在子类中屏蔽父类的方法"><a href="#在子类中屏蔽父类的方法" class="headerlink" title="在子类中屏蔽父类的方法"></a>在子类中屏蔽父类的方法</h4><blockquote>
<p>如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  <span class="comment">//extents后面跟表示要继承的类型</span></span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);  <span class="comment">//相当于以前的：Father.call(this, name);</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类独有的方法</span></span><br><span class="line">    sayAge()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类中的方法会屏蔽到父类中的同名方法。</span></span><br><span class="line">    sayName()&#123;</span><br><span class="line">            <span class="keyword">super</span>.syaName();  <span class="comment">//调用被覆盖的父类中的方法。 </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是子类的方法，我屏蔽了父类："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="string">"李四"</span>, <span class="number">30</span>);</span><br><span class="line">son1.sayAge();</span><br><span class="line">son1.sayName();</span><br></pre></td></tr></table></figure>
<p>如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。<br>注意：<br>1，如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法<br>2，普通方法调用需要使用super.父类的方法() 来调用。</p>
<h4 id="静态方法也可以继承"><a href="#静态方法也可以继承" class="headerlink" title="静态方法也可以继承"></a>静态方法也可以继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> foo()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是父类的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Son.foo(); <span class="comment">//子类也继承了父类的静态方法。  这种方式调用和直接通过父类名调用时一样的。</span></span><br></pre></td></tr></table></figure>
<h2 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h2><blockquote>
<p>JavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。<br>其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。<br>当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。<br>ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。</p>
</blockquote>
<h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>​ 模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义：</p>
<ol>
<li>模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。</li>
<li>模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。</li>
<li>模块顶级作用域中的 this 为 undefined 。</li>
<li>模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。</li>
<li>模块必须输出可被模块外部代码使用的相关内容。</li>
<li>一个模块可以引入另外的模块。</li>
</ol>
<h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>​ 可以使用 export 关键字来对外暴露模块中的部分代码。<br>​ 一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> magicNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数没有使用export关键字   所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以把这个函数的引用导出。  和导出函数是一样的。</span></span><br><span class="line"><span class="keyword">export</span> &#123; multiply &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><blockquote>
<p>一旦有了导出内容的模块，则可以在另一个模块中使用import关键字来获取他们。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1, identifier2 &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</span><br></pre></td></tr></table></figure>
<p>​ import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）。浏览器中的 <code>&lt;script&gt;</code>元素也使用了这个路径形式，意味着它必须包含文件扩展名。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持是对我最大的鼓励！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Jay Bein 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Jay Bein 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ES6/" rel="tag"># ES6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/20/JavaScript特效三大系列总结/" rel="next" title="JavaScript特效三大系列总结">
                <i class="fa fa-chevron-left"></i> JavaScript特效三大系列总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/01/剖析let-const在for循环中的作用原理/" rel="prev" title="剖析let/const在for循环中的作用原理">
                剖析let/const在for循环中的作用原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yODMwNC80ODc2"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Jay Bein" />
            
              <p class="site-author-name" itemprop="name">Jay Bein</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CallmeJay" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jaybein1209@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/mqyqingfeng/Blog" title="mqyqingfeng" target="_blank">mqyqingfeng</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/wxyyxc1992/Web-Series" title="Web-Series" target="_blank">Web-Series</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/InterviewMap/CS-Interview-Knowledge-Map" title="InterviewMap" target="_blank">InterviewMap</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/KieSun/Front-end-knowledge" title="KieSun" target="_blank">KieSun</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/amandakelake/blog" title="amandakelake" target="_blank">amandakelake</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.kancloud.cn/dennis/tgjavascript/241800" title="JavaScript半知半解" target="_blank">JavaScript半知半解</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6简介"><span class="nav-number">1.</span> <span class="nav-text">ES6简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#块级作用域"><span class="nav-number">2.</span> <span class="nav-text">块级作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let声明"><span class="nav-number">2.1.</span> <span class="nav-text">let声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const声明-Constant-Declarations"><span class="nav-number">2.2.</span> <span class="nav-text">const声明(Constant Declarations)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环中的块级绑定"><span class="nav-number">2.3.</span> <span class="nav-text">循环中的块级绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环中的函数"><span class="nav-number">2.4.</span> <span class="nav-text">循环中的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的新增特性"><span class="nav-number">3.</span> <span class="nav-text">函数的新增特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#带默认参数的函数"><span class="nav-number">3.1.</span> <span class="nav-text">带默认参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认参数对-arguments-对象的影响"><span class="nav-number">3.2.</span> <span class="nav-text">默认参数对 arguments 对象的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认参数表达式-Default-Parameter-Expressions"><span class="nav-number">3.3.</span> <span class="nav-text">默认参数表达式 (Default Parameter Expressions)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未命名参数问题"><span class="nav-number">3.4.</span> <span class="nav-text">未命名参数问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数中的扩展运算符"><span class="nav-number">3.5.</span> <span class="nav-text">函数中的扩展运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全新的函数：箭头函数（-gt-）"><span class="nav-number">4.</span> <span class="nav-text">全新的函数：箭头函数（=&gt;）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#箭头函数语法"><span class="nav-number">4.1.</span> <span class="nav-text">箭头函数语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用箭头函数实现函数自执行"><span class="nav-number">4.2.</span> <span class="nav-text">使用箭头函数实现函数自执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#箭头函数中无this绑定-No-this-Binding"><span class="nav-number">4.3.</span> <span class="nav-text">箭头函数中无this绑定(No this Binding)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无arguments绑定"><span class="nav-number">4.4.</span> <span class="nav-text">无arguments绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象功能的扩展"><span class="nav-number">5.</span> <span class="nav-text">对象功能的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象类别"><span class="nav-number">5.1.</span> <span class="nav-text">对象类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象字面量的语法扩展"><span class="nav-number">5.2.</span> <span class="nav-text">对象字面量的语法扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简写的属性初始化"><span class="nav-number">5.2.1.</span> <span class="nav-text">简写的属性初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简写的方法声明"><span class="nav-number">5.2.2.</span> <span class="nav-text">简写的方法声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在字面量中动态计算属性名"><span class="nav-number">5.2.3.</span> <span class="nav-text">在字面量中动态计算属性名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新增的方法"><span class="nav-number">5.3.</span> <span class="nav-text">新增的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-is"><span class="nav-number">5.3.1.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-assign"><span class="nav-number">5.3.2.</span> <span class="nav-text">Object.assign()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串功能的增强"><span class="nav-number">6.</span> <span class="nav-text">字符串功能的增强</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找子字符串"><span class="nav-number">6.1.</span> <span class="nav-text">查找子字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#repeat方法"><span class="nav-number">6.2.</span> <span class="nav-text">repeat方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串模板字面量"><span class="nav-number">6.3.</span> <span class="nav-text">字符串模板字面量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本语法"><span class="nav-number">6.3.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多行字符串"><span class="nav-number">6.3.2.</span> <span class="nav-text">多行字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串置换"><span class="nav-number">6.3.3.</span> <span class="nav-text">字符串置换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板标签"><span class="nav-number">6.3.4.</span> <span class="nav-text">模板标签</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是模板标签"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">什么是模板标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#定义模板标签"><span class="nav-number">6.3.4.2.</span> <span class="nav-text">定义模板标签</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解构"><span class="nav-number">7.</span> <span class="nav-text">解构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解构的实用性"><span class="nav-number">7.1.</span> <span class="nav-text">解构的实用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象解构"><span class="nav-number">7.2.</span> <span class="nav-text">对象解构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象解构的基本形式"><span class="nav-number">7.2.1.</span> <span class="nav-text">对象解构的基本形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构赋值表达式"><span class="nav-number">7.2.2.</span> <span class="nav-text">解构赋值表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象解构时的默认值"><span class="nav-number">7.2.3.</span> <span class="nav-text">对象解构时的默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#赋值给不同的变量名"><span class="nav-number">7.2.4.</span> <span class="nav-text">赋值给不同的变量名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组解构"><span class="nav-number">7.3.</span> <span class="nav-text">数组解构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组解构基本语法"><span class="nav-number">7.3.1.</span> <span class="nav-text">数组解构基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构表达式"><span class="nav-number">7.3.2.</span> <span class="nav-text">解构表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新的基本类型：Symbol"><span class="nav-number">8.</span> <span class="nav-text">新的基本类型：Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Symbol"><span class="nav-number">8.1.</span> <span class="nav-text">创建Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#识别Symbol"><span class="nav-number">8.2.</span> <span class="nav-text">识别Symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol作为属性名"><span class="nav-number">8.3.</span> <span class="nav-text">Symbol作为属性名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol属性名的遍历"><span class="nav-number">8.4.</span> <span class="nav-text">Symbol属性名的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol-for-字符串-和Symbol-keyFor-symbol类型的值"><span class="nav-number">8.5.</span> <span class="nav-text">Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set数据结构"><span class="nav-number">9.</span> <span class="nav-text">Set数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Set和并添加元素"><span class="nav-number">9.1.</span> <span class="nav-text">创建Set和并添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set中不能添加重复元素"><span class="nav-number">9.2.</span> <span class="nav-text">Set中不能添加重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用数组初始化Set"><span class="nav-number">9.3.</span> <span class="nav-text">使用数组初始化Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一个值是否在Set中"><span class="nav-number">9.4.</span> <span class="nav-text">判断一个值是否在Set中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移除Set中的元素"><span class="nav-number">9.5.</span> <span class="nav-text">移除Set中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历Set"><span class="nav-number">9.6.</span> <span class="nav-text">遍历Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将Set转换为数组"><span class="nav-number">9.7.</span> <span class="nav-text">将Set转换为数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map数据结构"><span class="nav-number">10.</span> <span class="nav-text">Map数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Map对象和Map的基本的存取操作"><span class="nav-number">10.1.</span> <span class="nav-text">创建Map对象和Map的基本的存取操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map与Set类似的3个方法"><span class="nav-number">10.2.</span> <span class="nav-text">Map与Set类似的3个方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化Map"><span class="nav-number">10.3.</span> <span class="nav-text">初始化Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map的forEach方法"><span class="nav-number">10.4.</span> <span class="nav-text">Map的forEach方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器和for…of循环"><span class="nav-number">11.</span> <span class="nav-text">迭代器和for…of循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#循环问题"><span class="nav-number">11.1.</span> <span class="nav-text">循环问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是迭代器"><span class="nav-number">11.2.</span> <span class="nav-text">什么是迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器函数"><span class="nav-number">11.3.</span> <span class="nav-text">生成器函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器函数表达式"><span class="nav-number">11.4.</span> <span class="nav-text">生成器函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可迭代类型和for-of迭代循环"><span class="nav-number">11.5.</span> <span class="nav-text">可迭代类型和for-of迭代循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问可迭代类型的默认迭代器"><span class="nav-number">11.6.</span> <span class="nav-text">访问可迭代类型的默认迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义可迭代类型"><span class="nav-number">11.7.</span> <span class="nav-text">自定义可迭代类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">12.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ES5之前的模拟的类"><span class="nav-number">12.1.</span> <span class="nav-text">ES5之前的模拟的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6中基本的类声明"><span class="nav-number">12.2.</span> <span class="nav-text">ES6中基本的类声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名类表达式"><span class="nav-number">12.3.</span> <span class="nav-text">匿名类表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具名类表达式"><span class="nav-number">12.4.</span> <span class="nav-text">具名类表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为一等公民的类型"><span class="nav-number">12.5.</span> <span class="nav-text">作为一等公民的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态计算类成员的命名"><span class="nav-number">12.6.</span> <span class="nav-text">动态计算类成员的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态成员"><span class="nav-number">12.7.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6中的继承"><span class="nav-number">12.8.</span> <span class="nav-text">ES6中的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的基本写法"><span class="nav-number">12.8.1.</span> <span class="nav-text">继承的基本写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在子类中屏蔽父类的方法"><span class="nav-number">12.8.2.</span> <span class="nav-text">在子类中屏蔽父类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法也可以继承"><span class="nav-number">12.8.3.</span> <span class="nav-text">静态方法也可以继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Moudle"><span class="nav-number">13.</span> <span class="nav-text">Moudle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是模块"><span class="nav-number">13.1.</span> <span class="nav-text">什么是模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导出模块"><span class="nav-number">13.2.</span> <span class="nav-text">导出模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入模块"><span class="nav-number">13.3.</span> <span class="nav-text">引入模块</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jay Bein</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
