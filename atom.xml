<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay&#39;s Blog</title>
  <subtitle>对不起，我要赢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://callmejay.github.io/"/>
  <updated>2018-03-17T09:23:51.846Z</updated>
  <id>https://callmejay.github.io/</id>
  
  <author>
    <name>Jay Bein</name>
    <email>291977464@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="https://callmejay.github.io/2018/03/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://callmejay.github.io/2018/03/17/排序算法/</id>
    <published>2018-03-17T09:19:10.000Z</published>
    <updated>2018-03-17T09:23:51.846Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6入门之对象的扩展</title>
    <link href="https://callmejay.github.io/2018/03/13/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://callmejay.github.io/2018/03/13/ES6入门之对象的扩展/</id>
    <published>2018-03-13T13:29:47.000Z</published>
    <updated>2018-03-16T15:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性的简洁表示"><a href="#属性的简洁表示" class="headerlink" title="属性的简洁表示"></a>属性的简洁表示</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</div><div class="line">baz <span class="comment">// &#123;foo: 'bar'&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></div></pre></td></tr></table></figure></p>
<p>除了属性简写，方法也可以简写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> o = &#123;</div><div class="line">  method() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">const</span> o = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面是一个实际的例子.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> birth = <span class="string">'2000/01/01'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Person = &#123;</div><div class="line"></div><div class="line">  <span class="attr">name</span>: <span class="string">'张三'</span>,</div><div class="line"></div><div class="line">  <span class="comment">//等同于birth: birth</span></div><div class="line">  birth,</div><div class="line"></div><div class="line">  <span class="comment">// 等同于hello: function ()...</span></div><div class="line">  hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这种写法用于函数的返回值，将会非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</div><div class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</div><div class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getPoint()</div><div class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></div></pre></td></tr></table></figure></p>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ms = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">  ms[key] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ms = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123; getItem, setItem, clear &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">getItem</span>: getItem,</div><div class="line">  <span class="attr">setItem</span>: setItem,</div><div class="line">  <span class="attr">clear</span>: clear</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cart = &#123;</div><div class="line">  <span class="attr">_wheels</span>: <span class="number">4</span>,</div><div class="line"></div><div class="line">  get wheels () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  set wheels (value) &#123;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数值太小了！'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>._wheels = value;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> () </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个<code>Generator</code>函数，前面需要加上星号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  * m() &#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>JavaScript 定义对象的属性，有两种方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line">obj.foo = <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 方法二</span></div><div class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = <span class="number">123</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">abc</span>: <span class="number">123</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [propKey]: <span class="literal">true</span>,</div><div class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面是另一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> lastWord = <span class="string">'last word'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> a = &#123;</div><div class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</div><div class="line">  [lastWord]: <span class="string">'world'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">a[<span class="string">'first word'</span>] <span class="comment">// "hello"</span></div><div class="line">a[lastWord] <span class="comment">// "world"</span></div><div class="line">a[<span class="string">'last word'</span>] <span class="comment">// "world"</span></div></pre></td></tr></table></figure></p>
<p>表达式还可以用于定义方法名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.hello() <span class="comment">// hi</span></div></pre></td></tr></table></figure></p>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">const</span> bar = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">const</span> baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myObject = &#123;</div><div class="line">  [keyA]: <span class="string">'valueA'</span>,</div><div class="line">  [keyB]: <span class="string">'valueB'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject <span class="comment">// Object &#123;[object Object]: "valueB"&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = &#123;</div><div class="line">  sayName() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">person.sayName.name   <span class="comment">// "sayName"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，方法的name属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  get foo() &#123;&#125;,</div><div class="line">  set foo(x) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.foo.name</div><div class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"></div><div class="line">descriptor.get.name <span class="comment">// "get foo"</span></div><div class="line">descriptor.set.name <span class="comment">// "set foo"</span></div></pre></td></tr></table></figure></p>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回<code>anonymous</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// 'anonymous'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line">doSomething.bind().name <span class="comment">// 'bound doSomething'</span></div></pre></td></tr></table></figure></p>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>);</div><div class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [key1]() &#123;&#125;,</div><div class="line">  [key2]() &#123;&#125;,</div><div class="line">&#125;;</div><div class="line">obj[key1].name <span class="comment">// "[description]"</span></div><div class="line">obj[key2].name <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>key1</code>对应的 <code>Symbol</code> 值有描述，<code>key2</code>没有。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></div><div class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>ES5 可以通过下面的代码，部署Object.is。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'is'</span>, &#123;</div><div class="line">  <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x === y) &#123;</div><div class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></div><div class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 针对NaN的情况</span></div><div class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">writable</span>: <span class="literal">true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><hr>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></div></pre></td></tr></table></figure></p>
<p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>如果该参数不是对象，则会先转成对象，然后返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></div></pre></td></tr></table></figure></p>
<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></div><div class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="string">'abc'</span>) <span class="comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">'c'</span>&#125;,</div><div class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: <span class="string">'hello'</span></div><div class="line">  &#125;)</div><div class="line">)</div><div class="line"><span class="comment">// &#123; b: 'c' &#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为 <code>Symbol</code> 值的属性，也会被<code>Object.assign</code>拷贝。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="string">'b'</span> &#125;, &#123; [<span class="built_in">Symbol</span>(<span class="string">'c'</span>)]: <span class="string">'d'</span> &#125;)</div><div class="line"><span class="comment">// &#123; a: 'b', Symbol(c): 'd' &#125;</span></div></pre></td></tr></table></figure></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</div><div class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</div><div class="line"></div><div class="line">obj1.a.b = <span class="number">2</span>;</div><div class="line">obj2.a.b <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<h5 id="同名属性的替换"><a href="#同名属性的替换" class="headerlink" title="同名属性的替换"></a>同名属性的替换</h5><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</div><div class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</div><div class="line"><span class="built_in">Object</span>.assign(target, source)</div><div class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供<code>Object.assign</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p>
<h5 id="数组的处理"><a href="#数组的处理" class="headerlink" title="数组的处理"></a>数组的处理</h5><p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="comment">// [4, 5, 3]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。</p>
<h5 id="取值函数的处理"><a href="#取值函数的处理" class="headerlink" title="取值函数的处理"></a>取值函数的处理</h5><p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> source = &#123;</div><div class="line">  get foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source)</div><div class="line"><span class="comment">// &#123; foo: 1 &#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h4 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h4><p><code>Object.assign</code>方法有很多用处。</p>
<h5 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法通过<code>Object.assign</code>方法，将x属性和y属性添加到<code>Point</code>类的对象实例。</p>
<h5 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</div><div class="line">  someMethod(arg1, arg2) &#123;</div><div class="line">    <span class="comment">// ···</span></div><div class="line">  &#125;,</div><div class="line">  anotherMethod() &#123;</div><div class="line">    <span class="comment">// ···</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 等同于下面的写法</span></div><div class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</div><div class="line">  <span class="comment">// ···</span></div><div class="line">&#125;;</div><div class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ···</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<h5 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h5><p>将多个对象合并到某个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> merge =</div><div class="line">  <span class="function">(<span class="params">target, ...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(target, ...sources);</div></pre></td></tr></table></figure></p>
<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> merge =</div><div class="line">  <span class="function">(<span class="params">...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</div></pre></td></tr></table></figure></p>
<h5 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DEFAULTS = &#123;</div><div class="line">  <span class="attr">logLevel</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">outputFormat</span>: <span class="string">'html'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</div><div class="line">  <span class="built_in">console</span>.log(options);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> DEFAULTS = &#123;</div><div class="line">  <span class="attr">url</span>: &#123;</div><div class="line">    <span class="attr">host</span>: <span class="string">'example.com'</span>,</div><div class="line">    <span class="attr">port</span>: <span class="number">7070</span></div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">processContent(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码的原意是将<code>url.port</code>改成 <code>8000</code>，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<h3 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h3><hr>
<h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</div><div class="line"><span class="comment">//  &#123;</span></div><div class="line"><span class="comment">//    value: 123,</span></div><div class="line"><span class="comment">//    writable: true,</span></div><div class="line"><span class="comment">//    enumerable: true,</span></div><div class="line"><span class="comment">//    configurable: true</span></div><div class="line"><span class="comment">//  &#125;</span></div></pre></td></tr></table></figure></p>
<p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的length属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'toString'</span>).enumerable</div><div class="line"><span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 <code>Class</code> 的原型的方法都是不可枚举的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;foo() &#123;&#125;&#125;.prototype, <span class="string">'foo'</span>).enumerable</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<h5 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h5><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<h5 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h5><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<h5 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h5><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<h5 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h5><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</div><div class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。</p>
<h3 id="原型的操作方法"><a href="#原型的操作方法" class="headerlink" title="原型的操作方法"></a>原型的操作方法</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法.</p>
<h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__ 属性"></a>__proto__ 属性</h4><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// es6 的写法</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line">&#125;;</div><div class="line">obj.__proto__ = someOtherObj;</div><div class="line"></div><div class="line"><span class="comment">// es5 的写法</span></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(someOtherObj);</div><div class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</div></pre></td></tr></table></figure></p>
<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>, &#123;</div><div class="line">  get() &#123;</div><div class="line">    <span class="keyword">let</span> _thisObj = <span class="built_in">Object</span>(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(_thisObj);</div><div class="line">  &#125;,</div><div class="line">  set(proto) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">undefined</span> || <span class="keyword">this</span> === <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isObject(<span class="keyword">this</span>)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> status = <span class="built_in">Reflect</span>.setPrototypeOf(<span class="keyword">this</span>, proto);</div><div class="line">    <span class="keyword">if</span> (!status) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(value) === value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</div><div class="line"><span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 格式</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</div><div class="line"></div><div class="line"><span class="comment">// 用法</span></div><div class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<p>该方法等同于下面的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</div><div class="line">  obj.__proto__ = proto;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proto = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</div><div class="line"></div><div class="line">proto.y = <span class="number">20</span>;</div><div class="line">proto.z = <span class="number">40</span>;</div><div class="line"></div><div class="line">obj.x <span class="comment">// 10</span></div><div class="line">obj.y <span class="comment">// 20</span></div><div class="line">obj.z <span class="comment">// 40</span></div></pre></td></tr></table></figure></p>
<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">'foo'</span>, &#123;&#125;) === <span class="string">'foo'</span> <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">undefined</span>, &#123;&#125;)</div><div class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)</div><div class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></div></pre></td></tr></table></figure></p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</div></pre></td></tr></table></figure></p>
<p>下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>如果参数不是对象，会被自动转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</div><div class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String('foo'))</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>)</div><div class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) === <span class="built_in">Number</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>) === <span class="built_in">String</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) === <span class="built_in">Boolean</span>.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">null</span>)</div><div class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">undefined</span>)</div><div class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></div></pre></td></tr></table></figure></p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> proto = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="string">'hello'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="string">'world'</span>,</div><div class="line">  find() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</div><div class="line">obj.find() <span class="comment">// "hello"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>obj</code>的<code>find</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="keyword">super</span>.foo</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让<code>JavaScript</code>引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> proto = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="string">'hello'</span>,</div><div class="line">  foo() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">  &#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  <span class="attr">x</span>: <span class="string">'world'</span>,</div><div class="line">  foo() &#123;</div><div class="line">    <span class="keyword">super</span>.foo();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</div><div class="line"></div><div class="line">obj.foo() <span class="comment">// "world"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h3 id="遍历对象的方法"><a href="#遍历对象的方法" class="headerlink" title="遍历对象的方法"></a>遍历对象的方法</h3><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>ES5 引入了<code>bject.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>:<span class="string">'bar'</span>,<span class="attr">baz</span>:<span class="number">42</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.keys(obj);</div><div class="line"><span class="comment">// ["foo", "baz"]</span></div></pre></td></tr></table></figure></p>
<p>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 'a', 'b', 'c'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</div><div class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// ['a', 1], ['b', 2], ['c', 3]</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.values(obj)</div><div class="line"><span class="comment">// ["bar", 42]</span></div></pre></td></tr></table></figure></p>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.values(obj)</div><div class="line"><span class="comment">// ["b", "c", "a"]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>.</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</div><div class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性p的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>:</div><div class="line">  &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">42</span>,</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [42]</span></div></pre></td></tr></table></figure></p>
<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">'abc'</span> &#125;);</div><div class="line"><span class="comment">// ['abc']</span></div></pre></td></tr></table></figure></p>
<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.values(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// ['f', 'o', 'o']</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></div><div class="line"><span class="built_in">Object</span>.values(<span class="literal">true</span>) <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><p>《数组的扩展》一章中，已经介绍过扩展运算符（…）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// [2, 3]</span></div></pre></td></tr></table></figure></p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">null</span>; <span class="comment">// 运行时错误</span></div><div class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">undefined</span>; <span class="comment">// 运行时错误</span></div></pre></td></tr></table></figure></p>
<p>解构赋值必须是最后一个参数，否则会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = obj; <span class="comment">// 句法错误</span></div><div class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj; <span class="comment">// 句法错误</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</div><div class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</div><div class="line">obj.a.b = <span class="number">2</span>;</div><div class="line">x.a.b <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line">o2.__proto__ = o1;</div><div class="line"><span class="keyword">let</span> &#123; ...o3 &#125; = o2;</div><div class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></div><div class="line">o3.a <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>
<p>下面是另一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.create(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</div><div class="line">o.z = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。</p>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></div><div class="line">  <span class="comment">// 其余参数传给原始函数</span></div><div class="line">  <span class="keyword">return</span> baseFunction(restConfig);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</div><div class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></div></pre></td></tr></table></figure></p>
<p>这等同于使用Object.assign方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</div></pre></td></tr></table></figure></p>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">const</span> clone1 = &#123;</div><div class="line">  <span class="attr">__proto__</span>: <span class="built_in">Object</span>.getPrototypeOf(obj),</div><div class="line">  ...obj</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</div><div class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</div><div class="line">  obj</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// 写法三</span></div><div class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</div><div class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</div><div class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</div></pre></td></tr></table></figure></p>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> aWithOverrides = <span class="built_in">Object</span>.assign(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> newVersion = &#123;</div><div class="line">  ...previousVersion,</div><div class="line">  <span class="attr">name</span>: <span class="string">'New Name'</span> <span class="comment">// Override the name property</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>newVersion</code>对象自定义了name属性，其他属性全部复制自<code>previousVersion</code>对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"> even <span class="keyword">if</span> property keys don’t clash, because objects record insertion order:</div><div class="line"></div><div class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</div></pre></td></tr></table></figure></p>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;</div><div class="line">  ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</div><div class="line">  <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果扩展运算符后面是一个空对象，则没有任何效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</div><div class="line"><span class="comment">// &#123; a: 1 &#125;</span></div><div class="line"> even <span class="keyword">if</span> property keys don’t clash, because objects record insertion order:</div></pre></td></tr></table></figure></p>
<p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这两个值会被忽略，不会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> emptyObject = &#123; ...null, ...undefined &#125;; <span class="comment">// 不报错</span></div></pre></td></tr></table></figure></p>
<p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></div><div class="line"><span class="keyword">let</span> aWithXGetter = &#123;</div><div class="line">  ...a,</div><div class="line">  get x() &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not throw yet'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 会抛出错误，因为 x 属性被执行了</span></div><div class="line"><span class="keyword">let</span> runtimeError = &#123;</div><div class="line">  ...a,</div><div class="line">  ...&#123;</div><div class="line">    get x() &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw now'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;属性的简洁表示&quot;&gt;&lt;a href=&quot;#属性的简洁表示&quot; class=&quot;headerlink&quot; title=&quot;属性的简洁表示&quot;&gt;&lt;/a&gt;属性的简洁表示&lt;/h3&gt;&lt;p&gt;ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; baz = &amp;#123;foo&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;baz &lt;span class=&quot;comment&quot;&gt;// &amp;#123;foo: &#39;bar&#39;&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等同于&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; baz = &amp;#123;&lt;span class=&quot;attr&quot;&gt;foo&lt;/span&gt;: foo&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="对象" scheme="https://callmejay.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入对象</title>
    <link href="https://callmejay.github.io/2018/03/07/JavaScript%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/"/>
    <id>https://callmejay.github.io/2018/03/07/JavaScript深入对象/</id>
    <published>2018-03-07T15:03:40.000Z</published>
    <updated>2018-03-12T15:12:20.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="简单做法"><a href="#简单做法" class="headerlink" title="简单做法"></a>简单做法</h4><h5 id="使用Object构造函数创建"><a href="#使用Object构造函数创建" class="headerlink" title="使用Object构造函数创建"></a>使用Object构造函数创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象实例的创建</span></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() </div><div class="line">obj.key = <span class="string">'value'</span>   <span class="comment">//使用构造函数创建一个空对象，并赋值s</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="使用对象字面量表示法创建"><a href="#使用对象字面量表示法创建" class="headerlink" title="使用对象字面量表示法创建"></a>使用对象字面量表示法创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">key1</span>: <span class="string">'value1'</span>,</div><div class="line">    <span class="attr">key2</span>: <span class="string">'value2'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字面量表示法与 Object 构造函数创建法唯一的区别是，在字面量表示法里你可以给对象添加多个 键/值 对，但是在构造形式中你必须逐个添加属性。</p>
<p>现在ES6可以使用更简洁的方式创建对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</div><div class="line"><span class="keyword">let</span> sex = <span class="string">'sexy'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'jay'</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 简洁表示法，等同于 age: age</span></div><div class="line">    age, </div><div class="line"></div><div class="line">    <span class="comment">// 简洁表示法，等同于 sayName： function() &#123;&#125;</span></div><div class="line">    sayName()&#123;&#125;,</div><div class="line"></div><div class="line">    <span class="comment">//属性名表达式，等同于 lover:'rose'</span></div><div class="line">    [<span class="string">'lo'</span>+<span class="string">'ver'</span>]: <span class="string">'rose'</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 属性名表达式，等同于 sexy: 'male'</span></div><div class="line">    [sex]: <span class="string">'male'</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 ‘[object Object]’，这一点要特别小心。</p>
</blockquote>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>即用函数来封装创建对象的细节。多次调用该函数来创建多个相似对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = &#123;&#125;</div><div class="line">    o.name = name</div><div class="line">    o.age = age</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</div><div class="line">    <span class="keyword">return</span> o</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = createPerson(<span class="string">'a'</span>, <span class="number">20</span>)</div><div class="line"><span class="keyword">var</span> b = createPerson(<span class="string">'b'</span>, <span class="number">22</span>)</div></pre></td></tr></table></figure></p>
<p>工厂模式虽然解决多创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<h4 id="模仿‘类’的设计"><a href="#模仿‘类’的设计" class="headerlink" title="模仿‘类’的设计"></a>模仿‘类’的设计</h4><h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><p>构造函数包括像Array,Object这样的原生构造函数，他们在js运行时会自动出现在执行环境中。此外，我们可以创建自定义构造函数，从而定义自定义类型的属性和方法。现在构造函数重写上个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Person(<span class="string">'a'</span>,<span class="number">20</span>);</div><div class="line"></div><div class="line">a <span class="keyword">instanceof</span> Person <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>构造函数就是普通的函数，不存在特殊语法。构造函数与其他函数唯一的区别就在于调用他们的方式不同。任何函数只要通过<code>new</code>操作符来调用，那它就可以作为构造函数。<br>使用<code>new</code>操作符调用函数，或者说发生构造函数调用时，会自动执行下面操作：</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个新对象会被执行[[Prototype]] 链接。</li>
<li>这个新对象会绑定到函数调用时的this。</li>
<li>如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象。</li>
</ol>
<p>由于构造函数调用时会自动执行 [[Prototype]] 链接，也就是把新对象的原型链指向构造函数的 prototype。所以使用<code>instanceof</code>或<code>isPrototypeOf</code>方法可以判断他们的类型。</p>
<p>上面这种构造函数解决了对象类型识别的问题，但是每个方法都要在每个实例上重新创建一遍，在上面的例子中，a 和 b 都有个名为<code>sayName()</code>的方法，这两个方法虽然名字、内容、功能相同，但却分别在 a 和 b 中都重新创建了一次，这是没有必要的。</p>
<p>更好的方法应该是将公用的方法放到他们的原型上，也就是接下来要说的原型模式。</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>所有函数都有一个不可枚举的prototype(原型)属性，这个属性时一个指针，指向一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Foo.prototype <span class="comment">// &#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>上一节【构造函数模式】里面有说，<code>new</code>操作符会新建一个对象，并把该对象的原型链指向构造函数的 <code>prototype</code> 所指向的对象。</p>
<p>这里出现了一个重点词<strong>原型链</strong>，我们先解释下什么叫做原型链。</p>
<blockquote>
<p>原型链也被称为 [[Prototype]]链，是对象的内置属性。原型链是 ECMAScript 中实现继承的主要办法，其基本思想就是让一个引用类型继承另一个引用类型的属性和和方法。</p>
</blockquote>
<p>例如我们新建个对象 a，然后给它指定它的原型链的指向：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;</div><div class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b)</div><div class="line"> </div><div class="line">a.x <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>这个例子中我们通过<code>Object.setPrototypeOf()</code>方法把 a 的原型链指向 b，然后 a 就继承了 b 的属性，当查询 a 中没有的 x 属性时，会指向到 b.x 的值。</p>
<p>这里原理上说是委托比说是继承更符合真实情况。因为真实情况如上段所说是 a 把自身没有的属性查询委托给 b，如果 b 中也没 x 属性的话，系统会继续循着原型链往上查。所有普通的 [[Prototype]] 链最终都会指向内置的 <code>Object.prototype</code>。如果 <code>Object.prototype</code> 也没有的话就会提示 <code>undefined</code>。</p>
<p>这里提示一下，由于所有普通的对象都”源于“（或者说把 [[Prototype]] 链的顶端设置为）这个 <code>Object.prototype</code> 对象，所以它包含 Javascript 中许多通用的功能。</p>
<p>上面说过，new操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 属性所指向的对象（即原型对象）。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'h'</span>,</div><div class="line">    sayName () &#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person()</div><div class="line"> </div><div class="line">a.sayName() <span class="comment">// h</span></div></pre></td></tr></table></figure></p>
<p>这种方法因为重写了Person.prototype,所以默认的Person.prototype.constructor也会丢失，如果要修复constructor,可以使用<code>Object.defineProperty()</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">'constructor'</span>,&#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: Person</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>不过实例一般都是要有属于自己的全部属性的。所以日常开发中设计对象更常见的做法是构造函数模式跟原型模式组合使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>);</div><div class="line">a.sayName(); <span class="comment">// Jack</span></div></pre></td></tr></table></figure></p>
<p>这里很像一些面向“类”的语言的行为，a 和 b 是 Person 类的实例，a 和 b 继承了 Person 类的特性。但实际上 JavaScript 和面向类的语言不同，它并没有类作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。</p>
<h5 id="使用ES6-Class"><a href="#使用ES6-Class" class="headerlink" title="使用ES6 Class"></a>使用ES6 Class</h5><p>上面说的原型是通过构造函数，定义并生成新对象。但这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。</p>
<p>不过需要注意的是， ES6 的 class 语法是并不是向 JavaScript 中引入了一种新的“ 类” 机制。 <strong>class 基本上只是现有 [[Prototype]] 机制的一种语法糖。</strong></p>
<p>也就是说， class 并不会像传统面向类的语言一样在声明时静态复制所有行为。 如果你（ 有意或无意） 修改或者替换了父“ 类” 中的一个方法， 那子“ 类” 和所有实例都会受到影响， 因为它们在定义时并没有进行复制， 只是使用基于 [[Prototype]] 的实时委托。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">typeof</span> Foo <span class="comment">// 'function'</span></div><div class="line">Foo === Foo.prototype.constructor <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    sayName () &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Foo(<span class="string">'a'</span>);</div><div class="line"></div><div class="line">a.sayName(); <span class="comment">// a</span></div></pre></td></tr></table></figure></p>
<p>构造函数的prototype 属性，在ES6的‘类’上继续存在，事实上，类的所有方法都定义上类的prototype 属性上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;&#125;</div><div class="line">    toString () &#123;&#125;</div><div class="line">    toValue () &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line">Foo.prototype = &#123;</div><div class="line">    toString()&#123;&#125;,</div><div class="line">    toValue () &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.assign(Foo.prototype, &#123;</div><div class="line">  toString()&#123;&#125;,</div><div class="line">  toValue()&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>ES6 Class 与 普通构造函数的不同点主要有 4 个：</p>
<p>(1)constructor 方法</p>
<p><code>constructor</code>方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<p><code>constructor</code>方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo    <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">Foo()</div><div class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></div></pre></td></tr></table></figure></p>
<p>(2)类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与普通构造函数的行为不一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/ <span class="class"><span class="keyword">class</span></span></div><div class="line"><span class="title">class</span> <span class="title">Foo</span> &#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;</div><div class="line">    sayName()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.keys(Foo.prototype)  <span class="comment">// []</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Foo.prototype)   <span class="comment">// ["constructor","sayName"]</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name) </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.keys(Foo.prototype)  <span class="comment">// ["sayName"]</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Foo.prototype)   <span class="comment">// ["constructor", "sayName"]</span></div></pre></td></tr></table></figure>
<p>上面代码中，sayName方法是 Foo 类内部定义的方法，它是不可枚举的。而定义在 Foo.prototype 中的话则是可枚举的。</p>
<p>(3) Class不存在变量提升（hoist），这点与ES5完全不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p>(4)子类的继承</p>
<p>Class 之间可以通过 <code>extends</code> 关键字实现继承，这比普通构造函数通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个 Bar 类，该类通过extends关键字，继承了 Foo 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Foo 类。下面，我们在 Bar 内部加上代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (name,age) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sayProfile () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (name ,age, lover) &#123;</div><div class="line">        <span class="keyword">super</span>(name,age);<span class="comment">// 调用父类的 constructor(name,age), 约等于普通构造函数中的 Foo.call(this, name, age)</span></div><div class="line">        <span class="keyword">this</span>.age = <span class="built_in">Number</span>(<span class="keyword">this</span>.age) + <span class="number">5</span>;</div><div class="line">        <span class="keyword">this</span>.lover = lover;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sayIntro() &#123;</div><div class="line">        alert(<span class="keyword">super</span>.sayProfile() + <span class="string">`, my lover is <span class="subst">$&#123;<span class="keyword">this</span>.lover&#125;</span>, again, I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'Jack'</span>, <span class="string">'20'</span>, <span class="string">'Rose'</span>)</div><div class="line"> </div><div class="line">a.sayIntro()    <span class="comment">// "hello, my name is Jack, 25 years old, my lover is Rose, again, I am</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，子类 Bar 的<code>constructor</code>方法和<code>sayIntro</code>方法之中，都出现了<code>super</code>关键字，<code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。在上面的代码中 子类 Bar 的构造函数中<code>super(name, age)</code>相当于<code>Foo.prototype.constructor.call(this, name, age)</code>。作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<p><strong>要注意的是，子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错</strong>。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到 this 对象。在子类的构造函数中，只有调用<code>super</code>之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p>
<p>普通构造函数的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面<code>（Foo.call(this)）</code>。<strong>ES6 Class 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改 this。</strong></p>
<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span> (...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种情况，<strong><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong>上面代码代码中的 <code>super.sayProfile()</code>就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向 <code>Foo.prototype</code>，所以<code>super.sayProfile()</code>就相当于<code>Foo.prototype.sayProfile()</code>。</p>
<p>ES6 规定，通过<code>super</code>调用父类的方法时，<code>super</code>会绑定子类的 this。所以<code>sayProfile</code>输出的<code>this.age</code>是子类 Bar 的 age 25岁。</p>
<p>刚刚说到在静态方法中<code>super</code>指向父类。</p>
<blockquote>
<p>静态方法</p>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> sayHi () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.sayHi(); <span class="comment">// hello</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</div><div class="line">a.sayHi(); <span class="comment">// TypeError: a.sayHi is not a function</span></div></pre></td></tr></table></figure>
<p>上面代码中<code>ayHi()</code>就是 Foo 的静态方法，它只能通过 Foo 调用，不能通过 Foo 的实例调用。</p>
<p>如果<code>super</code>作为对象用在静态方法中，这时<code>super</code>将指向父类，而不是父类的原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> sayHi() &#123;  <span class="comment">// 父类</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">    &#125;</div><div class="line">    sayHi () &#123;  <span class="comment">// 原型</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'oops'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> sayBob () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sayHi() + <span class="string">'Bob'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.sayBob (); <span class="comment">// 'hello Bob'</span></div></pre></td></tr></table></figure></p>
<h4 id="面向委托的设计（对象关联风格）"><a href="#面向委托的设计（对象关联风格）" class="headerlink" title="面向委托的设计（对象关联风格）"></a>面向委托的设计（对象关联风格）</h4><p>有些开发者比较诟病这种模仿“类”的设计模式，因为继承意味着复制，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联（我们把这种关联成为原型链），这样对象就可以通过委托访问另一个对象的属性和函数。委托这个术语可以更加准确地描述 JavaScript 中的对象关联机制。</p>
<p>即便通过 ES6 class 让 js 看起来更像“类”，也只是一种模仿的假象。在传统的面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改，但是 Javascript 最强大的特性就是它的动态性，任何对象的定义都可以修改（除非你把它定义为不可变）。</p>
<p>一些开发者认为 ES6 的 class 想伪装成一种很好的语法问题的解决方案，但实际上却让问题更难解决且让 JavaScript 更难理解。因为它隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托机制。让本来简洁优雅的 [[Prototype]] 机制变的非常别扭。</p>
<p>我们比较下继承与委托设计的区别。</p>
<p>我们先想想类（继承）的设计方法：先定义一个通用的父类 F，在父类 F 中定义所有任务都有的行为，接着定义子类 a 和 b，他们都继承自父类并且会添加一些特殊行为来处理对应的任务。</p>
<p>再用委托的思想来考虑同样的问题：首先先定义一个对象 F，它包含所有任务都可以使用（委托）的具体行为。接着，对于每个任务你都会定义一个对象来储存对应的数据和行为，你会把特定的任务对象都关联到 F 功能对象上面，让他们在需要的时候可以进行委托。基本你可以想象成 a 和 F 之间是兄弟关系，a 完成不了的任务东西都委托给 F完成。</p>
<blockquote>
<p>JavaScript 中原型链实际上是委托的关系而不是继承。委托行为意味着某些对象在找不到属性或方法引用时会把这个请求委托给另一个对象。</p>
</blockquote>
<p>我们先看一个使用类设计风格的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Foo</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Foo.prototype.intro = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    Foo.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</div><div class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="keyword">this</span>.intro())&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>);</div><div class="line">a.speak(); <span class="comment">// my name is a</span></div></pre></td></tr></table></figure></p>
<p>这个例子里子类 Bar 继承了父类 Foo，然后生成了 a 这个实例，a 通过 new 构造函数委托了 <code>Bar.prototype</code>，<code>Bar.prototype</code> 通过<code>Object.create()</code>方法委托了 <code>Foo.prototype()</code>。这种风格很常见，你应该已经熟悉了。</p>
<p>当然我们可以用 class 让这段代码看起来更简洁明了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;</div><div class="line">    intro() &#123; <span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">super</span>(name)</div><div class="line">    &#125;</div><div class="line">    speak() &#123; alert(<span class="keyword">super</span>.intro()) &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>)</div><div class="line"> </div><div class="line">a.speak()</div></pre></td></tr></table></figure></p>
<p>现在再来看看同例的对象关联风格的设计：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Foo = &#123;</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">intro</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Bar = <span class="built_in">Object</span>.create(Foo)</div><div class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.intro())</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(Bar)</div><div class="line">a.init(<span class="string">'a'</span>)</div><div class="line"> </div><div class="line">a.speak()</div></pre></td></tr></table></figure></p>
<p>这段代码中我们同样利用 [[Prototype]] 把 a 委托给 Bar 并把 Bar 委托给 Foo，和上段代码一样，我们仍然实现了三个对象的关联。</p>
<p>但非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。</p>
<h3 id="对象的内容"><a href="#对象的内容" class="headerlink" title="对象的内容"></a>对象的内容</h3><p>对象的内容是由一些储存在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p>
<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a>getter与setter</h4><h5 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h5><p>get 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。该方法会覆盖单个属性默认的 [[Get]] 操作（获得属性值的操作）。</p>
<p>用法：</p>
<blockquote>
<p>{get prop() { … } } // prop 为要绑定到给定函数的属性名</p>
<p>{get <a href="">expression</a> { … } } //从ECMAScript 2015 (ES6)开始，还可以使用一个计算的属性名的表达式绑定到给定的函数。</p>
</blockquote>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObj = &#123;</div><div class="line">    get a () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 也可以通过 defineProperty 创建</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="string">'b'</span>, &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a*<span class="number">2</span>&#125;,</div><div class="line">    <span class="attr">enumable</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">myObj.a <span class="comment">// 2</span></div><div class="line">myObj.b <span class="comment">// 4</span></div><div class="line"></div><div class="line">myObj.a = <span class="number">3</span> </div><div class="line">myObj.a  <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>如上面例子，不管是对象文字语法中的<code>get a() { .. }</code>， 还是<code>defineProperty(...)</code>中的显式定义， 二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。</p>
<p>同时由于我们只定义了 a 的 getter， 所以对 a 的值进行设置时 set 操作会忽略赋值操作，且不会抛出错误。 为了让属性更合理， 我们还应当定义 setter。</p>
<h5 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h5><p>set 语法会覆盖单个属性默认的 [[Put]] 操作（赋值操作）。</p>
<p>通常来说 getter 和 setter 是成对出现的（ 只定义一个的话通常会产生意料之外的行为）。</p>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObj = &#123;</div><div class="line">    get a () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</div><div class="line">    &#125;,</div><div class="line">    set a(val) &#123;</div><div class="line">        <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">myObj.a = <span class="number">2</span>;</div><div class="line">myObj.a <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>注意，在本例中， 实际上我们把赋值（ [[Put]]） 操作中的值 2 存储到了另一个变量_a_中。 名称_a_只是一种惯例， 没有任何特殊的行为，和其他普通属性一样。</p>
<h4 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h4><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p><code>for keys in object</code> 循环可以遍历对象的可枚举属性列表（包括 [[Prototype]] 原型链）。</p>
<p><code>for..in</code>循环是无法直接获取属性值的，你需要手动获取属性值。</p>
<p>需要注意的是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。</p>
<h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><p><code>for..of</code>循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 <code>next()</code> 方法来遍历所有返回值。</p>
<p>我们先看一下迭代器的定义：</p>
<blockquote>
<p><strong>可迭代协议</strong></p>
<p>可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可遍历对象并且有默认的迭代行为, 比如 Array、Map, 另一些类型则不是 (比如 Object) 。</p>
<p>为了变成可遍历对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链上的某个对象）必须有一个名字是 Symbol.iterator 的属性:</p>
</blockquote>
<p>数组有内置的 <code>@@iterator</code>， 因此<code>for..of</code>可以直接应用在数组上:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> myArr)&#123;</div><div class="line">    <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>我们再通过数组的<code>Symbol.iterator</code>属性看看<code>@@iterator</code>是怎么工作的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">it = myArr[<span class="built_in">Symbol</span>.iterator]()</div><div class="line">it.next()   <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">it.next()   <span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line">it.next()   <span class="comment">// &#123;value: 3, done: false&#125;</span></div><div class="line">it.next()   <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>如你所见，调用迭代器的<code>next()</code>方法会返回形式为<code>{value: .., done: ..}</code>的值，<code>value</code>是当前的遍历值，<code>done</code>是一个布尔值，表示是否还有可以遍历的值。</p>
<p>上面示例中需要注意的一点，我们使用符号<code>Symbol.iterator</code>来获取对象的<code>@@iterator</code>内部属性。引用类似 <code>iterator</code> 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但<code>@@iterator</code>本身并不是迭代器对象，而是返回迭代器对象的函数——这点非常精妙并且重要。</p>
<p>可是普通对象没有内置的<code>@@iterator</code>，所以无法完成<code>for..of</code>遍历。制定者之所以这样做，有许多复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。</p>
<p>但我们可以给任何想遍历的对象自定义<code>@@iterator</code>，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="built_in">Symbol</span>.iterator, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">var</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o);</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> &#123;</div><div class="line">                    <span class="attr">value</span>: o[ks[idx++]],</div><div class="line">                    <span class="attr">done</span>: (idx &gt; ks.length)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 手动遍历 myObj</span></div><div class="line"><span class="keyword">var</span> it = myObj[<span class="built_in">Symbol</span>.iterator]()</div><div class="line"></div><div class="line">it.next()   <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">it.next()   <span class="comment">//&#123;value: 2, done: false&#125;</span></div><div class="line">it.next()   <span class="comment">//&#123;value: undefined, done: true&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 用 for..of 遍历 myObj</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> myObj) &#123;</div><div class="line">    <span class="built_in">console</span>.log(v)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<h4 id="对象的代理Proxy"><a href="#对象的代理Proxy" class="headerlink" title="对象的代理Proxy"></a>对象的代理Proxy</h4><p>ES6 中引入的 Proxy 是一个元编程的特性。元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。</p>
<p>Proxy 对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。也就说它可以 “代理” 对象的原生行为，替换为执行自定义行为。</p>
<p>Proxy语法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</div></pre></td></tr></table></figure></p>
<p>其中，<code>new Proxy()</code>表示生成一个Proxy实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>举个栗子，我们知道当我们要获取对象的属性值的时候，对象内部会调用 get 方法去获取这个属性，如果该属性不存在在该对象中，则会继续向 [[Prototype]] 原型链向上寻找，一直找到 Object.prototype。</p>
<p>如果我们按上一节的方法给该属性设置了<code>get()</code>方法，则查询该属性值时会返回<code>get()</code> 方法的返回值。Proxy 可以给所有查询不到的属性设置统一的<code>get()</code>方法。</p>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a, &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">3</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">obj.x <span class="comment">// 2</span></div><div class="line">obj.y <span class="comment">// 3</span></div><div class="line">obj.z <span class="comment">// 3</span></div><div class="line">a.y <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a,&#123;&#125;)</div><div class="line"></div><div class="line">obj.y = <span class="number">3</span></div><div class="line">a.y = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>有一个技巧是把 Proxy 实例作为其他对象的原型对象，这样就可以让其他对象继承（或者说委托？）Proxy 实例的拦截方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span> (&#123;&#125;,&#123;</div><div class="line">    <span class="attr">get</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">233</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(obj);</div><div class="line"></div><div class="line">a.someprop <span class="comment">// 233</span></div></pre></td></tr></table></figure></p>
<p>此外，Proxy 对象还提供了一个revoke方法，可以随时注销所有的代理操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</div><div class="line">    get() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = p.proxy</div><div class="line">a.x <span class="comment">// 1</span></div><div class="line">p.revoke()</div><div class="line">a.x <span class="comment">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></div></pre></td></tr></table></figure></p>
<p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是 Proxy 实例，<code>revoke</code>属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行<code>revoke</code>函数之后，再访问 Proxy 实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<p>包括 <code>get()</code>、<code>set()</code> 在内，Proxy 支持的拦截操作有十多种，包含了大部分对象的方法操作的拦截。具体请查阅 ECMAScript 6 入门 及 MDN 文档</p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><h4 id="原型相关-create-setPrototypeOf-getPrototypeOf"><a href="#原型相关-create-setPrototypeOf-getPrototypeOf" class="headerlink" title="原型相关 create,setPrototypeOf,getPrototypeOf"></a>原型相关 create,setPrototypeOf,getPrototypeOf</h4><h5 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [ propertiesObject ])"></a>Object.create(proto, [ propertiesObject ])</h5><p>该方法使用指定的原型对象和其属性创建了一个新的对象。可理解为该方法会创建一个对象并把这个对象的 [[Prototype]]关联到指定对象。</p>
<p>需要注意的是，<code>Object.create(null)</code>会创建一个拥有空（或者 null）[[Prototype]] 链的对象，这个对象无法进行委托。由于这个对象没有原型链，所以<code>instanceof</code>操作符无法进行判断，因此总是返回 false。这些特殊的空 [[Prototype]] 对象通常被称作“字典”，他们完全不会受到原型链的干扰，因此非常适合用来储存数据。</p>
<h5 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h5><p>该方法是ES6的新方法，用于设置一个指定的对象的原型 ( 例如,内置的 [[Prototype]] 属性）到另一个对象或 null。可以代替 ES5 的<code>Object.create</code>。</p>
<p>例如有两个对象 a 和 b，我们需要把 b 设为 a 的原型，以便 a 可以继承 b 的属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> b = &#123;<span class="attr">y</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</div><div class="line"></div><div class="line">a.x <span class="comment">//1</span></div><div class="line">a.y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// ["x"]</span></div></pre></td></tr></table></figure></p>
<p>上例中把 b 设为 a 的原型，因此当向 a 查询 y 时，由于 a 本身没有 y 属性，所以会循着原型链查询到 b 的 y。</p>
<p>再例如有两个函数（函数也是对象哦！） Bar 和 Foo，我们需要把 Bar.prototype 关联到 Foo.prototype:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建 Foo</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;<span class="keyword">this</span>.name = name&#125;</div><div class="line">Foo.prototype.sayName= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建 Bar</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name</span>)</span>&#123;Foo.call(<span class="keyword">this</span>, name)&#125;</div><div class="line"></div><div class="line"><span class="comment">//关联 prototype</span></div><div class="line"><span class="comment">// ES6 之前需要抛弃默认的 Bar.prototype</span></div><div class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"></div><div class="line"><span class="comment">// ES6 开始可以直接修改现有的 Bar.prototype</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype, Foo.prototype)</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>)</div><div class="line">a.sayName()</div></pre></td></tr></table></figure></p>
<p>如果不考虑<code>Object.create(..)</code>方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它其实比 ES6 及其之后的方法更短切可读性更高。</p>
<h5 id="Object-getPrototypeOf-obj"><a href="#Object-getPrototypeOf-obj" class="headerlink" title="Object.getPrototypeOf(obj)"></a>Object.getPrototypeOf(obj)</h5><p>该方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。如果没有继承属性，则返回 null 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a)</div><div class="line"> </div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(b) === a <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;h4 id=&quot;简单做法&quot;&gt;&lt;a href=&quot;#简单做法&quot; class=&quot;headerlink&quot; title=&quot;简单做法&quot;&gt;&lt;/a&gt;简单做法&lt;/h4&gt;&lt;h5 id=&quot;使用Object构造函数创建&quot;&gt;&lt;a href=&quot;#使用Object构造函数创建&quot; class=&quot;headerlink&quot; title=&quot;使用Object构造函数创建&quot;&gt;&lt;/a&gt;使用Object构造函数创建&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对象实例的创建&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;() &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;obj.key = &lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//使用构造函数创建一个空对象，并赋值s&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="对象" scheme="https://callmejay.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入数组</title>
    <link href="https://callmejay.github.io/2018/02/26/JavaScript%E6%B7%B1%E5%85%A5%E6%95%B0%E7%BB%84/"/>
    <id>https://callmejay.github.io/2018/02/26/JavaScript深入数组/</id>
    <published>2018-02-26T15:13:39.000Z</published>
    <updated>2018-03-07T15:17:14.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。<br><a id="more"></a><br><img src="http://oonulpk6h.bkt.clouddn.com/Array.png" alt="数组"></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><strong>length</strong><br>length属性表示数组的长度，即其中元素的个数。<br>JavaScript数组的length属性时可变的，当length属性被设置的更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大;当length属性被设置的比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。</p>
<p><strong>prptotype</strong><br>返回对象类型原型的引用。prototype属性是object共有的。<br>一般用来给数组实例添加方法。</p>
<p><strong>constructor</strong><br>表示创建对象的函数。<br>说明：constructor属性是所有具有prototype的对象的成员。constructor属性保存了对构造特定对象实例的函数的引用。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组实例的创建</span></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 创建一个length为5的数组 [undefined, undefined, undefined, undefined, undefined]</span></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 创建数组并赋值 [1,2,3]</span></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">5</span>); <span class="comment">// 创建一个length为3的数组，并里面赋值均为5 [5,5,5] </span></div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">7</span>); <span class="comment">// 创建数组并赋值[7]</span></div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// 创建数组并赋值 [1,2,4]</span></div></pre></td></tr></table></figure>
<h5 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断一个对象是不是一个数组</span></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;&#125; <span class="comment">// 方法1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">'[object Array]'</span>) &#123;&#125;<span class="comment">// 方法2</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr)) &#123;&#125; <span class="comment">// 方法3</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(arr.constructor == <span class="built_in">Array</span>)&#123;&#125; <span class="comment">// 方法4</span></div></pre></td></tr></table></figure>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>Array.isArray(obj)</strong><br>检测对象是否Array,是则范湖true,否则为false.<br><strong>Array.from(arrayLike,mapFn,thisArg)</strong><br>该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg是可选参数，为执行 mapFn 函数时 this 的值。</p>
<p>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，<strong>任何有length属性的对象，都可以通过Array.from方法转为数组。</strong></p>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayLike = &#123;</div><div class="line">    <span class="number">0</span>: <span class="string">'a'</span>,</div><div class="line">    <span class="number">1</span>: <span class="string">'b'</span>,</div><div class="line">    <span class="number">2</span>: <span class="string">'c'</span>,</div><div class="line">    <span class="attr">length</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> arrayLike2 = &#123;<span class="attr">length</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">let</span> str = <span class="string">'abcd'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> newArray = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a','b','c']</span></div><div class="line"><span class="keyword">let</span> newArray2 = <span class="built_in">Array</span>.from(arrayLike, (i) =&gt; &#123; i+ <span class="string">'1'</span>&#125;); <span class="comment">// ['a1','b1','c1']</span></div><div class="line"><span class="keyword">let</span> newArray3= <span class="built_in">Array</span>.from(arrayLike2); <span class="comment">// [undefined,undefined,undefined]</span></div><div class="line"><span class="keyword">let</span> newArray4= <span class="built_in">Array</span>.from(str); <span class="comment">// ['a','b','c','d']</span></div></pre></td></tr></table></figure></p>
<p><strong>Array.of(item…)</strong><br>该方法用于创建数组实例。该方法用于替代 Array() 或 new Array()。Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// [7] </span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">7</span>);          <span class="comment">// [ , , , , , , ]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<h4 id="数组实例方法"><a href="#数组实例方法" class="headerlink" title="数组实例方法"></a>数组实例方法</h4><h5 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h5><p><strong>arr.join(separator)</strong><br>把数组构构造成字符串，它先把数组中的每个元素转换成字符串，然后再用 separator 分隔符把它们链接在一起，separator 分隔符默认是逗号 “,”，要想做到无间隔链接，可以使用空字符串作为 separator：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">arr.join(<span class="string">'|'</span>) <span class="comment">//"1|2|3|4|5"</span></div><div class="line">arr.join(<span class="string">""</span>) <span class="comment">//12345</span></div><div class="line"><span class="comment">//另所有对象有具有的 toLocaleString、toString、valueOf，可以看作是join的特殊用法，不常用</span></div></pre></td></tr></table></figure></p>
<h5 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h5><p><strong>arr.push(item…)</strong><br>将一个或多个新元素添加到数组结尾，并返回数组新长度。<br><strong>arr.pop()</strong><br>移除最后一个元素并返回该元素值。</p>
<h5 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h5><p><strong>arr.unshift(item…)</strong><br>将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度。<br><strong>arr.shift()</strong><br>移除第一个元素并返回该元素值，数组中元素自动前移.如果这个数组是空的，它会返回 undefined。shift 通常比 pop 慢的多。</p>
<h5 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h5><p><strong>arr.reverse()</strong><br>反转数组的顺序。<br><strong>arr.sort(compareFn)</strong><br>给数组排序，默认升序。</p>
<p>注意： sort 默认会将数组内容视为字符串来排序，所以对数字排序时默认的排序规则会错的离谱。一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数，如果两个参数相等则返回0，如果第一个参数应该排在前面则返回一个负数，如果第二个参数应该排在前面则返回一个正数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数组排序</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> a - b</div><div class="line">&#125;) <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure></p>
<h5 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h5><p><strong>arr.concat(item…)</strong><br>该方法产生一份 arr 的浅复制，并将多个数组（也可以是字符串，或者是数组和字符串的混合）附加在其后连接为一个数组，返回连接好的新的数组。</p>
<p><strong>arr.slice(start, end)</strong><br>该方法对数组中的一段做浅复制，首先复制数组 arr[start] 至 arr[end] 的部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素（或者理解成 end 的默认值为 arr.length）。字符串也有个同名方法 string.slice。</p>
<p><strong>arr.splice(start, deleteCount, item…)</strong><br>该方法从 arr 中移除一个或多个元素，并将新的 item 插入至移除元素的开始位置， 参数 start 是移除元素的开始位置，deleteCount 是要移除的元素的个数，item 是要被插入的元素。它返回一个包含被移除元素的数组。</p>
<p><strong>arr.copyWithin(target, start, end)</strong><br>该方法复制数组的一部分到同一数组中的另一个位置（会覆盖原成员），并返回修改后的数组。使用这个方法，会修改当前数组。参数 target 为开始替换数据的位置，若 target 大于等于 arr.length，将会不发生拷贝。start 是可选参数，为开始读取数据的位置，默认为0。end 是可选参数，为停止读取数据的位置，默认为 arr.length。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p><strong>arr.fill(value, start, end)</strong><br>该方法使用给定值填充一个数组，参数 value 是用来填充数组的值。start 是可选参数，为填充开始位置，默认为 0。end 是可选参数，为填充的结束位置，默认为 arr.length。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>)            <span class="comment">// [4, 4, 4]</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>, <span class="number">1</span> , <span class="number">2</span>)            <span class="comment">// [1, 4, 3]</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。</div><div class="line"></div><div class="line">##### 位置方法</div><div class="line">**arr.indexOf(searchElement,start)**</div><div class="line">该方法返回要查找的项在数组中的位置，如果没找到返回 -1。接受两个参数，searchElement 是要查找的项，start 是查找起始位置的索引，默认是0。</div><div class="line"></div><div class="line">**arr.lastIndexOf(searchElement, start)**</div><div class="line">从 start 位置开始向前查找，start 默认值为 arr.length – 1。</div><div class="line"></div><div class="line">注意该方法在比较查找项与数组中每一项时，会使用全等操作符，也就是要求查找的项必须严格相等。</div><div class="line"></div><div class="line">**arr.includes(searchElement, fromIndex)**</div><div class="line">该方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。参数 searchElement 为需要查找的元素值。参数 fromIndex 是可选参数，从该索引处开始查找 searchElement，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索，默认为 0。 如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索。</div><div class="line">该方法属于ES7，但Babel转码器已经支持。</div><div class="line">`<span class="string">``</span>js</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</div><div class="line"><span class="comment">// -1</span></div><div class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log([].includes.call(<span class="built_in">arguments</span>, <span class="number">2</span>)) <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log([].includes.call(<span class="built_in">arguments</span>, <span class="number">4</span>)) <span class="comment">// false</span></div><div class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p><strong>arr.every(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。callback 被调用时传入三个参数：元素值，元素的索引，原数组。thisArg 为可选参数，指定执行 callback 时使用的 this 值。</p>
<p><strong>arr.some(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，如果该函数对任意一项返回true,则返回true。</p>
<p><strong>arr.filter(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p>
<p><strong>arr.forEach(callback)</strong><br>对数组中的每一项运行给定函数，这个函数没有返回值。本质上和使用for一样。</p>
<p><strong>arr.map(callback)</strong><br>对数组中的每一项运行给定的函数，返回每次函数调用后结果组成的数组。</p>
<p><strong>arr.find(callback,thisArg)</strong><br>该方法对数组所有成员依次执行callback函数，直到找出第一个返回值为true的成员并返回。如果没有，则返回undefined.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-5</span>,<span class="number">19</span>].find(<span class="function">(<span class="params">v,i,arr</span>) =&gt;</span> v &lt; <span class="number">0</span>) <span class="comment">// -5</span></div></pre></td></tr></table></figure></p>
<p><strong>arr.findIndex(callback, thisArg)</strong><br>该方法与 arr.find() 类似，对数组中的成员依次执行 callback 函数，直至找到第一个返回值为 true 的成员，然后返回该成员的索引。如果没有符合条件的成员，则返回 -1。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function">(<span class="params">v, i , arr</span>)=&gt;</span>  v &gt; <span class="number">9</span>) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p><strong>arr.entries()</strong><br><strong>arr.keys()</strong><br><strong>arr.values()</strong><br>这三个方法都返回一个新的Array iterator对象，可以用<code>for...of</code>循环进行遍历，区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123; <span class="built_in">console</span>.log(index); &#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123; <span class="built_in">console</span>.log(elem) ;&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123; <span class="built_in">console</span>.log(index, elem);&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>;</div><div class="line"><span class="keyword">var</span> iterator = arr.entries(); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(iterator); <span class="comment">// Array Iterator &#123;&#125;</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);  <span class="comment">// [0, "a"]</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next().value);  <span class="comment">// [1, "b"]</span></div></pre></td></tr></table></figure></p>
<h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><p><strong>arr.reduce(callback,initialValue)</strong><br><strong>arr.reduceRight(callback,initialValue)</strong><br>这个两个方法都会迭代数组所有的项，然后返回一个最终值。reduce()方法从数组的第一项开始，逐个遍历到最后，而reduceRight()则从数组的最后一项开始，向前遍历到第一项。它们接受两个参数，callback 每一项上调用的函数，callback 被调用时传入四个参数：上一次调用回调返回的值、正在处理的元素、正在处理的元素的索引值（如果提供了 initialValue ，从0开始；否则从1开始）、原数组。initialValue 是可选项，作为归并基础的初始值，其值用于第一次调用 callback 的第一个参数。</p>
<h3 id="数组常见问题练习"><a href="#数组常见问题练习" class="headerlink" title="数组常见问题练习"></a>数组常见问题练习</h3><h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><h5 id="多个一维数组合并"><a href="#多个一维数组合并" class="headerlink" title="多个一维数组合并"></a>多个一维数组合并</h5><p>如有两个一维数组，要将他们合并成一个数组:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line"> </div><div class="line"><span class="comment">// =&gt; [1,2,3,4]</span></div></pre></td></tr></table></figure></p>
<p>Array.prototype.concat()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = arr1.concat(arr2) <span class="comment">//[1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<p>for循环和Array.prototype.push()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flation</span>(<span class="params">arr1, arr2</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</div><div class="line">        arr1.push(arr2[i])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>reduce()或reduceRight()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span> (<span class="params">arr1,arr2</span>)</span>&#123;</div><div class="line">    arr2.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,curr</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> prev.push(curr);</div><div class="line">    &#125;,arr1)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="多维（复合）数组合并成一维数组"><a href="#多维（复合）数组合并成一维数组" class="headerlink" title="多维（复合）数组合并成一维数组"></a>多维（复合）数组合并成一维数组</h5><p>例如有这么一组多维数组，要把它拍平成1维数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>];</div><div class="line"> </div><div class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></div></pre></td></tr></table></figure></p>
<p>Array.prototype.push()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">unction flatten(arr, result) &#123;</div><div class="line">    <span class="keyword">if</span> (!result) &#123;</div><div class="line">        result = []</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(arr[i].constructor == <span class="built_in">Array</span>) &#123;</div><div class="line">            flatten(arr[i], r)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            result.push(arr[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</div><div class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></div></pre></td></tr></table></figure></p>
<p>Array.prototype.concat()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//省略对二维以上数组的判断</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = []</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        result = result.concat(arr[i])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9] </span></div><div class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="number">10</span>,<span class="number">11</span>]);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></div></pre></td></tr></table></figure></p>
<p>可以通过Function.prototype.apply()方法，让其变得更简单:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//省略对二维以上数组的判断</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 ES6 中，还可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//省略对二维以上数组的判断</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [].concat(...arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果要处理三维或更多维数组，则需要加一些判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    arr = [].concat.apply([], arr)</div><div class="line">    <span class="keyword">return</span> arr.some(<span class="built_in">Array</span>.isArray) ? flatten(arr) : arr</div><div class="line">&#125;</div><div class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</div><div class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></div></pre></td></tr></table></figure></p>
<p>使用join()和split()<br>利用数组实例的join()方法和字符串实例的split()方法，也可以将多维数组拍平：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.join(<span class="string">','</span>).split(<span class="string">','</span>)</div><div class="line">&#125;</div><div class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</div><div class="line"><span class="comment">//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"]</span></div></pre></td></tr></table></figure></p>
<p>这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。</p>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><h5 id="双重循环去重"><a href="#双重循环去重" class="headerlink" title="双重循环去重"></a>双重循环去重</h5><p>思路：</p>
<ul>
<li>构建一个空数组来存放去重后的数组</li>
<li>对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比</li>
<li>如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = [];</div><div class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</div><div class="line">    result[<span class="number">0</span>] = arr[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</div><div class="line">        <span class="keyword">var</span> repeat = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j= <span class="number">0</span>;j&lt;result.length;j++) &#123;</div><div class="line">            <span class="keyword">if</span>(arr[i] == result[j]) &#123;</div><div class="line">                repeat = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!repeat) &#123;</div><div class="line">            result.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</div><div class="line"><span class="comment">//[1, 2, 3, 4, "a", "b"]</span></div></pre></td></tr></table></figure>
<p>这种方法也可以采用forEach()方法和indexOf()方法模拟实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> result = [];</div><div class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</div><div class="line">    result[<span class="number">0</span>] = arr[<span class="number">0</span>];</div><div class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(!result.includes(item)) result.push(item);</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="排序遍历去重"><a href="#排序遍历去重" class="headerlink" title="排序遍历去重"></a>排序遍历去重</h5><p>思路：</p>
<ul>
<li>构建一个空数组来存放去重后的数组</li>
<li>用<code>sort()</code>方法对原数组做一个排序，排完序后对数组做遍历，检测数组中第i个元素与结果数组中的最后一个元素是否相同，如果不同，则放到结果数组中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    arr.sort();</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    arr.forEach( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(item !== result[result.length <span class="number">-1</span>]) &#123;</div><div class="line">            result.push(item);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</div></pre></td></tr></table></figure>
<p>这种方法有两个特色：</p>
<ul>
<li>去重后的数组会做排序，主要是因为原数在去重前做了排序</li>
<li>去重后的数组，与数字相同的数字字符无法区分，比如‘1’和1</li>
</ul>
<h5 id="对象键值对法"><a href="#对象键值对法" class="headerlink" title="对象键值对法"></a>对象键值对法</h5><p>思路：</p>
<ul>
<li>创建一个js对象及新数组</li>
<li>遍历原数组，每次取出一个元素与js对象的键做对比</li>
<li>如果不包含，将存入对象的元素的值推入到结果数组中，并将object对象中该属性名的值设为1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = []</div><div class="line">    <span class="keyword">var</span> object = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!object[<span class="keyword">typeof</span>(arr[i]) + arr[i]]) &#123;  <span class="comment">//键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1`</span></div><div class="line">            result.push(arr[i])</div><div class="line">            object[<span class="keyword">typeof</span>(arr[i]) + arr[i]] = <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div><div class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</div><div class="line"><span class="comment">//[1, 2, 3, 4, "a", "b"]</span></div></pre></td></tr></table></figure>
<p>这种方法比较耗内存，但运行下来耗时最少，是较为优秀的方案。</p>
<h5 id="使用ES6的Set和Map方法"><a href="#使用ES6的Set和Map方法" class="headerlink" title="使用ES6的Set和Map方法"></a>使用ES6的Set和Map方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 借助Map数据结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !seen.has(item) &amp;&amp; seen.set(item,<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//借助 Set 数据结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="comment">//或 return [...new Set(arr)]</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</div><div class="line"><span class="comment">//[1, 2, 3, 4, "1", "a", "b"]</span></div></pre></td></tr></table></figure>
<h4 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h4><h5 id="递归的方法"><a href="#递归的方法" class="headerlink" title="递归的方法"></a>递归的方法</h5><p>思路:<br>不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr,newArr = []</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果原数组只有一个值</span></div><div class="line">    <span class="keyword">if</span>(arr.length == <span class="number">1</span>) &#123;</div><div class="line">        newArr.push(arr[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span> newArr; <span class="comment">// 递归结束</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> random = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*arr.length<span class="number">-1</span>);</div><div class="line">    newArr.push(arr[random]);</div><div class="line">    arr.splice(random,<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> randomSort(arr,newArr);</div><div class="line">&#125;</div><div class="line">randomSort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">//[2, 3, 1, 5, 6, 7, 4]</span></div><div class="line">randomSort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">//[3, 4, 2, 5, 1, 6, 7]</span></div></pre></td></tr></table></figure></p>
<h5 id="随机交换数组内的元素-原理from-underscore-js）"><a href="#随机交换数组内的元素-原理from-underscore-js）" class="headerlink" title="随机交换数组内的元素 (原理from underscore.js）"></a>随机交换数组内的元素 (原理from underscore.js）</h5><p>思路：<br>遍历数组，每次从i位置后元素随机挑一个放到i位置，将原i位置元素放至被挑元素位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</div><div class="line">        arr = <span class="keyword">this</span>.slice(<span class="number">0</span>),</div><div class="line">        temp, index;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        index = i + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - i))</div><div class="line">        [arr[i],arr[index]] = [arr[index],arr[i]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>) </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="随机从原数组抽取一个元素-加入到新数组"><a href="#随机从原数组抽取一个元素-加入到新数组" class="headerlink" title="随机从原数组抽取一个元素,加入到新数组"></a>随机从原数组抽取一个元素,加入到新数组</h5><p>思路：<br>遍历数组，每次从数组中随机挑一个元素（随机数最大值为原数组剩余长度），将该元素拿出来放入新数组。<br>```js<br>Array.prototype.shuffle = function() {<br>    var len = this.length,<br>        arr = this.slice(0),<br>        result = [],<br>        index;<br>    for (var i = 0; i &lt; len; i++) {<br>        index = Math.floor(Math.random() * (len - i))<br>        result.push(arr.splice(index, 1)[0])<br>    }<br>    return result;1<br>}<br>[1, 2, 3, 4, 5, 6, 7].shuffle()<br>//[5, 3, 2, 1, 7, 4, 6]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="Array" scheme="https://callmejay.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入之继承的多种方式</title>
    <link href="https://callmejay.github.io/2018/02/26/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://callmejay.github.io/2018/02/26/JavaScript深入之继承的多种方式/</id>
    <published>2018-02-26T12:55:14.000Z</published>
    <updated>2018-02-26T15:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'Jay'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line"></div><div class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// Jay</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>存在的问题：<br>1，引用类型的属性被所有的实例共享，eg:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.names = [<span class="string">"Jhon"</span>,<span class="string">"Michel"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line"></div><div class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</div><div class="line"></div><div class="line">child1.names.push(<span class="string">'Lili'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></div></pre></td></tr></table></figure></p>
<p>2，在创建Child的实例时，不能向Parent传参</p>
<h3 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.names = [<span class="string">"Jhon"</span>,<span class="string">"Michel"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</div><div class="line"></div><div class="line">child1.names.push(<span class="string">'Lili'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["Jhon","Michel"]</span></div></pre></td></tr></table></figure>
<p>优点：<br>1，避免了引用类型的属性被所有实例共享。<br>2，可以在Child中间向Parent传参. eg:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kaer'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kaer</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'james'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// james</span></div></pre></td></tr></table></figure></p>
<p>缺点：<br>方法都在构造函数里定义，每次创建实例都会创建一遍方法。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>原型链继承和经典继承的组合。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'cyan'</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name,age</span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line"></div><div class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'xiaoming'</span>,<span class="number">20</span>);</div><div class="line"></div><div class="line">child1.colors.push(<span class="string">'black'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child1.name,child1.age,child1.colors); <span class="comment">// xiaoming 20 ["red", "cyan", "black"]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'david'</span>,<span class="number">23</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child2.name,child2.age,child2.colors); <span class="comment">// david 23 ["red", "cyan"]</span></div></pre></td></tr></table></figure></p>
<p>优点：融合原型链继承和构造函数的优点，是JavaScript中最常用的继承模式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span> (<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是ES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：<br>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'kevin'</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createObj(person);</div><div class="line"><span class="keyword">var</span> person2 = createObj(person);</div><div class="line"></div><div class="line">person1.name = <span class="string">'person1'</span>;</div><div class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></div><div class="line"></div><div class="line">person1.firends.push(<span class="string">'taylor'</span>);</div><div class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></div></pre></td></tr></table></figure></p>
<p>注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的name值，而是因为person1.name = ‘person1’，给person1添加了name值，并非修改了原型上的name值.</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object.create(o);</div><div class="line">    clone.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>缺点: 跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承最大的缺点就是虎调用两次父构造函数。<br>一次是设置子类型实例的原型的时候：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div></pre></td></tr></table></figure></p>
<p>一次是在创建子类型实例的时候：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'david'</span>,<span class="number">23</span>);</div></pre></td></tr></table></figure></p>
<p>回想下new的模拟实现，其实在这句中，我们会执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Parent.call(<span class="keyword">this</span>,name);</div></pre></td></tr></table></figure></p>
<p>在这里，我们又会调用了一次Parent构造函数。<br>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[‘red’, ‘blue’, ‘green’]。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>
<p>看看如何实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'cyan'</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name,age</span>) </span>&#123;</div><div class="line">    Parent.call(<span class="keyword">this</span>,name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 关键的三步</span></div><div class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">F.prototype = Parent.prototype;</div><div class="line">Child.prototype  = <span class="keyword">new</span> F();</div><div class="line"></div><div class="line"><span class="keyword">var</span> Child1 = <span class="keyword">new</span> Child(<span class="string">'david'</span>,<span class="number">23</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(child1);</div></pre></td></tr></table></figure></p>
<p>最后封装一下这个函数方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    functin F () &#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span> (<span class="params">child,parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</div><div class="line">    prototype.constructor = child;</div><div class="line">    child.prototype = prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当我们使用的时候</span></div><div class="line">prototype(Child,Parent);</div></pre></td></tr></table></figure></p>
<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<blockquote>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="external">原文地址</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = &lt;span class=&quot;string&quot;&gt;&#39;Jay&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Parent.prototype.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Child.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Parent();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; child1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(child1.getName()); &lt;span class=&quot;comment&quot;&gt;// Jay&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="继承" scheme="https://callmejay.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础3</title>
    <link href="https://callmejay.github.io/2018/02/21/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%803/"/>
    <id>https://callmejay.github.io/2018/02/21/快速掌握JavaScript面试基础3/</id>
    <published>2018-02-21T08:49:21.000Z</published>
    <updated>2018-02-22T09:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>如果使用new关键字来调用函数式很特别的形式。我们把那些用new调用的函数叫做构造函数(constructor function)。</p>
<p>使用了new的函数到底做了什么事情呢？</p>
<ul>
<li>创建一个新的对象</li>
<li>将对象的prototype设置为构造函数的prototype</li>
<li>执行构造函数，this执行新构造的对象</li>
<li>返回该对象。如果构造函数返回对象，那么返回该构造对象。<a id="more"></a>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为了更好地理解底层，我们来定义new关键字</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">constructor, ...arguments</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;</div><div class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">constructor</span>.prototype);</div><div class="line">  return <span class="keyword">constructor</span>.apply(obj, arguments) || obj</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用new和不使用的区别在哪里呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.wings = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 普通的函数调用 */</span></div><div class="line"><span class="keyword">let</span> fakeBird = Bird();</div><div class="line"><span class="built_in">console</span>.log(fakeBird);    <span class="comment">// undefined</span></div><div class="line"><span class="comment">/* 使用new调用 */</span></div><div class="line"><span class="keyword">let</span> realBird= <span class="keyword">new</span> Bird();</div><div class="line"><span class="built_in">console</span>.log(realBird)     <span class="comment">// &#123; wings: 2 &#125;</span></div></pre></td></tr></table></figure></p>
<p>为了便于对比理解，译者额外增加了测试了一种情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MBird</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.wings =<span class="number">2</span>; </div><div class="line">  <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> realMBrid = <span class="keyword">new</span> MBird();</div><div class="line"><span class="built_in">console</span>.log(realMBird) <span class="comment">// &#123; wings: 2 &#125;</span></div></pre></td></tr></table></figure></p>
<p>你会发现，这一句return “hello”并没有生效！</p>
<h3 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h3><p>原型(Prototype)是JavaScript中最容易搞混的概念，其中一个原因是prototype可以用在两个不同的情形下。</p>
<ul>
<li><p>原型关系<br>每一个对象都有一个prototype对象，里面包含了所有它的原型的属性。<br>.__proto__是一个不正规的机制(ES6中提供)，用来获取一个对象的prototype。你可以理解为它指向对象的parent。<br>所有普通的对象都继承.constructor属性，它指向该对象的构造函数。当一个对象通过构造函数实现的时候，__proto__属性指向构造函数的构造函数的.prototype。Object.getPrototypeOf()是ES5的标准函数，用来获取一个对象的原型。</p>
</li>
<li><p>原型属性<br>每一个函数都有一个.prototype属性，它包含了所有可以被继承的属性。该对象默认包含了指向原构造函数的.constructor属性。每一个使用构造函数创建的对象都有一个构造函数属性。</p>
</li>
</ul>
<p>接下来通过例子来帮助理解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">breed, name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.breed = breed,</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line">Dog.prototype.describe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is a <span class="subst">$&#123;<span class="keyword">this</span>.breed&#125;</span>`</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> rusty = <span class="keyword">new</span> Dog(<span class="string">'Beagle'</span>, <span class="string">'Rusty'</span>);</div><div class="line"></div><div class="line"><span class="comment">/* .prototype 属性包含了构造函数以及构造函数中在prototype上定义的属性。*/</span></div><div class="line"><span class="built_in">console</span>.log(Dog.prototype)  <span class="comment">// &#123; describe: ƒ , constructor: ƒ &#125;</span></div><div class="line"></div><div class="line"><span class="comment">/* 使用Dog构造函数构造的对象 */</span></div><div class="line"><span class="built_in">console</span>.log(rusty)   <span class="comment">//  &#123; breed: "Beagle", name: "Rusty" &#125;</span></div><div class="line"></div><div class="line"><span class="comment">/* 从构造函数的原型中继承下来的属性或函数 */</span></div><div class="line"><span class="built_in">console</span>.log(rusty.describe())   <span class="comment">// "Rusty is a Beagle"</span></div><div class="line"></div><div class="line"><span class="comment">/* .__proto__ 属性指向构造函数的.prototype属性 */</span></div><div class="line"><span class="built_in">console</span>.log(rusty.__proto__)    <span class="comment">// &#123; describe: ƒ , constructor: ƒ &#125;</span></div><div class="line"></div><div class="line"><span class="comment">/* .constructor 属性指向构造函数 */</span></div><div class="line"><span class="built_in">console</span>.log(rusty.constructor)  <span class="comment">// ƒ Dog(breed, name) &#123; ... &#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是指对象之间通过prototype链接起来，形成一个有向的链条。当访问一个对象的某个属性的时候，JavaScript引擎会首先查看该对象是否包含该属性。如果没有，就去查找对象的prototype中是否包含。以此类推，直到找到该属性或则找到最后一个对象。最后一个对象的prototype默认为null。</p>
<h3 id="拥有vs继承"><a href="#拥有vs继承" class="headerlink" title="拥有vs继承"></a>拥有vs继承</h3><p>一个对象有两种属性，分别是它自身定义的和继承的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">Car.prototype.wheels = <span class="number">4</span>;</div><div class="line">Car.prototype.airbags = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> Car();</div><div class="line">myCar.color = <span class="string">'black'</span>;</div><div class="line"></div><div class="line"><span class="comment">/*  原型链中的属性也可以通过in来查看:  */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'airbags'</span> <span class="keyword">in</span> myCar)  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(myCar.wheels)        <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(myCar.year)          <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">/*  通过hasOwnProperty来查看是否拥有该属性:  */</span></div><div class="line"><span class="built_in">console</span>.log(myCar.hasOwnProperty(<span class="string">'airbags'</span>))  <span class="comment">// false — Inherited</span></div><div class="line"><span class="built_in">console</span>.log(myCar.hasOwnProperty(<span class="string">'color'</span>))    <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>Object.create(obj) 创建一个新的对象，prototype指向obj。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dog = &#123; <span class="attr">legs</span>: <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">var</span> myDog = <span class="built_in">Object</span>.create(dog);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(myDog.hasOwnProperty(<span class="string">'legs'</span>))  <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(myDog.legs)                    <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(myDog.__proto__ === dog)       <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="继承是引用传值"><a href="#继承是引用传值" class="headerlink" title="继承是引用传值"></a>继承是引用传值</h3><p>继承属性都是通过引用的形式。看例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objProt = &#123; <span class="attr">text</span>: <span class="string">'original'</span> &#125;;</div><div class="line"><span class="keyword">var</span> objAttachedToProt = <span class="built_in">Object</span>.create(objProt);</div><div class="line"><span class="built_in">console</span>.log(objAttachedToProt.text)   <span class="comment">// original</span></div><div class="line"></div><div class="line"><span class="comment">// 我们更改objProt的text属性，objAttachedToProt的text属性同样更改了</span></div><div class="line">objProt.text = <span class="string">'prototype property changed'</span>;</div><div class="line"><span class="built_in">console</span>.log(objAttachedToProt.text)   <span class="comment">// prototype property changed</span></div><div class="line"></div><div class="line"><span class="comment">// 但是如果我们讲一个新的对象赋值给objProt，那么objAttachedToProt的text属性不受影响</span></div><div class="line">objProt = &#123; <span class="attr">text</span>: <span class="string">'replacing property'</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(objAttachedToProt.text)   <span class="comment">// prototype property changed</span></div></pre></td></tr></table></figure></p>
<h3 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a>异步JavaScript</h3><p>JavaScript是一个单线程程序语言，也就是说JavaScript引擎一次只能执行某一段代码。它导致的问题就是：如果有一段代码需要耗费很长的时间执行，其它的操作就被卡住了。JavaScript使用Call Stack来记录函数的调用。一个Call Stack可以看成是一摞书。最后一本书放在最上面，也最先被移走。最先放的书在最底层，最后被移走。</p>
<p>为了避免复杂代码占用CPU太长时间，一个解法就是定义异步回调函数。我们自己来定义一个异步函数看看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetingAsync</span>(<span class="params">name, callback</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> greeting = <span class="string">"hello, "</span> + name ;</div><div class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> callback(greeting),<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">greetingAsync(<span class="string">"fundebug"</span>, <span class="built_in">console</span>.log);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"start greeting"</span>);</div></pre></td></tr></table></figure></p>
<p>我们在greetingAsync中构造了greeting语句，然后通过setTimeout定义了异步，callback函数，是为了让用户自己去定义greeting的具体方式。为方便起见，我们时候直接使用console.log。</p>
<p>上面代码执行首先会打印start greeting，然后才是hello, fundebug。也就是说，greetingAsync的回调函数后执行。在网站开发中，和服务器交互的时候需要不断地发送各种请求，而一个页面可能有几十个请求。如果我们一个一个按照顺序来请求并等待结果，串行的执行会使得网页加载很慢。通过异步的方式，我们可以先发请求，然后在回调中处理请求结果，高效低并发处理。</p>
<p>下面通过一个例子来描述整个执行过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> first = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'First message'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> second = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Second message'</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> third = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Third message'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">first();</div><div class="line">setTimeout(second, <span class="number">0</span>);</div><div class="line">third();</div><div class="line"></div><div class="line"><span class="comment">// 输出:</span></div><div class="line">  <span class="comment">// First message</span></div><div class="line">  <span class="comment">// Third message</span></div><div class="line">  <span class="comment">// Second message</span></div></pre></td></tr></table></figure></p>
<ol>
<li>初始状态下，浏览器控制台没有输出，并且事件管理器(Event Manager)是空的；</li>
<li>first()被添加到调用栈</li>
<li>将console.log(“First message”)加到调用栈</li>
<li>console.log(“First message”)执行并输出“First message”到控制台</li>
<li>console.log(“First message”)从调用栈中移除</li>
<li>first()从调用栈中移除</li>
<li>setTimeout(second, 0)加到调用栈</li>
<li>setTimeout(second, 0)执行，0ms之后，second()被加到回调队列</li>
<li>setTimeout(second, 0)从调用栈中移除</li>
<li>third()加到调用栈</li>
<li>console.log(“Third message”)加到调用栈</li>
<li>console.log(“Third message”)执行并输出“Third message”到控制台</li>
<li>console.log(“Third message”)从调用栈中移除</li>
<li>third()从调用栈中移除</li>
<li>Event Loop 将second()从回调队列移到调用栈</li>
<li>console.log(“Second message”)加到调用栈</li>
<li>console.log(“Second message”)Second message”到控制台</li>
<li>console.log(“Second message”)从调用栈中移除</li>
<li>Second()从调用栈中移除</li>
</ol>
<p>特别注意的是：second()函数在0ms之后并没有立即执行，你传入到setTimeout()函数的时间和second()延迟执行的时间并不一定直接相关。事件管理器等到setTimeout()设置的时间到期才会将其加入回调队列，而回调队列中它执行的时间和它在队列中的位置以及它前面的函数的执行时间有关。</p>
<p><a href="https://blog.fundebug.com/2018/01/29/the-definitive-javascript-handbook-for-a-developer-interview-3/" target="_blank" rel="external">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;new关键字&quot;&gt;&lt;a href=&quot;#new关键字&quot; class=&quot;headerlink&quot; title=&quot;new关键字&quot;&gt;&lt;/a&gt;new关键字&lt;/h3&gt;&lt;p&gt;如果使用new关键字来调用函数式很特别的形式。我们把那些用new调用的函数叫做构造函数(constructor function)。&lt;/p&gt;
&lt;p&gt;使用了new的函数到底做了什么事情呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的对象&lt;/li&gt;
&lt;li&gt;将对象的prototype设置为构造函数的prototype&lt;/li&gt;
&lt;li&gt;执行构造函数，this执行新构造的对象&lt;/li&gt;
&lt;li&gt;返回该对象。如果构造函数返回对象，那么返回该构造对象。
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础2</title>
    <link href="https://callmejay.github.io/2018/02/21/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802/"/>
    <id>https://callmejay.github.io/2018/02/21/快速掌握JavaScript面试基础2/</id>
    <published>2018-02-21T04:47:09.000Z</published>
    <updated>2018-02-22T09:18:00.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包由一个函数以及该函数定义式所在的环境组成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> message = <span class="string">`Hi <span class="subst">$&#123;name&#125;</span>`</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(message);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> greeting();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sayHiToJon = sayHi(<span class="string">'Jon'</span>);</div><div class="line"><span class="built_in">console</span>.log(sayHiToJon)     <span class="comment">// ƒ() &#123; console.log(message) &#125;</span></div><div class="line"><span class="built_in">console</span>.log(sayHiToJon())   <span class="comment">// 'Hi Jon!'</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>请理解<code>var sayHiToJon=sayHi(&#39;Jon&#39;)</code>;这段代码的执行过程，sayHi函数执行，首先将message的值计算出来，然后定义了greeting函数，函数中引用了message变量，最后，返回greeting函数。<br>如果按照C/Java语言的思路，sayHiToJon就等价于greeting函数，那么就会报错：message为定义。但是在JavaScript中不一样，这里的sayHiToJon函数等于greeting函数以及一个环境，该环境中包含了message。因此，当我们调用sayHiToJon函数，可以成功将message打印出来。因此，这里的闭包就是greeting函数和一个包含message变量的环境。</p>
<p>闭包的一个优势在于<strong>数据隔离</strong>，下面用一个例子说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpringfieldSchool</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> staff = [<span class="string">'Seymour Skinner'</span>, <span class="string">'Edna Krabappel'</span>];</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">getStaff</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(staff) &#125;,</div><div class="line">    <span class="attr">addStaff</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; staff.push(name) &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> elementary = SpringfieldSchool()</div><div class="line"><span class="built_in">console</span>.log(elementary)        <span class="comment">// &#123; getStaff: ƒ, addStaff: ƒ &#125;</span></div><div class="line"><span class="built_in">console</span>.log(staff)             <span class="comment">// ReferenceError: staff is not defined</span></div><div class="line"><span class="comment">/* Closure allows access to the staff variable */</span></div><div class="line">elementary.getStaff()          <span class="comment">// ["Seymour Skinner", "Edna Krabappel"]</span></div><div class="line">elementary.addStaff(<span class="string">'Otto Mann'</span>)</div><div class="line">elementary.getStaff()          <span class="comment">// ["Seymour Skinner", "Edna Krabappel", "Otto Mann"]</span></div></pre></td></tr></table></figure></p>
<p>在elementary被创建的时候，SpringfieldSchool已经返回。也就是说staff无法被外部访问。唯一可以访问的方式就是里面的闭包函数getStaff和addStaff。</p>
<p>我们来看一个面试题：下面的代码有什么问题，如何修复？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`The value <span class="subst">$&#123;arr[i]&#125;</span> is at index: <span class="subst">$&#123;i&#125;</span>`</span>);</div><div class="line">  &#125;, (i+<span class="number">1</span>) * <span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码输出的结果全部都一样：”The value undefined is at index: 4”。因为所有在setTimeout中定义的匿名函数都引用了同一个外部变量i。当匿名函数执行的时候，i的值为4。</p>
<p>这个问题可以改用IIFE(后面会介绍)方法来解决，通过对每一个匿名函数构建独立的外部作用域来实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`The value <span class="subst">$&#123;arr[j]&#125;</span> is at index: <span class="subst">$&#123;j&#125;</span>`</span>);</div><div class="line">    &#125;, j * <span class="number">1000</span>);</div><div class="line">  &#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，还有一个方法，使用let来声明i。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;'</span>)</div><div class="line">    &#125;,(i)*<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="立即调用的函数表达式-Immediate-Invoked-Function-Expression-IIFE"><a href="#立即调用的函数表达式-Immediate-Invoked-Function-Expression-IIFE" class="headerlink" title="立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)"></a>立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)</h3><p>一个IIFE是一个函数表达式在定义之后立即被调用。常用在你想对一个新声明的变量创建一个隔离的作用域。<br>它的格式为:<code>(function(){....})()</code>。前面的大括号用于告诉编译器这里不仅仅是函数定义，后面的大括号用于执行该函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  result.push( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i &#125; );</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( result[<span class="number">1</span>]() ); <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log( result[<span class="number">3</span>]() ); <span class="comment">// 5</span></div><div class="line">result = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i; <span class="comment">// copy current value of i</span></div><div class="line">    result.push( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> j &#125; );</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( result[<span class="number">1</span>]() ); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log( result[<span class="number">3</span>]() ); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>使用IIFE可以：</p>
<ul>
<li>为函数绑定私有数据</li>
<li>创建一个新的环境</li>
<li>避免污染全局命名空间</li>
</ul>
<h3 id="环境（Context）"><a href="#环境（Context）" class="headerlink" title="环境（Context）"></a>环境（Context）</h3><p>我们往往容易将环境（Context）和作用域（Scope）搞混，解释一下：</p>
<ul>
<li><strong>环境（Context）</strong>：由函数如何被调用而决定，往往指this.</li>
<li><strong>作用域（Scope）</strong>：可访问的变量。</li>
</ul>
<h3 id="函数调用：call-apply-bind"><a href="#函数调用：call-apply-bind" class="headerlink" title="函数调用：call, apply, bind"></a>函数调用：call, apply, bind</h3><p>这三个方法都是为了将this绑定到函数，区别在于调用的方式。</p>
<ul>
<li>.call(a,b,c,d…)会理解执行函数，需要把参数按照顺序传入；</li>
<li>.apply([a,b,c,d…])会理解执行函数，需要把参数组合成数组传入了；</li>
</ul>
<p>.call()和.apply()几乎相同。哪个传入参数方便，你就选择哪个。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Snow = &#123;<span class="attr">surename</span>: <span class="string">'Snow'</span>&#125;</div><div class="line"><span class="keyword">const</span> char = &#123;</div><div class="line">  <span class="attr">surename</span>: <span class="string">'Stark'</span>,</div><div class="line">  <span class="attr">knows</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arg, name</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`You know <span class="subst">$&#123;arg&#125;</span>, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surename&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">char.knows(<span class="string">'something'</span>, <span class="string">'Bran'</span>);              <span class="comment">// You know something, Bran Stark</span></div><div class="line">char.knows.call(Snow, <span class="string">'nothing'</span>, <span class="string">'Jon'</span>);      <span class="comment">// You know nothing, Jon Snow</span></div><div class="line">char.knows.apply(Snow, [<span class="string">'nothing'</span>, <span class="string">'Jon'</span>]);   <span class="comment">// You know nothing, Jon Snow</span></div></pre></td></tr></table></figure></p>
<p>注意：如果你将数组传入call函数，它会认为只有一个参数。</p>
<p>ES6允许使用新的操作符将数组变换为一个序列。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char.knows.call(Snow, ...[<span class="string">"nothing"</span>, <span class="string">"Jon"</span>]);  <span class="comment">// You know nothing, Jon Snow</span></div></pre></td></tr></table></figure></p>
<p>.bind()返回一个新的函数，以及相应的环境和参数。如果你想该函数稍后调用，那么推荐使用bind。<br>.bind()函数的优点在于它可以记录一个执行环境，对于异步调用和事件驱动的编程很有用。</p>
<p>.bind()传参数的方式和call相同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Snow = &#123;<span class="attr">surename</span>: <span class="string">'Snow'</span>&#125;</div><div class="line"><span class="keyword">const</span> char = &#123;</div><div class="line">  <span class="attr">surename</span>: <span class="string">'Stark'</span>,</div><div class="line">  <span class="attr">knows</span>: <span class="function"><span class="keyword">function</span>(<span class="params">arg, name</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`You know <span class="subst">$&#123;arg&#125;</span>, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surename&#125;</span>`</span>);&#125;</div><div class="line">  &#125;</div><div class="line"><span class="keyword">const</span> whoKnowsNothing = char.knows.bind(Snow, <span class="string">'nothing'</span>);</div><div class="line">whoKnowsNothing(<span class="string">'Jon'</span>);  <span class="comment">// You know nothing, Jon Snow</span></div></pre></td></tr></table></figure></p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>要理解JavaScript中this关键字，特别是它指向谁，有时候相当地复杂。this的值通常由函数的执行环境决定。简单的说，执行环境指函数如何被调用的。this像是一个占位符(placeholder)，它指向当方法被调用时，调用对应的方法的对象。</p>
<p>下面有序地列出了判断this指向的规则。如果第一条匹配，那么就不用去检查第二条了。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>当使用new关键字调用函数的时候，this指向新构建的对象(实例)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> = Rachel = <span class="keyword">new</span> Person(<span class="string">'Rachel'</span>,<span class="number">30</span>); <span class="comment">// &#123;name: 'Rachel',age: 30&#125;</span></div></pre></td></tr></table></figure></p>
<h4 id="显示绑定-Explicit-binding"><a href="#显示绑定-Explicit-binding" class="headerlink" title="显示绑定(Explicit binding)"></a>显示绑定(Explicit binding)</h4><p>当使用call或则apply的时候，我们显示的传入一个对象参数，该参数会绑定到this。 注意：.bind()函数不一样。用bind定义一个新的函数，但是依然绑定到原来的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> agent = &#123;<span class="attr">id</span>: <span class="string">'007'</span>&#125;;</div><div class="line">fn.call(agent);    <span class="comment">// &#123; id: '007' &#125;</span></div><div class="line">fn.apply(agent);   <span class="comment">// &#123; id: '007' &#125;</span></div><div class="line"><span class="keyword">var</span> boundFn = fn.bind(agent);</div><div class="line">boundFn();         <span class="comment">// &#123; id: '007' &#125;</span></div></pre></td></tr></table></figure></p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>当一个函数在某个环境下调用(在某个对象里)，this指向该对象。也就是说该函数是对象的一个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> building = &#123;</div><div class="line">  <span class="attr">floors</span>: <span class="number">5</span>,</div><div class="line">  <span class="attr">printThis</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">building.printThis();  <span class="comment">// &#123; floors: 5, printThis: function() &#123;…&#125; &#125;</span></div></pre></td></tr></table></figure></p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>如果上面所有的规则都不满足，那么this指向全局对象(在浏览器中，就是window对象)。当函数没有绑定到某个对象，而单独定义的时候，该函数默认绑定到全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printWindow</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line">printWindow();  <span class="comment">// window object</span></div></pre></td></tr></table></figure></p>
<p>注意：下面的情况中，inner函数中的this指向全局。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dinosaur</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  inner();</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>);        <span class="comment">// window object — the function has overwritten the 'this' context</span></div><div class="line">    <span class="built_in">console</span>.log(self);  <span class="comment">// &#123;name: 'Dino'&#125; — referencing the stored value from the outer context</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myDinosaur = <span class="keyword">new</span> Dinosaur(<span class="string">'Dino'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="词法-Lexical-this"><a href="#词法-Lexical-this" class="headerlink" title="词法(Lexical) this"></a>词法(Lexical) this</h4><p>当是使用<code>=&gt;</code>来定义函数时，this指向定义该函数时候外层的this。<br>备注：大概是和定义的词法(=&gt;)有关，把它称作Lexical this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// &#123; name: 'Garfield' &#125;</span></div><div class="line">  ( <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>) )();   <span class="comment">// &#123; name: 'Garfield' &#125;</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Cat(<span class="string">'Garfield'</span>);</div></pre></td></tr></table></figure></p>
<p><a href="https://blog.fundebug.com/2018/01/22/the-definitive-javascript-handbook-for-a-developer-interview-2/" target="_blank" rel="external">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h3&gt;&lt;p&gt;闭包由一个函数以及该函数定义式所在的环境组成。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;`Hi &lt;span class=&quot;subst&quot;&gt;$&amp;#123;name&amp;#125;&lt;/span&gt;`&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;greeting&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(message);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; greeting();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sayHiToJon = sayHi(&lt;span class=&quot;string&quot;&gt;&#39;Jon&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sayHiToJon)     &lt;span class=&quot;comment&quot;&gt;// ƒ() &amp;#123; console.log(message) &amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sayHiToJon())   &lt;span class=&quot;comment&quot;&gt;// &#39;Hi Jon!&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础1</title>
    <link href="https://callmejay.github.io/2018/02/20/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%801/"/>
    <id>https://callmejay.github.io/2018/02/20/快速掌握JavaScript面试基础1/</id>
    <published>2018-02-20T10:15:33.000Z</published>
    <updated>2018-02-22T09:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类型和类型转换"><a href="#类型和类型转换" class="headerlink" title="类型和类型转换"></a>类型和类型转换</h3><p>在JavaScript中有7个内置类型：null,undefined,boolean,number,string,object和symbol（ES6)。</p>
<p>除了object以外，其他都叫做基本类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="number">0</span> <span class="comment">//number</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></div><div class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">// string</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'Hi'</span>) <span class="comment">// symbol</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<ul>
<li>Null vs. Undefined</li>
</ul>
<p><strong>Undefined</strong>表示未定义。对于没有初始化的变量，函数调用时未提供的函数参数，不存在的对象属性，它们的默认值就是undefined。如果一个函数没有返回语句，那么默认的返回值也是undefined。</p>
<p><strong>Null</strong>表示值为空。一个变量我们可以将其赋值为null,表示当前没有值。</p>
<ul>
<li>隐士转换</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'Joey'</span>;</div><div class="line"><span class="keyword">if</span> (name) &#123;</div><div class="line">  <span class="built_in">console</span>.log(name + <span class="string">" doesn't share food!"</span>)  <span class="comment">// Joey doesn’t share food!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在if语句的条件判断中，name从字符串转换为布尔型。在if的代码块中，在控制台将name原原本本打印出来。你知道在什么情况下字符串会转换为真，什么时候为假么？</p>
<p><code>&quot;&quot;，0， null，undefined, NaN, false 会自动转换为false</code>。其它的都会转换为真：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)         <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">'hello'</span>)      <span class="comment">// true </span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">'0'</span>)          <span class="comment">// true </span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">' '</span>)          <span class="comment">// true </span></div><div class="line"><span class="built_in">Boolean</span>([])           <span class="comment">// true </span></div><div class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>空数组、对象、函数定义都会自动转换为真。</p>
<ul>
<li>String &amp; Number之间的转换</li>
<li>第一个你要非常小心的是<code>+</code>操作符。因为它同时用于数字相加和字符串拼接。</li>
</ul>
<p><code>*,/,-</code>只用于数字运算，当这些操作符和字符串一起使用，那么字符串会被强制转换为数字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + <span class="string">"2"</span> = <span class="string">"12"</span></div><div class="line"><span class="string">""</span> + <span class="number">1</span> + <span class="number">0</span> = <span class="string">"10"</span></div><div class="line"><span class="string">""</span> - <span class="number">1</span> + <span class="number">0</span> = <span class="number">-1</span></div><div class="line"><span class="string">"-9\n"</span> + <span class="number">5</span> = <span class="string">"-9\n5"</span></div><div class="line"><span class="string">"-9\n"</span> - <span class="number">5</span> = <span class="number">-14</span></div><div class="line"><span class="string">"2"</span> * <span class="string">"3"</span> = <span class="number">6</span></div><div class="line"><span class="number">4</span> + <span class="number">5</span> + <span class="string">"px"</span> = <span class="string">"9px"</span></div><div class="line"><span class="string">"$"</span> + <span class="number">4</span> + <span class="number">5</span> = <span class="string">"$45"</span></div><div class="line"><span class="string">"4"</span> - <span class="number">2</span> = <span class="number">2</span></div><div class="line"><span class="string">"4px"</span> - <span class="number">2</span> = <span class="literal">NaN</span></div><div class="line"><span class="literal">null</span> + <span class="number">1</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<ul>
<li>== vs. ===</li>
</ul>
<p>一个广泛被接受的认知就是：==判断值是否相等，===同时判断值是否相等和类型是否相同。但是，这里有些误解。</p>
<p>实际上，==在验证相等性的时候，会对类型不同的值做一个类型转换。===对要判断的值不做类型转换。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span> == <span class="string">'2'</span>            <span class="comment">// True</span></div><div class="line"><span class="number">2</span> === <span class="string">'2'</span>           <span class="comment">// False</span></div><div class="line"><span class="literal">undefined</span> == <span class="literal">null</span>   <span class="comment">// True</span></div><div class="line"><span class="literal">undefined</span> === <span class="literal">null</span>  <span class="comment">// False</span></div></pre></td></tr></table></figure></p>
<p>类型转换有很多取巧的地方，要注意：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="string">'0'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(a)); <span class="comment">// True</span></div><div class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(b)); <span class="comment">// False</span></div><div class="line"><span class="string">``</span><span class="string">`	</span></div><div class="line">你认为下面的相等判断会输出什么值呢?</div><div class="line">`<span class="string">``</span>js</div><div class="line"><span class="built_in">console</span>.log(a == b);</div></pre></td></tr></table></figure></p>
<p>实际上会返回true。知道为什么吗？</p>
<p><strong>如果你将一个布尔类型的和非布尔类型的判断，JavaScript会将布尔类型的转换为数字然后再比对。</strong><br>执行过程如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'0'</span> == <span class="literal">false</span>   (<span class="number">1</span>)</div><div class="line"><span class="string">'0'</span> == <span class="number">0</span>       (<span class="number">2</span>)</div><div class="line"> <span class="number">0</span>  == <span class="number">0</span>       (<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>所以，最终变成了0==0，当然返回true啦。</p>
<p>一些比较容易掉坑的比较，我在这里列出来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="literal">false</span> == <span class="string">""</span>  <span class="comment">// true</span></div><div class="line"><span class="literal">false</span> == []  <span class="comment">// true</span></div><div class="line"><span class="literal">false</span> == &#123;&#125;  <span class="comment">// false</span></div><div class="line"><span class="string">""</span> == <span class="number">0</span>      <span class="comment">// true</span></div><div class="line"><span class="string">""</span> == []     <span class="comment">// true</span></div><div class="line"><span class="string">""</span> == &#123;&#125;     <span class="comment">// false</span></div><div class="line"><span class="number">0</span> == []      <span class="comment">// true</span></div><div class="line"><span class="number">0</span> == &#123;&#125;      <span class="comment">// false</span></div><div class="line"><span class="number">0</span> == <span class="literal">null</span>    <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="值-vs-引用"><a href="#值-vs-引用" class="headerlink" title="值 vs. 引用"></a>值 vs. 引用</h3><p>对于基本类型的值，赋值是通过值拷贝的形式；比如：null，undefined，boolean，number，string和ES6的symbol。对于复杂类型的值，通过引用拷贝的形式赋值。比如：对象、对象包括数组和函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;        <span class="comment">// 'a' hold a copy of the value 2.</span></div><div class="line"><span class="keyword">var</span> b = a;        <span class="comment">// 'b' is always a copy of the value in 'a'</span></div><div class="line">b++;</div><div class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 3</span></div><div class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> d = c;        <span class="comment">// 'd' is a reference to the shared value</span></div><div class="line">d.push( <span class="number">4</span> );      <span class="comment">// Mutates the referenced value (object)</span></div><div class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(d);   <span class="comment">// [1,2,3,4]</span></div><div class="line"><span class="comment">/* Compound values are equal by reference */</span></div><div class="line"><span class="keyword">var</span> e = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(c === d);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(c === e);  <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>如果想对复杂类型的值进行值拷贝，你需要自己去对所有子元素进行拷贝。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> copy = c.slice()    <span class="comment">// 'copy' 即使copy和c相同，但是copy指向新的值</span></div><div class="line"><span class="built_in">console</span>.log(c);           <span class="comment">// [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(copy);        <span class="comment">// [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(c === copy);  <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h3><p>作用域是程序的执行环境，它包含了在当前位置可访问的变量和函数。</p>
<p>全局作用域是最外层的作用域，在函数外面定义的变量属于全局作用域，可以被任何其他子作用域访问。在浏览器中，window对象就是全局作用域。</p>
<p>局部作用域是在函数内部的作用域。在局部作用域定义的变量只能在该作用域以及其子作用域被访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innermost</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">let</span> c = <span class="number">3</span>;</div><div class="line">      <span class="built_in">console</span>.log(a, b, c);   <span class="comment">// 1 2 3</span></div><div class="line">    &#125;</div><div class="line">    innermost();</div><div class="line">    <span class="built_in">console</span>.log(a, b);        <span class="comment">// 1 2 — 'c' is not defined</span></div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(a);             <span class="comment">// 1 — 'b' and 'c' are not defined</span></div><div class="line">&#125;</div><div class="line">outer();</div></pre></td></tr></table></figure></p>
<p>你可以将作用域想象成一系列不断变小的门。如果一个个子不高的人可以穿过最小的门(局部最小作用域)，那么必然可以穿过任何比它大的门(外部作用域)。</p>
<h3 id="提升-Hoisting"><a href="#提升-Hoisting" class="headerlink" title="提升(Hoisting)"></a>提升(Hoisting)</h3><p>在编译过程中，将var和function的定义移动到他们作用域最前面的行为叫做提升。</p>
<p>整个函数定义会被提升。所以，你可以在函数还未定义之前调用它，而不用担心找不到该函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(toSquare(<span class="number">3</span>));  <span class="comment">// 9</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toSquare</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> n*n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变量只会被部分提升。而且只有变量的声明会被提升，赋值不会动。</p>
<p>let和const不会被提升。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;  <span class="comment">/* Original code */</span></div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// undefined</span></div><div class="line">  <span class="keyword">var</span> i = <span class="number">10</span></div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;  <span class="comment">/* Compilation phase */</span></div><div class="line">  <span class="keyword">var</span> i;</div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// undefined</span></div><div class="line">  i = <span class="number">10</span></div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// ES6 let &amp; const</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// ReferenceError: i is not defined</span></div><div class="line">  <span class="keyword">const</span> i = <span class="number">10</span></div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// ReferenceError: i is not defined</span></div><div class="line">  <span class="keyword">let</span> i = <span class="number">10</span></div><div class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h3><ul>
<li>函数表达式</li>
</ul>
<p>一个函数表达式是在函数执行到函数表达式定义的位置才开始创建，并被使用。它不会被提升。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>函数声明</li>
</ul>
<p>函数声明的函数可以在文件中任意位置调用，因为它会被提升。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量：var，let和const"><a href="#变量：var，let和const" class="headerlink" title="变量：var，let和const"></a>变量：var，let和const</h3><p>在ES6之前，只能使用var来声明变量。在一个函数体中声明的变量和函数，周围的作用域内无法访问。在块作用域if和for中声明的变量，可以在if和for的外部被访问。</p>
<p>注意：如果没有使用var,let或则const关键字声明的变量将会绑定到全局作用域上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(s) <span class="comment">// undefined</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">var</span> s = <span class="string">'Hi'</span>;</div><div class="line">    undeclaredVar = <span class="string">'I am automatically created in global scope'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(s) <span class="comment">// 'Hi'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// Error — ReferenceError: s is not defined</span></div><div class="line">greeting();</div><div class="line"><span class="built_in">console</span>.log(undeclaredVar) <span class="comment">// 'I am automatically created in global scope'</span></div></pre></td></tr></table></figure></p>
<p>ES6的let和const都是新引入的关键字。它们不会被提升，而且是块作用域。也就是说被大括号包围起来的区域声明的变量外部将不可访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> g1 = <span class="string">'global 1'</span></div><div class="line"><span class="keyword">let</span> g2 = <span class="string">'global 2'</span></div><div class="line">&#123;   <span class="comment">/* Creating a new block scope */</span></div><div class="line">    g1 = <span class="string">'new global 1'</span></div><div class="line">    <span class="keyword">let</span> g2 = <span class="string">'local global 2'</span></div><div class="line">    <span class="built_in">console</span>.log(g1)   <span class="comment">// 'new global 1'</span></div><div class="line">    <span class="built_in">console</span>.log(g2)   <span class="comment">// 'local global 2'</span></div><div class="line">    <span class="built_in">console</span>.log(g3)   <span class="comment">// ReferenceError: g3 is not defined</span></div><div class="line">    <span class="keyword">let</span> g3 = <span class="string">'I am not hoisted'</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(g1)    <span class="comment">// 'new global 1'</span></div><div class="line"><span class="built_in">console</span>.log(g2)    <span class="comment">// 'global 2'</span></div></pre></td></tr></table></figure></p>
<p>一个常见的误解是：使用const声明的变量，其值不可更改。准确地说它不可以被重新赋值，但是可以更改。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tryMe = <span class="string">'initial assignment'</span>;</div><div class="line">tryMe = <span class="string">'this has been reassigned'</span>;  <span class="comment">// TypeError: Assignment to constant variable.</span></div><div class="line"></div><div class="line"><span class="comment">// You cannot reassign but you can change it…</span></div><div class="line"><span class="keyword">const</span> array = [<span class="string">'Ted'</span>, <span class="string">'is'</span>, <span class="string">'awesome!'</span>];</div><div class="line">array[<span class="number">0</span>] = <span class="string">'Barney'</span>;</div><div class="line">array[<span class="number">3</span>] = <span class="string">'Suit up!'</span>;</div><div class="line"><span class="built_in">console</span>.log(array);     <span class="comment">// [“Barney”, “is”, “awesome!”, “Suit up!”]</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> airplane = &#123;&#125;;</div><div class="line">airplane.wings = <span class="number">2</span>;</div><div class="line">airplane.passengers = <span class="number">200</span>;</div><div class="line"><span class="built_in">console</span>.log(airplane);   <span class="comment">// &#123;passengers: 200, wings: 2&#125;</span></div></pre></td></tr></table></figure></p>
<p><a href="https://blog.fundebug.com/2018/01/15/the-definitive-javascript-handbook-for-a-developer-interview/" target="_blank" rel="external">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;类型和类型转换&quot;&gt;&lt;a href=&quot;#类型和类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型和类型转换&quot;&gt;&lt;/a&gt;类型和类型转换&lt;/h3&gt;&lt;p&gt;在JavaScript中有7个内置类型：null,undefined,boolean,number,string,object和symbol（ES6)。&lt;/p&gt;
&lt;p&gt;除了object以外，其他都叫做基本类型。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//number&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// boolean&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;Hi&#39;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// symbol&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之原型和原型链</title>
    <link href="https://callmejay.github.io/2018/02/08/JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://callmejay.github.io/2018/02/08/JavaScript之原型和原型链/</id>
    <published>2018-02-08T14:02:47.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p>我们先使用构造函数创建一个对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.name = <span class="string">'lili'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// lili</span></div></pre></td></tr></table></figure></p>
<p>在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。<br><a id="more"></a></p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每一个<strong>函数都有一个prototype属性</strong>，就是我们经常在各种例子中看到那个prototype,比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">*虽然写在注释了，但是要注意：prototype是函数才会有的属性</div><div class="line">*/</div><div class="line">Person.prototype.name = <span class="string">'Jay'</span>;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// jay</span></div><div class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// jay</span></div></pre></td></tr></table></figure></p>
<p>那这个函数的prototype属性到底指向的是什么呢？</p>
<p>其实，函数的prototype属性指向了一个对象，这个对象正是<strong>调用该构造函数而创建的实例</strong>的原型，也就是这个例子中的person1和person2的原型。</p>
<p>那什么是原型呢？可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype1.png" alt=""><br>在这张图中我们用的<code>Object.prototype</code>表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢？</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>这是每一个JavaScript对象（null除外）都具有的一个属性，叫__proto__，这个属性会指向该对象的原型，证明如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype2.png" alt=""><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就是第三个属性: constructor，每个原型都有一个constructor属性指向关联的构造函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(Person === <span class="built_in">Object</span>.prototype.constructor);</div></pre></td></tr></table></figure></p>
<p>再更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype3.png" alt=""><br>综上所述:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor = Person); <span class="comment">// true</span></div><div class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系。</p>
<h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br>举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">'jay'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person.name = <span class="string">'John'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// John</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// jay</span></div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们给实例对象person添加了name属性，当我们打印person.name的时候，结果自然为John。</p>
<p>但是当我们删除了person的name属性时，读取person.name,从person对象中找不到name属性就会从person的原型也就是person.__proto__,也就是Person.prototype中查找，幸运的是我们找打name属性，结果为jay。</p>
<p>但是万一没找到呢，原型的原型又是什么呢？</p>
<h3 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h3><p>在前面，我们已经讲了原型也是一个对象，既然是对象，那我们就可以用最原始的方式创建它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.name = <span class="string">'Kevin'</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Kevin</span></div></pre></td></tr></table></figure></p>
<p>其实原型对象就是通过Object构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的prototype,所以载更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype4.png" alt=""></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>那Object.prototype的原型呢？<br>null, 我们可以打印：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>然而null究竟代表了什么呢？</p>
<blockquote>
<p>null代表’没有对象’，即该处不该有值。</p>
</blockquote>
<p><img src="http://oonulpk6h.bkt.clouddn.com/null&amp;undefined.png" alt=""><br>所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype5.png" alt=""></p>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是<strong>原型链</strong>，也就是蓝色的这条线。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h4><p>首先是constructor属性，例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.constructor == Person); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有这个属性，所以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person.constructor = Person.prototype.constructor</div></pre></td></tr></table></figure></p>
<h4 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h4><p>其次是__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h4 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h4><p>最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性的说法， 引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建了一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和方法，所以与其叫继承，委托的说法反而更准确些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;构造函数创建对象&quot;&gt;&lt;a href=&quot;#构造函数创建对象&quot; class=&quot;headerlink&quot; title=&quot;构造函数创建对象&quot;&gt;&lt;/a&gt;构造函数创建对象&lt;/h3&gt;&lt;p&gt;我们先使用构造函数创建一个对象：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&#39;lili&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person.name); &lt;span class=&quot;comment&quot;&gt;// lili&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="原型" scheme="https://callmejay.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="https://callmejay.github.io/2018/02/07/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>https://callmejay.github.io/2018/02/07/前端跨域整理/</id>
    <published>2018-02-07T15:41:20.000Z</published>
    <updated>2018-02-10T09:29:37.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><blockquote>
<p>跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。</p>
</blockquote>
<a id="more"></a>
<p>下面是具体的跨域情况详解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">URL                      说明       是否允许通信</div><div class="line">http://www.a.com/a.js</div><div class="line">http://www.a.com/b.js     同一域名下   允许</div><div class="line"></div><div class="line">http://www.a.com/lab/a.js</div><div class="line">http://www.a.com/script/b.js 同一域名下不同文件夹 允许</div><div class="line"></div><div class="line">http://www.a.com:8000/a.js</div><div class="line">http://www.a.com/b.js     同一域名，不同端口  不允许</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">https://www.a.com/b.js 同一域名，不同协议 不允许</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">http://70.32.92.74/b.js 域名和域名对应ip 不允许</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">http://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</div><div class="line"></div><div class="line">http://www.cnblogs.com/a.js</div><div class="line">http://www.a.com/b.js 不同域名 不允许</div></pre></td></tr></table></figure></p>
<p><strong>这里我们需要注意两点:</strong></p>
<ul>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</li>
</ul>
<h3 id="通过document-domain跨域"><a href="#通过document-domain跨域" class="headerlink" title="通过document.domain跨域"></a>通过document.domain跨域</h3><blockquote>
<p>前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<code>www.damonare.cn/a.html</code> ， 在这个页面里面有一个iframe，它的src是<code>damonare.cn/b.html</code>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function test()&#123;</div><div class="line">        var iframe = document.getElementById('ifame');</div><div class="line">        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</div><div class="line">        var doc = win.document;//这里获取不到iframe里的document对象</div><div class="line">        var name = win.name;//这里同样获取不到window对象的name属性</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，<code>document.domain</code>就可以派上用场了，我们只要把<code>www.damonare.cn/a.html</code>和<code>damonare.cn/b.html</code>这两个页面的<code>document.domain</code>都设成相同的域名就可以了。但要注意的是，<code>document.domain</code>的设置是有限制的，我们只能把<code>document.domain</code>设置成自身或更高一级的父域，且主域必须相同。</p>
</blockquote>
<p>在页面<code>www.damonare.cn/a.html</code>中设置<code>document.domain</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://damonare.cn/b.html"</span> onload = <span class="string">"test()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//设置成主域</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>在页面<code>damonare.cn/b.html</code>中也设置<code>document.domain</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>修改<code>document.domain</code>的方法只适用于不同子域的框架间的交互。</strong></p>
<h3 id="通过location-hash跨域"><a href="#通过location-hash跨域" class="headerlink" title="通过location.hash跨域"></a>通过location.hash跨域</h3><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。</p>
</blockquote>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。<br>1, a.html传送数据到b.html</p>
<ul>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
</ul>
<p>2, b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</p>
<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”www.baidu.com/proxy.html#…”</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
<p>b.html页面的关键代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;  </div><div class="line">    parent.location.hash = <span class="string">'data'</span>;  </div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </div><div class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，  </span></div><div class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </div><div class="line">    ifrproxy.style.display = <span class="string">'none'</span>;  </div><div class="line">    ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html#data"</span>;  </div><div class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>proxy.html页面的关键代码如下 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span></div><div class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<h3 id="通过HTML5的postMessage方法跨域"><a href="#通过HTML5的postMessage方法跨域" class="headerlink" title="通过HTML5的postMessage方法跨域"></a>通过HTML5的postMessage方法跨域</h3><blockquote>
<p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。</p>
</blockquote>
<p>比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。</p>
<p>A页面通过postMessage方法发送消息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);</div><div class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">'http://www.google.com'</span>;</div><div class="line">    ifr.contentWindow.postMessage(<span class="string">'hello'</span>,targetOrigin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>postMessage的使用方法：</strong></p>
<ul>
<li>otherWindow.postMessage(message, targetOrigin);</li>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames属性的成员或者由window.open方法创建的窗口</li>
<li>message:是要发送的消息，类型为String、Object(IE8、9 不支持)<br>targetOrigin:是限定消息接收范围，不限制请使用 ‘*’</li>
</ul>
<p>B页面通过message事件监听并接受消息:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> data = ev.data; <span class="comment">// 消息</span></div><div class="line">    <span class="keyword">var</span> origin = ev.origin; <span class="comment">// 消息来源地址</span></div><div class="line">    <span class="keyword">var</span> source = ev.source; <span class="comment">// 源window对象 </span></div><div class="line">    <span class="keyword">if</span>(origin == <span class="string">'http://www.baidu.com'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(data); <span class="comment">// hello</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,onmessage,<span class="literal">false</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123; <span class="comment">// ie</span></div><div class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">'message'</span>,onmessage);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<h3 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h3><blockquote>
<p>刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
</blockquote>
<p>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是damonare.cn/data.php, 那么a.html中的代码就可以这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function dosomething(jsondata)&#123;</div><div class="line">        //处理获得的json数据</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</p>
<p>因为是当做一个js文件来引入的，所以<code>damonare.cn/data.php</code>返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></div><div class="line">$data = array(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></div><div class="line">echo $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</div><div class="line">        <span class="comment">//处理获得的json数据</span></div><div class="line">    &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<p>JSONP的优缺点：</p>
<ul>
<li>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</li>
<li>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h3 id="通过CORS跨域"><a href="#通过CORS跨域" class="headerlink" title="通过CORS跨域"></a>通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。<strong>CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</strong>目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<p>平时的ajax请求可能是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">'/getSomething'</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>以上getSomething部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">'http://jaybein.site/getSomething'</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>
<p>服务器端对于CORS的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享CORS详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;什么是跨域？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="https://callmejay.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>对缓存的一点理解</title>
    <link href="https://callmejay.github.io/2018/02/07/%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>https://callmejay.github.io/2018/02/07/对缓存的一点理解/</id>
    <published>2018-02-07T13:44:29.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p>
</blockquote>
<h3 id="缓存的种类"><a href="#缓存的种类" class="headerlink" title="缓存的种类"></a>缓存的种类</h3><p>很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。<br><a id="more"></a><br>实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。</p>
<p>缓存好处有很多：</p>
<ul>
<li>缓解服务器压力(不用每次去请求资源)；</li>
<li>提升性能(打开本地资源速度当然比请求回来再打开要快得多)；</li>
<li>减少带宽消耗(我相信你可以理解)；</li>
</ul>
<h3 id="浏览器的缓存策略"><a href="#浏览器的缓存策略" class="headerlink" title="浏览器的缓存策略"></a>浏览器的缓存策略</h3><p><strong>缓存的目标:</strong></p>
<ul>
<li>一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；</li>
<li>不变的重定向: 响应状态码：301；</li>
<li>可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；</li>
<li>错误响应: 响应状态码：404 的一个页面；</li>
<li>不完全的响应: 响应状态码 206，只返回局部的信息；</li>
<li>除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；</li>
</ul>
<p><strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</strong><br>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Age:23146</div><div class="line">Cache-Control:max-age=2592000</div><div class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</div><div class="line">ETag:W/&quot;5a1cf09a-63c6&quot;</div><div class="line">Expires:Thu, 28 Dec 2017 05:27:45 GMT</div><div class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</div><div class="line">Vary:Accept-Encoding</div></pre></td></tr></table></figure></p>
<h4 id="强缓存阶段"><a href="#强缓存阶段" class="headerlink" title="强缓存阶段"></a>强缓存阶段</h4><p>以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，<code>Expires</code>是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。<code>Cache-Control:max-age=2592000</code>是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，<code>max-age &gt; Expires</code>。</p>
<p>这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️</p>
<p>Firefox浏览器表现为一个灰色的200状态码。</p>
<p>Chrome浏览器状态码表现为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">200 (from disk cache)或是200 OK (from memory cache)</div></pre></td></tr></table></figure></p>
<p><strong>多说一点：</strong>关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是<code>from memory cache</code>有时是<code>from disk cache</code>的问题了。</p>
<h4 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h4><p>那么当这个CSS文件过期了怎么办?<code>ETag</code>和<code>Last-Modified</code>就该闪亮登场了。</p>
<p>先说<code>Last-Modified</code>，这个字段是文件最后一次修改的时间；</p>
<p><code>ETag</code>呢？<code>ETag</code>是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。</p>
<p>利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带<code>If-Moified-Since</code>和<code>If-None-Match</code>这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑</p>
<p>具体两个字段携带的内容如下(分别和上面的<code>Last-Modified</code>、<code>ETag</code>携带的值对应)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT</div><div class="line">If-None-Match: W/&quot;5a1cf09a-63c6&quot;</div></pre></td></tr></table></figure></p>
<p>到这协商缓存结束。</p>
<h4 id="启发式缓存阶段"><a href="#启发式缓存阶段" class="headerlink" title="启发式缓存阶段"></a>启发式缓存阶段</h4><p>我们把上面的响应头改下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Age:23146</div><div class="line">Cache-Control: public</div><div class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</div><div class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</div><div class="line">Vary:Accept-Encoding</div></pre></td></tr></table></figure></p>
<p>发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带<code>If-Moified-Since</code>呗，不是的，浏览器还有个启发式缓存阶段。</p>
<p><strong>根据响应头中2个时间字段<code>Date</code>和<code>Last-Modified</code>之间的时间差值，取其值的10%作为缓存时间周期</strong>。</p>
<p>这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种<code>默认缓存</code>的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。<br>下面用一张图，来解释浏览器整个缓存策略的过程：<br><img src="http://oonulpk6h.bkt.clouddn.com/broswer_cache" alt="浏览器缓存过程"><br>对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。</p>
<blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7?utm_source=gold_browser_extension" target="_blank" rel="external">传送门</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;缓存的种类&quot;&gt;&lt;a href=&quot;#缓存的种类&quot; class=&quot;headerlink&quot; title=&quot;缓存的种类&quot;&gt;&lt;/a&gt;缓存的种类&lt;/h3&gt;&lt;p&gt;很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。&lt;br&gt;
    
    </summary>
    
      <category term="浏览器" scheme="https://callmejay.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="cache" scheme="https://callmejay.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript:彻底理解同步、异步和事件循环（Event Loop）</title>
    <link href="https://callmejay.github.io/2018/02/06/JavaScript-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/02/06/JavaScript-彻底理解同步、异步和事件循环（Event-Loop）/</id>
    <published>2018-02-06T13:05:10.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。</p>
</blockquote>
<a id="more"></a>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<p>如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在函数返回时，获得了预期值，即2的平方根</span></div><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">2</span>);</div><div class="line"><span class="comment">//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div></pre></td></tr></table></figure></p>
<p>上面两个函数就是同步的。<br><strong>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</strong></p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<p>如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取文件</span></div><div class="line">fs.readFile(<span class="string">'hello.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//网络请求</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.send(); <span class="comment">// 发起函数</span></div></pre></td></tr></table></figure></p>
<p>上述示例中读取文件函数 <code>readFile</code>和网络请求的发起函数  <code>send</code>都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在<code>JavaScript</code>中通过回调函数<code>function(err, data) { console.log(data); }</code>和 <code>onreadystatechange</code>，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行<code>JavaScript</code>代码的线程执行回调。</p>
<p><strong>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</strong></p>
<h3 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h3><p>在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？</p>
<p>JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。</p>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。<br>一个浏览器通常由以下几个常驻的线程：</p>
<ul>
<li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li>
<li>JS引擎线程：负责JS的解析和执行</li>
<li>定时触发器线程：处理定时事件，比如setTimeout, setInterval</li>
<li>事件触发线程：处理DOM事件</li>
<li>异步http请求线程：处理http请求</li>
</ul>
<p>需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。</p>
<h4 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h4><p>通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。</p>
<p>JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤：</p>
<ul>
<li>词法分析：将源代码分解为有意义的分词</li>
<li>语法分析：用语法分析器将分词解析成语法树</li>
<li>代码生成：生成机器能运行的代码</li>
<li>代码执行</li>
</ul>
<p>不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。</p>
<p>之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。</p>
<p><strong>所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</strong></p>
<h3 id="消息队列与事件循环"><a href="#消息队列与事件循环" class="headerlink" title="消息队列与事件循环"></a>消息队列与事件循环</h3><p>通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？</p>
<p>这一切的解释就需要继续了解消息队列和事件循环。</p>
<p><img src="http://oonulpk6h.bkt.clouddn.com/message&amp;queue" alt="消息队列"></p>
<p>如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。</p>
<p>JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫<strong>事件循环</strong>。</p>
<p><img src="http://oonulpk6h.bkt.clouddn.com/ajax%E7%BA%BF%E7%A8%8B" alt="AJAX过程"></p>
<p>上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。</p>
<p>从上文中我们也可以得到这样一个明显的结论，就是：</p>
<blockquote>
<p>异步过程的回调函数，一定不在当前这一轮事件循环中执行。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。</p>
<blockquote>
<p>执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'timer a'</span>);</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</div><div class="line">    <span class="built_in">console</span>.log(j);</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'timer b'</span>);</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitFiveSeconds</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">    <span class="keyword">while</span>(((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - now) &lt; <span class="number">5000</span>)&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'finished waiting'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'click begin'</span>);</div><div class="line">waitFiveSeconds();</div></pre></td></tr></table></figure>
<p>要想了解上述代码的输出结果，首先介绍下定时器。</p>
<p><code>setTimeout</code>的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，<strong>所以间隔的时间一般会大于等于指定的时间</strong>。</p>
<p><code>setTimeout(fn, 0)</code>的意思是，将回调函数<code>fn</code>立刻插入消息队列，等待执行，而不是立即执行。看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>)</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b a</div></pre></td></tr></table></figure>
<p>打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。</p>
<p>理解了定时器的作用，那么对于输出结果就容易得出了。</p>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达5s。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line">click begin</div><div class="line">finished waiting</div></pre></td></tr></table></figure></p>
<p>然后，在JS引擎线程执行的时候，<code>&#39;timer a&#39;</code>对应的定时器产生的回调、 <code>&#39;timer b&#39;</code>对应的定时器产生的回调和两次<code>click</code>对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">click</div><div class="line">click</div><div class="line">timer a</div><div class="line">timer b</div></pre></td></tr></table></figure></p>
<p>最后，5s 后的两次<code>click</code>事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">click</div><div class="line">click</div></pre></td></tr></table></figure></p>
<h3 id="异步与事件"><a href="#异步与事件" class="headerlink" title="异步与事件"></a>异步与事件</h3><p>上文中说的“事件循环”，为什么里面有个事件呢？那是因为：</p>
<blockquote>
<p>消息队列中的每条消息实际上都对应着一个事件。</p>
</blockquote>
<p>上文中一直没有提到一类很重要的异步过程：<code>DOM事件</code>。<br>举例说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElement(<span class="string">'#btn'</span>);</div><div class="line">button.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'lalla'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。</p>
<p>从异步过程的角度看，<code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。</p>
<p>这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些.</p>
<p><strong>参考文章</strong>：<br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop</a></p>
<blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5a6ad46ef265da3e513352c8?utm_source=gold_browser_extension" target="_blank" rel="external">传送门</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="Event Loop" scheme="https://callmejay.github.io/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之字符串的扩展</title>
    <link href="https://callmejay.github.io/2017/09/01/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://callmejay.github.io/2017/09/01/ES6入门之字符串的扩展/</id>
    <published>2017-09-01T13:38:26.000Z</published>
    <updated>2018-02-10T09:29:37.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p><code>ES6</code>为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(codePoint)</div><div class="line">&#125;</div><div class="line"><span class="comment">// "f"</span></div><div class="line"><span class="comment">// "o"</span></div><div class="line"><span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(),startsWith(),endsWith()"></a>includes(),startsWith(),endsWith()</h3><p>传统上，<code>JavaScript</code>只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。<code>ES6</code>又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></div><div class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数如果是小数，会被取整。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></div></pre></td></tr></table></figure></p>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)</div><div class="line"><span class="comment">// RangeError</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)</div><div class="line"><span class="comment">// RangeError</span></div></pre></td></tr></table></figure></p>
<p>但是，如果参数是<code>0</code>到<code>-1</code>之间的小数，则等同于<code>0</code>，这是因为会先进行取整运算。<code>0</code>到<code>-1</code>之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为<code>0</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数<code>NaN</code>等同于0。<br>如果<code>repeat</code>的参数是字符串，则会先转换成数字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></div></pre></td></tr></table></figure></p>
<h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p><code>ES2017</code>引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<br><code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></div><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></div><div class="line"></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></div></pre></td></tr></table></figure></p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div><div class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div></pre></td></tr></table></figure></p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</div><div class="line"><span class="comment">// '0123456abc'</span></div></pre></td></tr></table></figure></p>
<p>如果省略第二个参数，默认使用空格补全长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></div></pre></td></tr></table></figure></p>
<p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成<code>10</code>位的数值字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></div><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></div><div class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></div></pre></td></tr></table></figure></p>
<p>另一个用途是提示字符串格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></div><div class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统的<code>JavaScript</code>语言，输出模板通常是这样写的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(</div><div class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</div><div class="line">  <span class="string">'items in your basket, '</span> +</div><div class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</div><div class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面这种写法相当繁琐不方便，<code>ES6</code>引入了模板字符串解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></div><div class="line">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>模板字符串(template string)是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></div><div class="line">string text line 2`);</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure></p>
<p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</div></pre></td></tr></table></figure></p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">      <span class="comment">// 传统写法为</span></div><div class="line">      <span class="comment">// 'User '</span></div><div class="line">      <span class="comment">// + user.name</span></div><div class="line">      <span class="comment">// + ' is not authorized to do '</span></div><div class="line">      <span class="comment">// + action</span></div><div class="line">      <span class="comment">// + '.'</span></div><div class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大括号内部可以放入任意的<code>JavaScript</code>表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 4 = 5"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></div><div class="line"><span class="comment">// "3"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串之中还能调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></div><div class="line"><span class="comment">// foo Hello World bar</span></div></pre></td></tr></table></figure></p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量place没有声明</span></div><div class="line"><span class="keyword">let</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</div><div class="line"><span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>由于模板字符串的大括号内部，就是执行<code>JavaScript</code>代码，因此如果大括号内部是一个字符串，将会原样输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "Hello World"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串甚至还能嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></div><div class="line">  &lt;table&gt;</div><div class="line">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">  `).join(<span class="string">''</span>)&#125;</div><div class="line">  &lt;/table&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = [</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(tmpl(data));</div><div class="line"><span class="comment">// &lt;table&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// &lt;/table&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串的遍历器接口&quot;&gt;&lt;a href=&quot;#字符串的遍历器接口&quot; class=&quot;headerlink&quot; title=&quot;字符串的遍历器接口&quot;&gt;&lt;/a&gt;字符串的遍历器接口&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被&lt;code&gt;for...of&lt;/code&gt;循环遍历。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; codePoint &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(codePoint)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;f&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;o&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;o&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之变量的解构赋值</title>
    <link href="https://callmejay.github.io/2017/08/28/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://callmejay.github.io/2017/08/28/ES6入门之变量的解构赋值/</id>
    <published>2017-08-28T13:35:22.000Z</published>
    <updated>2018-03-14T14:39:55.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。<br>以前，为变量赋值，只能直接指定值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>ES6允许写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。<br>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备<code>Iterator</code>接口（前五个表达式），要么本身就不具备<code>Iterator</code>接口（最后一个表达式）。<br>对于<code>Set</code>结构，也可以使用数组的解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</div><div class="line">x <span class="comment">// "a"</span></div></pre></td></tr></table></figure></p>
<p>事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> a;</div><div class="line">    [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure></p>
<p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。<br>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</div><div class="line">  x = f();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></div><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure></p>
<p><strong>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。<br>如果变量名与属性名不一致，必须写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f <span class="comment">// 'hello'</span></div><div class="line">l <span class="comment">// 'world'</span></div></pre></td></tr></table></figure></p>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</strong><br>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">p</span>: [</div><div class="line">    <span class="string">'Hello'</span>,</div><div class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class="line">x <span class="comment">// "Hello"</span></div><div class="line">y <span class="comment">// "World"</span></div></pre></td></tr></table></figure></p>
<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">p</span>: [</div><div class="line">    <span class="string">'Hello'</span>,</div><div class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class="line">x <span class="comment">// "Hello"</span></div><div class="line">y <span class="comment">// "World"</span></div><div class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></div></pre></td></tr></table></figure></p>
<p>对象的解构也可以指定默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">x <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</div><div class="line">msg <span class="comment">// "Something went wrong"</span></div></pre></td></tr></table></figure></p>
<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。<br>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误的写法</span></div><div class="line"><span class="keyword">let</span> x;</div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="comment">// SyntaxError: syntax error</span></div></pre></td></tr></table></figure></p>
<p>上面代码的写法会报错，因为<code>JavaScript</code>引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免<code>JavaScript</code>将其解释为代码块，才能解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正确的写法</span></div><div class="line"><span class="keyword">let</span> x;</div><div class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</div><div class="line">(&#123;&#125; = <span class="string">'abc'</span>);</div><div class="line">(&#123;&#125; = []);</div></pre></td></tr></table></figure></p>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。<br>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</div><div class="line">first <span class="comment">// 1</span></div><div class="line">last <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// "h"</span></div><div class="line">b <span class="comment">// "e"</span></div><div class="line">c <span class="comment">// "l"</span></div><div class="line">d <span class="comment">// "l"</span></div><div class="line">e <span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>变量的解构赋值用途很多。</p>
<h4 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<h4 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个数组</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a, b, c] = example();</div><div class="line"></div><div class="line"><span class="comment">// 返回一个对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">bar</span>: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure></p>
<h4 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h4><p>解构赋值可以方便地将一组参数与变量名对应起来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h4><p>解构赋值对提取<code>JSON</code>对象中的数据，尤其有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">42</span>,</div><div class="line">  <span class="attr">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 42, "OK", [867, 5309]</span></div></pre></td></tr></table></figure></p>
<h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line">  async = true,</div><div class="line">  beforeSend = function () &#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  <span class="comment">// ... more config</span></div><div class="line">&#125;) &#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;</code>;这样的语句。</p>
<h4 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h4><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code>结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure></p>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取键名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取键值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h4><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/object#__proto__%E5%B1%9E%E6%80%A7%EF%BC%8CObject-setPrototypeOf%EF%BC%8CObject-getPrototypeOf" target="_blank" rel="external">原文地址</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h3&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;p&gt;ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;br&gt;以前，为变量赋值，只能直接指定值。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ES6允许写成下面这样。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a, b, c] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之let和const</title>
    <link href="https://callmejay.github.io/2017/08/25/ES6%E5%85%A5%E9%97%A8%E4%B9%8Blet%E5%92%8Cconst/"/>
    <id>https://callmejay.github.io/2017/08/25/ES6入门之let和const/</id>
    <published>2017-08-25T13:55:50.000Z</published>
    <updated>2018-02-10T09:29:37.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a <span class="comment">// ReferenceError: a is not defined.</span></div><div class="line">b <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。<br><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line"><span class="comment">// ReferenceError: i is not defined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。<br>下面的代码如果使用<code>var</code>，最后输出的是10。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。<br>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为<code>JavaScript</code>引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// abc</span></div><div class="line"><span class="comment">// abc</span></div><div class="line"><span class="comment">// abc</span></div></pre></td></tr></table></figure></p>
<p>上面代码正确运行，输出了3次abc。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var 的情况</span></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// let 的情况</span></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="comment">// TDZ开始</span></div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></div><div class="line"></div><div class="line">  tmp = <span class="number">123</span>;</div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。<br>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，不能在函数内部重新声明参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h4><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(tmp);</div><div class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数f执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。<br>第二种场景，用来计数的循环变量泄露为全局变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(s[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p><code>let</code>实际上为<code>JavaScript</code>新增了块级作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是10。<br>ES6 允许块级作用域的任意嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;</div><div class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</div><div class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></div><div class="line">&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure></p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<blockquote>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE 写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="comment">// 块级作用域写法</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</div><div class="line">PI <span class="comment">// 3.1415</span></div><div class="line"></div><div class="line">PI = <span class="number">3</span>;</div><div class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></div></pre></td></tr></table></figure></p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。<br><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></div><div class="line">foo.prop = <span class="number">123</span>;</div><div class="line">foo.prop <span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></div><div class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></div><div class="line"><span class="comment">// 严格模式时，该行会报错</span></div><div class="line">foo.prop = <span class="number">123</span>;</div></pre></td></tr></table></figure></p>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在<code>Node</code>指的是<code>global</code>对象。<code>ES5</code>之中，顶层对象的属性与全局变量是等价的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</div><div class="line">a <span class="comment">// 1</span></div><div class="line"></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是<code>JavaScript</code>语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p><code>ES6</code>为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从<code>ES6</code>开始，全局变量将逐步与顶层对象的属性脱钩。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></div><div class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h3&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;p&gt;ES6 新增了&lt;code&gt;let&lt;/code&gt;命令，用来声明变量。它的用法类似于&lt;code&gt;var&lt;/code&gt;，但是所声明的变量，只在&lt;code&gt;let&lt;/code&gt;命令所在的代码块内有效。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a &lt;span class=&quot;comment&quot;&gt;// ReferenceError: a is not defined.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中常见的几种轮播</title>
    <link href="https://callmejay.github.io/2017/08/15/JavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BD%AE%E6%92%AD/"/>
    <id>https://callmejay.github.io/2017/08/15/JavaScript中常见的几种轮播/</id>
    <published>2017-08-15T13:38:59.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<p>项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。<br><a id="more"></a><br><strong>首先奉上轮播图</strong><br><img src="http://oonulpk6h.bkt.clouddn.com/imgScroll.png" alt="轮播图"></p>
<h3 id="无缝不停轮播"><a href="#无缝不停轮播" class="headerlink" title="无缝不停轮播"></a>无缝不停轮播</h3><p>body布局:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span>   <span class="comment">&lt;!--将ul和li包住,起显示图片的作用--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>                                 </div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img1.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img2.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img3.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img4.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img1.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>css样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;    <span class="comment">/*给要动的元素也就是ul 它的父级加上相对定位*/</span></div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;           </div><div class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;       <span class="comment">/*给要动的元素也就是ul 它的父级加上溢出隐藏*/</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">ul</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;     <span class="comment">/*给要动的元素也就是ul 加上绝对定位,才能保证用left和top;*/</span></div><div class="line">    <span class="attribute">width</span>: <span class="number">3000px</span>;          <span class="comment">/*ul 的宽度为 li 的个数 * li 的宽度*/</span></div><div class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">ul</span> &gt;<span class="selector-tag">li</span>&#123;</div><div class="line">    <span class="attribute">float</span>: left;    </div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">ul</span> &gt;<span class="selector-tag">li</span> <span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JS代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);  <span class="comment">//获取ul</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;                 <span class="comment">//设置定时器 </span></div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft&lt;=<span class="number">-2400</span>)&#123;        <span class="comment">//判断:若ul走到倒数第二张图的时候,让left从0开始运行</span></div><div class="line">        ul.style.left=<span class="number">0</span>+<span class="string">'px'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">var</span> left = ul.offsetLeft <span class="number">-3</span>;        <span class="comment">//给ul设置速度</span></div><div class="line">        ul.style.left=left+<span class="string">'px'</span>;            </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> time = <span class="number">10</span>;         <span class="comment">//设定一个时间,以控制其轮播的速度</span></div><div class="line">    setTimeout(step,time);            <span class="comment">//定时器内部调用定时器</span></div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h3 id="无缝停顿轮播"><a href="#无缝停顿轮播" class="headerlink" title="无缝停顿轮播"></a>无缝停顿轮播</h3><blockquote>
<p>停顿轮播在不停轮播的基础上加以改进,判断当ul走到li宽度的倍数时,让定时器的时间加大,就可以起到停顿的效果</p>
</blockquote>
<p>​body布局以及css样式不变</p>
<p>js代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);   <span class="comment">//获取ul</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;                  <span class="comment">//设置定时器 </span></div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft&lt;=<span class="number">-2400</span>)&#123;               <span class="comment">//判断:若ul走到倒数第二张图的时候,让left从0开始运行</span></div><div class="line">        ul.style.left = <span class="number">0</span> +<span class="string">'px'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        speed = <span class="number">-3</span>;     <span class="comment">//给ul设置速度           </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> time;               </div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft%<span class="number">600</span>==<span class="number">0</span>)&#123;               <span class="comment">//做判断:当ul走到li宽度的倍数时</span></div><div class="line">        time = <span class="number">3000</span>;                          <span class="comment">//设定一个很大的时间,也就是很小的速度</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;                                  </div><div class="line">        time = <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    ul.style.left=ul.offsetLeft+speed+<span class="string">'px'</span>;</div><div class="line">    setTimeout(step,time);                  <span class="comment">//定时器内部调用定时器</span></div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h3 id="无缝停顿反向轮播"><a href="#无缝停顿反向轮播" class="headerlink" title="无缝停顿反向轮播"></a>无缝停顿反向轮播</h3><blockquote>
<p>反向轮播在停顿轮播的基础上加以改进,判断当ul最左边和ul走到最右边,将速度反向;<br>将最后一张重复的li去掉并修改ul的宽度</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);</div><div class="line"><span class="keyword">var</span> speed = <span class="number">3</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft&lt;=<span class="number">-1800</span>||ul.offsetLeft&gt;=<span class="number">0</span>)&#123;      <span class="comment">//判断当ul最左边和ul走到最右边,将速度反向;</span></div><div class="line">        speed*=<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> time = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft%<span class="number">600</span>==<span class="number">0</span>)&#123;                    <span class="comment">//做判断:当ul走到li宽度的倍数时</span></div><div class="line">        time = <span class="number">3000</span>;                             <span class="comment">//设定一个很大的时间,也就是很小的速度</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        time=<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    ul.style.left=ul.offsetLeft+speed+<span class="string">'px'</span>;  </div><div class="line">    setTimeout(step,time);                       <span class="comment">//定时器内部调用定时器</span></div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h3 id="透明度普通轮播"><a href="#透明度普通轮播" class="headerlink" title="透明度普通轮播"></a>透明度普通轮播</h3><p>​1.body布局上一样;<br>​2.css样式:将所有li 绝对定位,重叠在一起<br>​3.JS:先获取到ul 和 li 并对 li的数组进行遍历 赋值每个的opacity<br>​<strong>注:要在js中遍历li 再给它赋值opacity,而不是在css中直接设置属性是为了在js中好获取到opacity并给它进行修改设置</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);  <span class="comment">//获取ul</span></div><div class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container &gt; ul &gt;li'</span>);</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lis.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;                   <span class="comment">//默认显示第一张图,让其透明度为1;</span></div><div class="line">        lis[i].style.opacity=<span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//其他图片透明度为0;</span></div><div class="line">        lis[i].style.opacity=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> i=<span class="number">0</span>;                        <span class="comment">//重新赋值i </span></div><div class="line"><span class="keyword">var</span> time = <span class="number">50</span>;                  <span class="comment">//设置时间,控制图片转换的速度,时间越大,速度越慢</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;                 <span class="comment">//设置定时器</span></div><div class="line">    lis[i%<span class="number">4</span>].style.opacity-=<span class="number">0.05</span>;   </div><div class="line">    lis[(i+<span class="number">1</span>)%<span class="number">4</span>].style.opacity=<span class="built_in">parseFloat</span>(lis[(i+<span class="number">1</span>)%<span class="number">4</span>].style.opacity)+<span class="number">0.05</span>;</div><div class="line">    <span class="keyword">if</span>(lis[i%<span class="number">4</span>].style.opacity==<span class="number">0</span>)&#123;</div><div class="line">        i++;</div><div class="line">        time = <span class="number">1000</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        time =<span class="number">50</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setTimeout(step,time);</div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h3 id="透明度指示器轮播"><a href="#透明度指示器轮播" class="headerlink" title="透明度指示器轮播"></a>透明度指示器轮播</h3><p>body布局:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span>                     </div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"picture"</span>&gt;</span>                           <span class="comment">&lt;!--轮播图片区--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img1.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img2.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img3.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img4.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img5.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img6.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"arrow"</span>&gt;</span>                          <span class="comment">&lt;!--左右切换--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"arrowLeft"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"arrowRight"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>                      <span class="comment">&lt;!--指示器--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"margin:0"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>css样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;                        <span class="comment">/*整体样式*/</span></div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> auto;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.picture</span> &#123;             <span class="comment">/*轮播图片区样式*/</span></div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.picture</span> &gt; <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.picture</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">img</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span>&#123;                    <span class="comment">/*左右切换区样式*/</span></div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">height</span>: <span class="number">70px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">40%</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">70px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_left1.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_right1.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_left2.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_right2.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> <span class="selector-class">.bottom</span> &#123;                            <span class="comment">/*指示器样式*/</span></div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">width</span>: <span class="number">215px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">350px</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">background-color</span>: grey;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.bottom</span> &gt; <span class="selector-tag">ul</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">205px</span>;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.bottom</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span>&#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">background-color</span>: white;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>js代码：<br>​<em>代码分析:</em></p>
<ol>
<li>先进行准备工作, 利用for循环将初始化的图片透明度已经指示器的背景色设定好</li>
<li>给整个container添加事件,当鼠标上来的时候,让自动播放停止</li>
<li>给左,右”按钮” 点击事件,用以切换上一张下一张图片;</li>
<li>给指示器onmouseenter事件,使得图片与你的指示器同步,达到随意切换图片的效果;</li>
<li>定义 图片切换的函数 ,使得以上事件都可以调用它</li>
<li>定义自动播放的函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>);</div><div class="line"><span class="keyword">var</span> pictureLis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container &gt; .picture &gt; li'</span>);</div><div class="line"><span class="keyword">var</span> optionLis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container &gt; .bottom &gt;ul &gt; li'</span>);</div><div class="line"><span class="keyword">var</span> arrowLeft = <span class="built_in">document</span>.querySelector(<span class="string">'.container .arrow  &gt; .arrowLeft'</span>);</div><div class="line"><span class="keyword">var</span> arrowRight = <span class="built_in">document</span>.querySelector(<span class="string">'.container .arrow &gt; .arrowRight'</span>);</div><div class="line"><span class="keyword">var</span> showIndex = <span class="number">0</span>;  <span class="comment">//当前正在显示的图片的下标</span></div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; pictureLis.length; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</div><div class="line">            optionLis[j].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">            pictureLis[j].style.opacity = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            pictureLis[j].style.opacity = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//给整个container添加事件,当鼠标上来的时候,让自动播放停止</span></div><div class="line">    container.onmouseenter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        clearTimeout(autoPlayId);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    container.onmouseleave = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        auto();</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//给左按钮和右按钮添加点击事件</span></div><div class="line">    arrowLeft.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        optionLis[showIndex % optionLis.length].style.backgroundColor=<span class="string">'white'</span>;</div><div class="line">        <span class="keyword">var</span> preIndex = showIndex<span class="number">-1</span>+pictureLis.length;</div><div class="line">        move(showIndex,preIndex);</div><div class="line">        showIndex=preIndex;</div><div class="line">        optionLis[showIndex%optionLis.length].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">    &#125;;</div><div class="line">    arrowRight.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        optionLis[showIndex % optionLis.length].style.backgroundColor=<span class="string">'white'</span>;</div><div class="line">        move(showIndex,showIndex+<span class="number">1</span>);</div><div class="line">        showIndex++;</div><div class="line">        optionLis[showIndex%optionLis.length].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//给指示器添加onmouseenter事件,使得图片与指示器同步</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;optionLis.length;i++)&#123;</div><div class="line">        optionLis[i].onmouseenter=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">            move(showIndex,i);</div><div class="line">            optionLis[showIndex%optionLis.length].style.backgroundColor=<span class="string">'white'</span>;</div><div class="line">            optionLis[i%optionLis.length].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">            showIndex=i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">init(); <span class="comment">//调用初始化</span></div><div class="line"></div><div class="line"><span class="comment">//图片移动</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">showIndex,nextIndex</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        pictureLis[showIndex % pictureLis.length].style.opacity -= <span class="number">0.05</span>;</div><div class="line">        pictureLis[nextIndex % pictureLis.length].style.opacity =</div><div class="line">            +pictureLis[nextIndex % pictureLis.length].style.opacity + <span class="number">0.05</span>;</div><div class="line">        <span class="keyword">if</span> (pictureLis[showIndex % pictureLis.length].style.opacity &lt;= <span class="number">0</span>||pictureLis[nextIndex%pictureLis.length].style.opacity&gt;=<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">        setTimeout(step, <span class="number">5</span>)</div><div class="line">    &#125;, <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//自动播放</span></div><div class="line"><span class="keyword">var</span> autoPlayId;     <span class="comment">//自动播放定时器id</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">auto</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    autoPlayId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">autoStep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        optionLis[showIndex].style.backgroundColor = <span class="string">"white"</span>;</div><div class="line">        move(showIndex,showIndex+<span class="number">1</span>);    <span class="comment">//切换下一张图片</span></div><div class="line">        showIndex++;</div><div class="line">        <span class="keyword">if</span> (showIndex == pictureLis.length) showIndex = <span class="number">0</span>;</div><div class="line">        optionLis[showIndex%optionLis.length].style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">        autoPlayId = setTimeout(autoStep,<span class="number">2000</span>);</div><div class="line">    &#125;, <span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line">auto();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="轮播" scheme="https://callmejay.github.io/tags/%E8%BD%AE%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>实现圣杯布局和双飞翼布局</title>
    <link href="https://callmejay.github.io/2017/07/20/%E5%AE%9E%E7%8E%B0%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>https://callmejay.github.io/2017/07/20/实现圣杯布局和双飞翼布局/</id>
    <published>2017-07-20T14:54:48.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>利用浮动特性可以实现一些布局，比较经典的有个圣杯布局，后来经过改进又出现了双飞翼布局，下面就来介绍一下这两种布局。<br><a id="more"></a><br>先看一下效果图：<br><a href="http://oarri6xxm.bkt.clouddn.com/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html" target="_blank" rel="external">三栏式圣杯布局demo</a><br><img src="http://oonulpk6h.bkt.clouddn.com/shengbei.png" alt="圣杯布局"><br><a href="http://oarri6xxm.bkt.clouddn.com/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html" target="_blank" rel="external">三栏式双飞翼布局demo</a><br><img src="http://oonulpk6h.bkt.clouddn.com/shuangfeiyi.png" alt="双飞翼"><br>两种布局基本原理是相似的，而且双飞翼布局是圣杯布局的基础上改进而来，所以先介绍圣杯布局。</p>
<h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>1.总体上看上、中、下三个部分，一般写三组<code>&lt;div&gt;&lt;/div&gt;</code>标签，当然也可以采用<code>html5</code>的标签。<br>2.所谓布局都是在中间部分做文章，有几个要求：第一最中间部分宽度是不定的；第二：俩侧边栏宽度是定的<br>3.为达目的，我们肯定要采用浮动，但是有个诀窍：此处<code>html</code>结构中中间部分要先写，所以<code>html</code>结构是下面这样的<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>三栏式圣杯布局<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span>定宽左侧边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>定宽右侧栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.此时的问题是用<code>css</code>控制各块到各自位置上。简单的办法是使用负<code>margin</code>，这个负<code>margin</code>的原理是盒子模型的算法，想一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">内容+padding+border+margin</div></pre></td></tr></table></figure></p>
<p>这个公式里如果有一个负值，总和会怎么变，占据宽度空间会怎么变。当我们给一个<code>div</code>加上左负<code>margin</code>自然这个区块就向左位移了。思考一下就知道如果我们给俩边栏设置的都是<code>float:left</code>属性，则需要左侧边栏向左位移一整个父容器的宽度，右侧边栏则向左位移一个自身宽度。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.aside</span> &#123;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.extra</span> &#123;</div><div class="line">    <span class="attribute">float</span>:right;</div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;            </div><div class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">background-color</span>: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仔细看一下代码，会发现右边栏的处理和之前说的不一样，原因就不解释 了，其实只要合理设置<code>css</code>可以有不同方法达到目的。<br>5.现在就剩下最后一步，俩侧边栏虽已经和中间主题内容处于同一行，但是肯定不能遮挡要平移到对应位置上。直接给父元素加个<code>padding</code>，俩侧边栏使用一个相对定位移到<code>padding</code>区域就搞定了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</div><div class="line">    &#125;</div><div class="line"><span class="selector-class">.aside</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.extra</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">right</span>: -<span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，圣杯布局就完成了。</p>
<h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局和圣杯布局的区别只是换一种思路解决中间元素被遮挡问题，主要想法就是在外侧加一个<code>div</code>占据位置，俩侧边栏占据<code>margin</code>位置。所以直接看代码。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">            <span class="selector-class">.mid</span> &#123;</div><div class="line">                <span class="attribute">float</span>: left;</div><div class="line">                <span class="attribute">width</span>: <span class="number">100%</span>;    </div><div class="line">            &#125;</div><div class="line">            <span class="selector-class">.mid</span> <span class="selector-class">.mid-content</span> &#123;</div><div class="line">                <span class="attribute">min-height</span>: <span class="number">80px</span>;</div><div class="line">                <span class="attribute">min-width</span>: <span class="number">20px</span>;</div><div class="line">                <span class="attribute">background-color</span>: green;</div><div class="line">                <span class="attribute">margin-left</span>:<span class="number">200px</span>;</div><div class="line">                <span class="attribute">margin-right</span>:<span class="number">200px</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="selector-class">.aside</span> &#123;</div><div class="line">                <span class="attribute">float</span>: left;</div><div class="line">                <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">                <span class="attribute">min-height</span>: <span class="number">60px</span>;</div><div class="line">                <span class="attribute">background-color</span>: yellow;</div><div class="line">                <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</div><div class="line">            &#125;    </div><div class="line">            <span class="selector-class">.extra</span> &#123;</div><div class="line">                <span class="attribute">float</span>: left;</div><div class="line">                <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">                <span class="attribute">min-height</span>: <span class="number">60px</span>;</div><div class="line">                <span class="attribute">background-color</span>: blue;</div><div class="line">                <span class="attribute">margin-left</span>:-<span class="number">200px</span>; </div><div class="line">            &#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid-content"</span>&gt;</span>三栏式双飞翼布局中间自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span>侧边栏定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>右侧定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>以上就是圣杯布局和双飞翼布局。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;利用浮动特性可以实现一些布局，比较经典的有个圣杯布局，后来经过改进又出现了双飞翼布局，下面就来介绍一下这两种布局。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://callmejay.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>基于vue配置移动端rem布局</title>
    <link href="https://callmejay.github.io/2017/07/19/%E5%9F%BA%E4%BA%8Evue%E9%85%8D%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80/"/>
    <id>https://callmejay.github.io/2017/07/19/基于vue配置移动端rem布局/</id>
    <published>2017-07-19T14:18:29.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天来聊一聊基于<code>vue-cli</code>配置的移动端屏幕适配问题。</p>
</blockquote>
<p>配方还是一样：手淘的<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">lib-flexible</a> + <code>rem</code></p>
<h3 id="配置-flexible"><a href="#配置-flexible" class="headerlink" title="配置 flexible"></a>配置 flexible</h3><h4 id="安装-lib-flexible"><a href="#安装-lib-flexible" class="headerlink" title="安装 lib-flexible"></a>安装 lib-flexible</h4><p>在命令行中运行如下安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i lib-flexible --save</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="引入-lib-flexible"><a href="#引入-lib-flexible" class="headerlink" title="引入 lib-flexible"></a>引入 lib-flexible</h4><p>在项目入口文件 <code>main.js</code> 里 引入 <code>lib-flexible</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> <span class="string">'lib-flexible'</span></div></pre></td></tr></table></figure></p>
<h4 id="添加-meta-标签"><a href="#添加-meta-标签" class="headerlink" title="添加 meta 标签"></a>添加 meta 标签</h4><p>在项目根目录的 <code>index.html</code> 中添加如下 <code>meta</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="px-转-rem"><a href="#px-转-rem" class="headerlink" title="px 转 rem"></a>px 转 rem</h3><p>实际开发中，我们通过设计稿得到的值单位是 <code>px</code>，所以要将 <code>px</code> 转换成 <code>rem</code> 再写进样式中。<br>将 <code>px</code> 转换成 <code>rem</code> 我们将使用 <code>px2rem</code> 这个工具，它有 <code>webpack</code> 的 <code>loader</code>：<a href="https://github.com/Jinjiang/px2rem-loader" target="_blank" rel="external">px2rem-loader</a></p>
<h4 id="安装-px2rem-loader"><a href="#安装-px2rem-loader" class="headerlink" title="安装 px2rem-loader"></a>安装 px2rem-loader</h4><p>在命令行中运行如下安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i px2rem-loade --save-dev</div></pre></td></tr></table></figure></p>
<h4 id="配置-px2rem-loade"><a href="#配置-px2rem-loade" class="headerlink" title="配置 px2rem-loade"></a>配置 px2rem-loade</h4><p>在 <code>vue-cli</code> 生成的 <code>webpack</code> 配置中，<code>vue-loader</code> 的 <code>options</code> 和其他样式文件 <code>loader</code> 最终是都是由 <code>build/utils.js</code> 里的一个方法生成的。</p>
<p>我们只需在 <code>cssLoader</code> 后再加上一个 <code>px2remLoader</code> 即可，<code>px2rem-loader</code> 的 <code>remUnit</code> 选项意思是 <code>1rem</code>=多少像素，结合 <code>lib-flexible</code> 的方案，我们将 <code>px2remLoader</code> 的 <code>options.remUnit</code> 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 <code>750px</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils.js</span></div><div class="line"><span class="keyword">var</span> cssLoader = &#123;</div><div class="line">  <span class="attr">loader</span>: <span class="string">'css-loader'</span>,</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">minimize</span>: process.env.NODE_ENV === <span class="string">'production'</span>,</div><div class="line">    <span class="attr">sourceMap</span>: options.sourceMap</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> px2remLoader = &#123;</div><div class="line">  <span class="attr">loader</span>: <span class="string">'px2rem-loader'</span>,</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">remUnit</span>: <span class="number">75</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure></p>
<p>并放进 loaders 数组中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLoaders</span>(<span class="params">loader, loaderOptions</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> loaders = [cssLoader, px2remLoader]</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure></p>
<p>修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天来聊一聊基于&lt;code&gt;vue-cli&lt;/code&gt;配置的移动端屏幕适配问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配方还是一样：手淘的&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lib-flexible&lt;/a&gt; + &lt;code&gt;rem&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-flexible&quot;&gt;&lt;a href=&quot;#配置-flexible&quot; class=&quot;headerlink&quot; title=&quot;配置 flexible&quot;&gt;&lt;/a&gt;配置 flexible&lt;/h3&gt;&lt;h4 id=&quot;安装-lib-flexible&quot;&gt;&lt;a href=&quot;#安装-lib-flexible&quot; class=&quot;headerlink&quot; title=&quot;安装 lib-flexible&quot;&gt;&lt;/a&gt;安装 lib-flexible&lt;/h4&gt;&lt;p&gt;在命令行中运行如下安装：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm i lib-flexible --save&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="vue" scheme="https://callmejay.github.io/tags/vue/"/>
    
      <category term="rem" scheme="https://callmejay.github.io/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的10个重点及难点</title>
    <link href="https://callmejay.github.io/2017/07/15/JavaScript%E7%9A%8410%E4%B8%AA%E9%87%8D%E7%82%B9%E5%8F%8A%E9%9A%BE%E7%82%B9/"/>
    <id>https://callmejay.github.io/2017/07/15/JavaScript的10个重点及难点/</id>
    <published>2017-07-15T13:22:43.000Z</published>
    <updated>2018-02-10T09:29:37.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p><strong>立即执行函数</strong>，即<code>Immediately Invoked Function Expression (IIFE)</code>，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">// 代码</span></div><div class="line">     <span class="comment">// ...</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p><code>function(){…}</code>是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。<strong>立即执行函数</strong>也可以理解为立即调用一个匿名函数。<strong>立即执行函数</strong>最常见的应用场景就是：将<code>var</code>变量的作用域限制于你们函数内，这样可以避免命名冲突。<br><a id="more"></a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> N = <span class="number">0</span>; <span class="comment">// N是f1函数的局部变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123; <span class="comment">// f2是f1函数的内部函数，是闭包</span></div><div class="line">        N += <span class="number">1</span>; <span class="comment">// 内部函数f2中使用了外部函数f1中的变量N</span></div><div class="line">        <span class="built_in">console</span>.log(N);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = f1();</div><div class="line"></div><div class="line">result(); <span class="comment">// 输出1</span></div><div class="line">result(); <span class="comment">// 输出2</span></div><div class="line">result(); <span class="comment">// 输出3</span></div></pre></td></tr></table></figure></p>
<p>代码中，外部函数<code>f1</code>只执行了一次，变量<code>N</code>设为0，并将内部函数<code>f2</code>赋值给了变量<code>result</code>。由于外部函数<code>f1</code>已经执行完毕，其内部变量<code>N</code>应该在内存中被清除，然而事实并不是这样：我们每次调用<code>result</code>的时候，发现变量<code>N</code>一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>
<h3 id="使用闭包定义私有变量"><a href="#使用闭包定义私有变量" class="headerlink" title="使用闭包定义私有变量"></a>使用闭包定义私有变量</h3><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Product();</div><div class="line">p.setName(<span class="string">"Fundebug"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// 输出undefined</span></div><div class="line"><span class="built_in">console</span>.log(p.getName()); <span class="comment">// 输出Fundebug</span></div></pre></td></tr></table></figure></p>
<p>代码中，对象<code>p</code>的的<code>name</code>属性为私有属性，使用<code>p.name</code>不能直接访问。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个<code>JavaScript</code>构造函数都有一个<code>prototype</code>属性，用于设置所有实例对象需要共享的属性和方法。<code>prototype</code>属性不能列举。<code>JavaScript</code>仅支持通过<code>prototype</code>属性进行继承属性和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>._length = x;</div><div class="line">    <span class="keyword">this</span>._breadth = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getDimensions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">length</span>: <span class="keyword">this</span>._length,</div><div class="line">        <span class="attr">breadth</span>: <span class="keyword">this</span>._breadth</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x.getDimensions()); <span class="comment">// &#123; length: 3, breadth: 4 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(y.getDimensions()); <span class="comment">// &#123; length: 4, breadth: 3 &#125;</span></div></pre></td></tr></table></figure></p>
<p>代码中，<code>x</code>和<code>y</code>都是构造函数<code>Rectangle</code>创建的对象实例，它们通过<code>prototype</code>继承了<code>getDimensions</code>方法。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><code>JavaScript</code>并非模块化编程语言，至少<code>ES6</code>落地之前都不是。然而对于一个复杂的<code>Web</code>应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多<code>JS</code>库比如<code>jQuery</code>以及<code>Fundebug</code>都是这样实现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> N = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"The result is: "</span> + x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> x = a + N;</div><div class="line">        print(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">description</span>: <span class="string">"This is description"</span>,</div><div class="line">        <span class="attr">add</span>: add</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.description); <span class="comment">// 输出"this is description" </span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.add(<span class="number">5</span>); <span class="comment">// 输出“The result is: 10”</span></div></pre></td></tr></table></figure></p>
<p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，<code>module</code>为一个独立的模块，<code>N</code>为其私有属性，<code>print</code>为其私有方法，<code>decription</code>为其公有属性，<code>add</code>为其共有方法。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><code>JavaScript</code>会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(<code>Hoisting</code>)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>
<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// 输出undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> y = <span class="number">2</span>; <span class="comment">// 初始化y</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等价于下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> y;  <span class="comment">// 声明y</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// 输出undefined</span></div><div class="line"></div><div class="line">y = <span class="number">2</span>; <span class="comment">// 初始化y</span></div></pre></td></tr></table></figure></p>
<p>为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化，即<code>Currying</code>，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 输出2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> add1 = add(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>)); <span class="comment">// 输出2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> add10 = add(<span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(add10(<span class="number">1</span>)); <span class="comment">// 输出11</span></div></pre></td></tr></table></figure></p>
<p>代码中，我们可以一次性传入2个1作为参数<code>add(1)(1)</code>，也可以传入1个参数之后获取<code>add1</code>与<code>add10</code>函数，这样使用起来非常灵活。</p>
<h3 id="apply-call与bind方法"><a href="#apply-call与bind方法" class="headerlink" title="apply, call与bind方法"></a>apply, call与bind方法</h3><p><code>JavaScript</code>开发者有必要理解<code>apply</code>、<code>call</code>与<code>bind</code>方法的不同点。它们的共同点是第一个参数都是<code>this</code>，即函数运行时依赖的上下文。</p>
<p>三者之中，<code>call</code>方法是最简单的，它等价于指定<code>this</code>值调用函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Rahul Mhatre"</span>,</div><div class="line">    <span class="attr">whatIsYourName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.whatIsYourName(); <span class="comment">// 输出"Rahul Mhatre",</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> user2 = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Neha Sampat"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.whatIsYourName.call(user2); <span class="comment">// 输出"Neha Sampat"</span></div></pre></td></tr></table></figure></p>
<p><code>apply</code>方法与<code>call</code>方法类似。两者唯一的不同点在于，<code>apply</code>方法使用数组指定参数，而<code>call</code>方法每个参数单独需要指定：</p>
<ul>
<li>apply(thisArg, [argsArray])</li>
<li>call(thisArg, arg1, arg2, …)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">greet</span>: <span class="string">"Hello!"</span>,</div><div class="line">    <span class="attr">greetUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userName</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.greet + <span class="string">" "</span> + userName);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> greet1 = &#123;</div><div class="line">    <span class="attr">greet</span>: <span class="string">"Hola"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.greetUser.call(greet1, <span class="string">"Rahul"</span>); <span class="comment">// 输出"Hola Rahul"</span></div><div class="line">user.greetUser.apply(greet1, [<span class="string">"Rahul"</span>]); <span class="comment">// 输出"Hola Rahul"</span></div></pre></td></tr></table></figure>
<p>使用<code>bind</code>方法，可以为函数绑定<code>this</code>值，然后作为一个新的函数返回：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">     <span class="attr">greet</span>: <span class="string">"Hello!"</span>,</div><div class="line">     <span class="attr">greetUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userName</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.greet + <span class="string">" "</span> + userName);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> greetHola = user.greetUser.bind(&#123;<span class="attr">greet</span>: <span class="string">"Hola"</span>&#125;);</div><div class="line"><span class="keyword">var</span> greetBonjour = user.greetUser.bind(&#123;<span class="attr">greet</span>: <span class="string">"Bonjour"</span>&#125;);</div><div class="line"></div><div class="line">greetHola(<span class="string">"Rahul"</span>) <span class="comment">// 输出"Hola Rahul"</span></div><div class="line">greetBonjour(<span class="string">"Rahul"</span>) <span class="comment">// 输出"Bonjour Rahul"</span></div></pre></td></tr></table></figure></p>
<h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><p><code>Memoization</code>用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoizeFunction</span>(<span class="params">func</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span> (cache[key])&#123;</div><div class="line">            <span class="keyword">return</span> cache[key];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">var</span> val = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">            cache[key] = val;</div><div class="line">            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fibonacci = memoizeFunction(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) ? n : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000</span></div><div class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000</span></div></pre></td></tr></table></figure></p>
<p>代码中，第2次计算<code>fibonacci(100)</code>则只需要在内存中直接读取结果。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>所谓函数重载(<code>method overloading</code>)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过<code>if...else</code>或者<code>switch</code>实现，这就不去管它了。<code>jQuery</code>之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>
<p>从效果上来说，<code>people</code>对象的<code>find</code>方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据<code>firstName</code>查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>
<p>难点在于，<code>people.find</code>只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数<code>find0,find1</code>与<code>find2</code>啊！这里的关键在于<code>old</code>属性。</p>
<p>由<code>addMethod</code>函数的调用顺序可知，<code>people.find</code>最终绑定的是<code>find2</code>函数。然而，在绑定<code>find2</code>时，<code>old</code>为<code>find1</code>；同理，绑定<code>find1</code>时，<code>old</code>为<code>find0</code>。3个函数<code>find0</code>,<code>find1</code>与<code>find2</code>就这样通过闭包链接起来了。</p>
<p>根据<code>addMethod</code>的逻辑，当<code>f.length</code>与<code>arguments.length</code>不匹配时，就会去调用<code>old</code>，直到匹配为止。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params">object, name, f</span>)</span>&#123;　　</div><div class="line">    <span class="keyword">var</span> old = object[name];　　</div><div class="line">    object[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// f.length为函数定义时的参数个数</span></div><div class="line">        <span class="comment">// arguments.length为函数调用时的参数个数　　　　</span></div><div class="line">        <span class="keyword">if</span> (f.length === <span class="built_in">arguments</span>.length)&#123;　　</div><div class="line">            <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);　　　　</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">"function"</span>)&#123;</div><div class="line">            <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不传参数时，返回所有name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find0</span>(<span class="params"></span>)</span>&#123;　　</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.names;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传一个参数时，返回firstName匹配的name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find1</span>(<span class="params">firstName</span>)</span>&#123;　　</div><div class="line">    <span class="keyword">var</span> result = [];　　</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.names.length; i++)&#123;　　　　</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.names[i].indexOf(firstName) === <span class="number">0</span>)&#123;　　　　　　</div><div class="line">            result.push(<span class="keyword">this</span>.names[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传两个参数时，返回firstName和lastName都匹配的name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find2</span>(<span class="params">firstName, lastName</span>)</span>&#123;　</div><div class="line">    <span class="keyword">var</span> result = [];　　</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.names.length; i++)&#123;　　　　</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.names[i] === (firstName + <span class="string">" "</span> + lastName))&#123;　　　　　　</div><div class="line">            result.push(<span class="keyword">this</span>.names[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> people = &#123;　　</div><div class="line">    <span class="attr">names</span>: [<span class="string">"Dean Edwards"</span>, <span class="string">"Alex Russell"</span>, <span class="string">"Dean Tom"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">addMethod(people, <span class="string">"find"</span>, find0);</div><div class="line">addMethod(people, <span class="string">"find"</span>, find1);</div><div class="line">addMethod(people, <span class="string">"find"</span>, find2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(people.find()); <span class="comment">// 输出["Dean Edwards", "Alex Russell", "Dean Tom"]</span></div><div class="line"><span class="built_in">console</span>.log(people.find(<span class="string">"Dean"</span>)); <span class="comment">// 输出["Dean Edwards", "Dean Tom"]</span></div><div class="line"><span class="built_in">console</span>.log(people.find(<span class="string">"Dean"</span>, <span class="string">"Edwards"</span>)); <span class="comment">// 输出["Dean Edwards"]</span></div></pre></td></tr></table></figure></p>
<p><a href="http://www.jianshu.com/p/dc3f4b0bed52" target="_blank" rel="external">传送门~</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;立即执行函数&quot;&gt;&lt;a href=&quot;#立即执行函数&quot; class=&quot;headerlink&quot; title=&quot;立即执行函数&quot;&gt;&lt;/a&gt;立即执行函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;立即执行函数&lt;/strong&gt;，即&lt;code&gt;Immediately Invoked Function Expression (IIFE)&lt;/code&gt;，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;function(){…}&lt;/code&gt;是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。&lt;strong&gt;立即执行函数&lt;/strong&gt;也可以理解为立即调用一个匿名函数。&lt;strong&gt;立即执行函数&lt;/strong&gt;最常见的应用场景就是：将&lt;code&gt;var&lt;/code&gt;变量的作用域限制于你们函数内，这样可以避免命名冲突。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://callmejay.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题(JavaScript)</title>
    <link href="https://callmejay.github.io/2017/07/12/%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript/"/>
    <id>https://callmejay.github.io/2017/07/12/经典前端面试题-JavaScript/</id>
    <published>2017-07-12T13:01:02.000Z</published>
    <updated>2018-02-10T09:29:37.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉"><a href="#写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉" class="headerlink" title="写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉"></a>写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/(&lt;\w+&gt;)|(&lt;\/\w+&gt;)/gi</span>;</div><div class="line"><span class="keyword">var</span> str = <span class="string">'&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;'</span>;</div><div class="line">alert(str.replace(reg,<span class="string">""</span>));</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="编写一个函数-用于统计一个字符串中出现次数最多的字符和其出现的次数？"><a href="#编写一个函数-用于统计一个字符串中出现次数最多的字符和其出现的次数？" class="headerlink" title="编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？"></a>编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'asdfssaaasasasasaa'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxAppearChar</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> maxKey = <span class="string">''</span>; </div><div class="line">    <span class="keyword">var</span> maxIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</div><div class="line">        <span class="keyword">if</span>( obj[ arr[i] ] )&#123;</div><div class="line">            obj[ arr[i] ] += <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            obj[ arr[i] ] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( key <span class="keyword">in</span> obj ) &#123;</div><div class="line">        <span class="keyword">if</span>(obj[key] &gt; maxIndex) &#123;</div><div class="line">            maxKey = key;</div><div class="line">            maxIndex = obj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="string">'出现最多字符是'</span> + maxKey + <span class="string">',一共出现了'</span> + maxIndex + <span class="string">"次"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="闭包是什么-有什么特性-对页面有什么影响"><a href="#闭包是什么-有什么特性-对页面有什么影响" class="headerlink" title="闭包是什么? 有什么特性? 对页面有什么影响?"></a>闭包是什么? 有什么特性? 对页面有什么影响?</h4><p>(1)闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.<br>(2)闭包有什么特性:<br>通过闭包,可以提供私有作用域.<br>函数执行完后,内部不会释放<br>通过闭包,可以实现带有存储函数运行时变量的函数.<br>(3)对页面有什么影响:大量使用闭包会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<h4 id="写一个reverseStr函数来实现字符串反转，如将-‘12345678’-变成-‘87654321’"><a href="#写一个reverseStr函数来实现字符串反转，如将-‘12345678’-变成-‘87654321’" class="headerlink" title="写一个reverseStr函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’"></a>写一个reverseStr函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'12345678'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseStr</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="将数字-12345678-转化成-RMB形式-如：-12-345-678"><a href="#将数字-12345678-转化成-RMB形式-如：-12-345-678" class="headerlink" title="将数字 12345678 转化成 RMB形式 如： 12,345,678"></a>将数字 12345678 转化成 RMB形式 如： 12,345,678</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNumberToRMB</span> (<span class="params"> number </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = number + <span class="string">''</span>;</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">''</span>).reverse(); <span class="comment">//[8,7,6,5,4,3,2,1]</span></div><div class="line">    <span class="keyword">var</span> resultArr = [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</div><div class="line">        resultArr.push( arr[i] );</div><div class="line">        <span class="keyword">if</span>( (i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) != arr.length )&#123;</div><div class="line">            resultArr.push(<span class="string">','</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resultArr.reverse().join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="请写一个阻止冒泡的兼容函数"><a href="#请写一个阻止冒泡的兼容函数" class="headerlink" title="请写一个阻止冒泡的兼容函数"></a>请写一个阻止冒泡的兼容函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span> (<span class="params"> e </span>) </span>&#123;</div><div class="line">    e = <span class="built_in">window</span>.event ? <span class="built_in">window</span>.event : e;</div><div class="line">    <span class="keyword">if</span>( e.stopPropagation ) &#123;</div><div class="line">        e.stopPropagation();</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        e.cancelBubble = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用js实现随机选取10–100之间的10个数字，存入一个数组，并排序"><a href="#用js实现随机选取10–100之间的10个数字，存入一个数组，并排序" class="headerlink" title="用js实现随机选取10–100之间的10个数字，存入一个数组，并排序"></a>用js实现随机选取10–100之间的10个数字，存入一个数组，并排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSortedRandomNumber</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</div><div class="line">        arr.push( <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">90</span> ) + <span class="number">10</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"> a, b </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a - b;</div><div class="line">    &#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-“a”-”1”-”b”-”2”-”c”-””-”d”-”xxx”-”e”-”undefined”"><a href="#有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-“a”-”1”-”b”-”2”-”c”-””-”d”-”xxx”-”e”-”undefined”" class="headerlink" title="有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}"></a>有这样一个URL：<code>http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</code>，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryJson</span> (<span class="params"> URLstr </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> queryIndex = URLstr.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> queryStr = URLstr.slice( queryIndex ); <span class="comment">//a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</span></div><div class="line">    <span class="keyword">var</span> arr = queryStr.split( <span class="string">'&amp;'</span> ); <span class="comment">//[ a=1, b=2, c=, d=xxx, e ]</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> resultArr =  [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</div><div class="line">        <span class="keyword">var</span> tempArr = arr[ i ].split( <span class="string">'='</span> );</div><div class="line">        obj[ tempArr[<span class="number">0</span>] ] = tempArr[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</div><div class="line">        resultArr.push( <span class="string">'"'</span> + key + <span class="string">'"'</span> + <span class="string">':'</span>  + <span class="string">'"'</span> + obj[ key ] + <span class="string">'"'</span>   ); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'&#123;'</span> + resultArr.join(<span class="string">','</span>) + <span class="string">'&#125;'</span>; <span class="comment">//&#123;"a":"1","b":"2","c":"","d":"xxx","e":"undefined"&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="写一个function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#写一个function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="写一个function，清除字符串前后的空格。（兼容所有浏览器）"></a>写一个function，清除字符串前后的空格。（兼容所有浏览器）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.trim !== <span class="string">'function'</span> ) &#123;</div><div class="line">    <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.replace ( <span class="regexp">/^\s*|\s*$/g</span>, <span class="string">''</span> );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取页面所有的checkbox"><a href="#获取页面所有的checkbox" class="headerlink" title="获取页面所有的checkbox"></a>获取页面所有的checkbox</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resultArr= [];</div><div class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelectorAll(<span class="string">'input'</span>);</div><div class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; input.length; i++ ) &#123;</div><div class="line">    <span class="keyword">if</span>( input[i].type == <span class="string">'checkbox'</span> ) &#123;</div><div class="line">        resultArr.push( input[i] );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//resultArr即中获取到了页面中的所有checkbox</span></div></pre></td></tr></table></figure>
<h4 id="已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”"><a href="#已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”" class="headerlink" title="已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”"></a>已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCamelCase</span> (<span class="params"> str </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">"-"</span>);</div><div class="line">    <span class="keyword">var</span> resultArr = [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ )&#123;</div><div class="line">        <span class="keyword">if</span>( i === <span class="number">0</span> ) &#123;</div><div class="line">            resultArr.push( arr[i] ); </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            resultArr.push( arr[i].charAt( <span class="number">0</span> ).toUpperCase() + arr[i].slice( <span class="number">1</span> ) );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resultArr.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&quot;&gt;&lt;a href=&quot;#写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&quot; class=&quot;headerlink&quot; title=&quot;写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&quot;&gt;&lt;/a&gt;写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reg = &lt;span class=&quot;regexp&quot;&gt;/(&amp;lt;\w+&amp;gt;)|(&amp;lt;\/\w+&amp;gt;)/gi&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;div&amp;gt;这里是div&amp;lt;p&amp;gt;里面的段落&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(str.replace(reg,&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="面试题" scheme="https://callmejay.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
