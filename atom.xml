<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay&#39;s Blog</title>
  <subtitle>知其然，知其所以然。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://callmejay.github.io/"/>
  <updated>2018-09-10T07:44:58.088Z</updated>
  <id>https://callmejay.github.io/</id>
  
  <author>
    <name>Jay Bein</name>
    <email>291977464@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编写更优雅的JavaScript代码</title>
    <link href="https://callmejay.github.io/2018/09/10/%E7%BC%96%E5%86%99%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81/"/>
    <id>https://callmejay.github.io/2018/09/10/编写更优雅的JavaScript代码/</id>
    <published>2018-09-10T05:46:33.000Z</published>
    <updated>2018-09-10T07:44:58.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码技巧"><a href="#代码技巧" class="headerlink" title="代码技巧"></a>代码技巧</h3><h4 id="优先-ES6-新特性写法"><a href="#优先-ES6-新特性写法" class="headerlink" title="优先 ES6 新特性写法"></a>优先 ES6 新特性写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> formatArray = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组合并</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...arr1, ...arr2, <span class="string">'value'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">'bao'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见对象属性取值前判断对象是否存在</span></span><br><span class="line"><span class="comment">// 如下是 react + antd 渲染 table 的简单代码，对象存在性判断 + 默认值设置</span></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; downloadList &#125; = <span class="keyword">this</span>.props.store.downloadList</span><br><span class="line">  <span class="keyword">let</span> items = downloadList &amp;&amp; downloadList.items || []</span><br><span class="line">  <span class="keyword">let</span> itemCount = downloadList &amp;&amp; downloadList.itemCount || <span class="number">10</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &lt;Table dataSource=&#123;items&#125; pagination=&#123;&#123;total: itemCount&#125;&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line">// 优化后</span><br><span class="line">render()&#123;</span><br><span class="line">  const &#123; items, itemCount &#125; = this.props.manageStore.downloadList || &#123;&#125;</span><br><span class="line">  return &lt;Table dataSource=&#123;items || []&#125; pagination=&#123;&#123;total: itemCount || 10&#125;&#125;/&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="优化逻辑判断语句"><a href="#优化逻辑判断语句" class="headerlink" title="优化逻辑判断语句"></a>优化逻辑判断语句</h4><p>大量的 if else 逻辑判断难以维护，且性能较差，可用多种方式代替</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象配置法</span></span><br><span class="line"><span class="comment">// 函数内部有条件判断，且 return 值时，满足条件立即return，而不要在结尾return</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v === <span class="string">'name'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bao'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v === <span class="string">'age'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'18'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v === <span class="string">'height'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'180'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cfg = &#123;</span><br><span class="line">  name: <span class="string">'bao'</span>,</span><br><span class="line">  age: <span class="string">'18'</span>,</span><br><span class="line">  height: <span class="string">'180'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">v</span> =&gt;</span> cfg[v]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组配置法</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="string">'hello'</span> || value === <span class="string">'world'</span> || value === <span class="string">'blabla'</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置数组形式</span></span><br><span class="line"><span class="keyword">const</span> rightValue = [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'blabla'</span>]</span><br><span class="line"><span class="keyword">if</span> (rightValue.includes[value]) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="善用-amp-amp-、-和-三元运算"><a href="#善用-amp-amp-、-和-三元运算" class="headerlink" title="善用 &amp;&amp; 、 || 和 三元运算"></a>善用 &amp;&amp; 、 || 和 三元运算</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name === <span class="string">'bao'</span>) &#123;</span><br><span class="line">  someFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name === <span class="string">'bao'</span> &amp;&amp; someFunc()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'bao'</span>) &#123;</span><br><span class="line">  someFunc()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  elseFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name === <span class="string">'bao'</span> ? someFunc() : elseFunc()</span><br></pre></td></tr></table></figure>
<h4 id="对象属性变量应用"><a href="#对象属性变量应用" class="headerlink" title="对象属性变量应用"></a>对象属性变量应用</h4><p>如在 react 中，调用 action 方法来获取数据，不同条件执行不同方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isMember) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> actions.getMemberInfo(params)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> actions.getCommonUserInfo(params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actionName = isMember ? <span class="string">'getMemberInfo'</span> : <span class="string">'getCommonUserInfo'</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> actions[actionName](params)</span><br></pre></td></tr></table></figure>
<h4 id="用-Array-map-Array-filter-代替数组-for-循环实现简易写法"><a href="#用-Array-map-Array-filter-代替数组-for-循环实现简易写法" class="headerlink" title="用 Array.map(), Array.filter() 代替数组 for 循环实现简易写法"></a>用 Array.map(), Array.filter() 代替数组 for 循环实现简易写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">'A'</span>, <span class="string">'B'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 取出 arr 中数字项为新数组</span></span><br><span class="line"><span class="keyword">let</span> numArr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> arr[i] === <span class="string">'number'</span>)&#123;</span><br><span class="line">    numArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改用filter</span></span><br><span class="line"><span class="keyword">let</span> numArr2 = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">'number'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numArr2) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获得新数组，元素是 arr 每个元素作为 value, key 为 arr 下标的对象, 不修改 arr</span></span><br><span class="line"><span class="keyword">let</span> strArr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  strArr.push(&#123;[i]: arr[i]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改用 map</span></span><br><span class="line"><span class="keyword">let</span> strArr2 = arr.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> (&#123;[i]: arr[i]&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(strArr2) <span class="comment">// [ &#123; '0': 1 &#125;,&#123; '1': 2 &#125;,&#123; '2': 3 &#125;, &#123; '3': 4 &#125;, &#123; '4': 'A' &#125;, &#123; '5': 'B' &#125; ]</span></span><br></pre></td></tr></table></figure>
<h4 id="浅拷贝、深拷贝-复杂数据类型对象深拷贝建议使用库来实现，如-lodash-cloneDeep"><a href="#浅拷贝、深拷贝-复杂数据类型对象深拷贝建议使用库来实现，如-lodash-cloneDeep" class="headerlink" title="浅拷贝、深拷贝 复杂数据类型对象深拷贝建议使用库来实现，如 lodash.cloneDeep"></a>浅拷贝、深拷贝 复杂数据类型对象深拷贝建议使用库来实现，如 <a href="http://lodash.think2011.net/cloneDeep" target="_blank" rel="noopener">lodash.cloneDeep</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">11</span>, <span class="attr">b</span>: &#123; <span class="attr">ba</span>: <span class="number">22</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.b === obj1.b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝，这种方法需要对象能够被 json 序列化</span></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1))</span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">//  ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3===obj1); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.b===obj1.b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="更高效的代码"><a href="#更高效的代码" class="headerlink" title="更高效的代码"></a>更高效的代码</h3><h4 id="使用局部变量代替引用类型查找"><a href="#使用局部变量代替引用类型查找" class="headerlink" title="使用局部变量代替引用类型查找"></a>使用局部变量代替引用类型查找</h4><p>局部变量的读取速度最快，而引用类型的数据读取需要按引用指针去查找，所以可以对多次使用的引用类型属性 使用局部变量读取一次，重复使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  person: &#123;</span><br><span class="line">    man: &#123;</span><br><span class="line">      bao: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = obj.person.man.bao.age</span><br><span class="line"><span class="comment">// use age do many things</span></span><br></pre></td></tr></table></figure>
<h4 id="删除多个对象属性时先使属性为-null"><a href="#删除多个对象属性时先使属性为-null" class="headerlink" title="删除多个对象属性时先使属性为 null"></a>删除多个对象属性时先使属性为 null</h4><p>删除属性时，js 引擎会去查找该属性的值是否是其他对象的引用，所以删除前提前赋值为 null，可以减少 js 引擎的检测过程，提高效率</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  person: &#123;</span><br><span class="line">    man: &#123;</span><br><span class="line">      bao: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.person = <span class="literal">null</span></span><br><span class="line"><span class="keyword">delete</span> obj.person</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代码技巧&quot;&gt;&lt;a href=&quot;#代码技巧&quot; class=&quot;headerlink&quot; title=&quot;代码技巧&quot;&gt;&lt;/a&gt;代码技巧&lt;/h3&gt;&lt;h4 id=&quot;优先-ES6-新特性写法&quot;&gt;&lt;a href=&quot;#优先-ES6-新特性写法&quot; class=&quot;headerlink&quot; title=&quot;优先 ES6 新特性写法&quot;&gt;&lt;/a&gt;优先 ES6 新特性写法&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 箭头函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组去重&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; formatArray = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt; =&amp;gt;&lt;/span&gt; [...new &lt;span class=&quot;built_in&quot;&gt;Set&lt;/span&gt;(arr)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; newArr = [...arr1, ...arr2, &lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对象浅拷贝&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; newObj = &amp;#123;...obj&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 解构赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; person = &amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;bao&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; name, age &amp;#125; = person&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 常见对象属性取值前判断对象是否存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如下是 react + antd 渲染 table 的简单代码，对象存在性判断 + 默认值设置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; downloadList &amp;#125; = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.store.downloadList&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; items = downloadList &amp;amp;&amp;amp; downloadList.items || []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; itemCount = downloadList &amp;amp;&amp;amp; downloadList.itemCount || &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;lt;Table dataSource=&amp;#123;items&amp;#125; pagination=&amp;#123;&amp;#123;total: itemCount&amp;#125;&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 优化后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const &amp;#123; items, itemCount &amp;#125; = this.props.manageStore.downloadList || &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &amp;lt;Table dataSource=&amp;#123;items || []&amp;#125; pagination=&amp;#123;&amp;#123;total: itemCount || 10&amp;#125;&amp;#125;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3之animation</title>
    <link href="https://callmejay.github.io/2018/08/17/CSS3%E4%B9%8Banimation/"/>
    <id>https://callmejay.github.io/2018/08/17/CSS3之animation/</id>
    <published>2018-08-17T08:43:59.000Z</published>
    <updated>2018-08-17T11:01:47.486Z</updated>
    
    <content type="html"><![CDATA[<p>首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> <span class="number">1s</span> rainbow linear <span class="number">3</span> forwards normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>用keyframes关键字，定义rainbow效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的animation属性是简写，可以拆分成多个单独的属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  animation-name: rainbow;  // 效果名称</span><br><span class="line">  animation-duration: 1s; // 执行一次所需是时间</span><br><span class="line">  animation-timing-function: linear; // 动画的速度曲线, linear是匀速，还有ease, ease-in加速,ease-out减速，cubic-bezier(http://cubic-bezier.com) 自定义速度模式等</span><br><span class="line">  animation-delay: 1s; // 延时多久执行动画</span><br><span class="line">  animation-fill-mode:forwards; // 动画保持在结束状态, forwards是停在结束时，backwards 是停在开始时，none 回到动画没开始状态</span><br><span class="line">  animation-direction: normal; // 动画播放的方向, 有alternate（start-end -&gt; end-start -&gt; start-end）、reverse(end-start -&gt; end-start)</span><br><span class="line">  animation-iteration-count: 3; // 动画执行次数 还有infinite</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: rainbow <span class="number">1s</span> linear infinite;</span><br><span class="line">  animation-play-state: paused; // 没有鼠标没有悬停时，动画状态是暂停；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  animation-play-state: running; // 一旦悬停，动画状态改为继续播放。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个栗子：实现动画的播放，暂停和重新开始<br><img src="http://oonulpk6h.bkt.clouddn.com/animation.gif" alt="效果图"></p>
<p>html部分</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"control"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"play"</span> <span class="attr">value</span>=<span class="string">"播放"</span>&gt;</span>播放<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"pause"</span> <span class="attr">value</span>=<span class="string">"暂停"</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"restart"</span> <span class="attr">value</span>=<span class="string">"重新开始"</span>&gt;</span>重新开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">400</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes mymove1 &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">400</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  margin: <span class="number">50</span>px <span class="number">0</span>;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: #5578a2;</span><br><span class="line">&#125;</span><br><span class="line">.play &#123;</span><br><span class="line">  animation: mymove <span class="number">5</span>s infinite ease;</span><br><span class="line">&#125;</span><br><span class="line">.restart &#123;</span><br><span class="line">  animation: mymove1 <span class="number">5</span>s infinite ease;</span><br><span class="line">&#125;</span><br><span class="line">.pause &#123;</span><br><span class="line">  animation-play-state: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>js部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> play = <span class="built_in">document</span>.getElementById(<span class="string">'play'</span>),</span><br><span class="line">    pause = <span class="built_in">document</span>.getElementById(<span class="string">'pause'</span>),</span><br><span class="line">    restart = <span class="built_in">document</span>.getElementById(<span class="string">'restart'</span>),</span><br><span class="line">    text = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>),</span><br><span class="line">    box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="comment">// 暂停</span></span><br><span class="line">pause.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (box.classList.contains(<span class="string">'play'</span>)) &#123;</span><br><span class="line">    box.className = <span class="string">'pause play box'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    box.className = <span class="string">'pause restart box'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text.innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 播放</span></span><br><span class="line">play.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (box.classList.contains(<span class="string">'play'</span>)) &#123;</span><br><span class="line">    box.className = <span class="string">'play box'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    box.className = <span class="string">'restart box'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text.innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 重新开始</span></span><br><span class="line">restart.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (box.classList.contains(<span class="string">'play'</span>)) &#123;</span><br><span class="line">    box.className = <span class="string">'restart box'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    box.className = <span class="string">'play box'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text.innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考资料<br><a href="https://aotu.io/notes/2016/11/28/css3-animation-properties/index.html" target="_blank" rel="noopener">CSS3 animation 属性妙用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:hover&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;animation&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1s&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1s&lt;/span&gt; rainbow linear &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; forwards normal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://callmejay.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记（强制类型转换）</title>
    <link href="https://callmejay.github.io/2018/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/07/29/学习笔记（强制类型转换）/</id>
    <published>2018-07-29T09:19:43.000Z</published>
    <updated>2018-07-29T09:41:06.038Z</updated>
    
    <content type="html"><![CDATA[<p>这里先插入下几个重要的点，先看先知：<br><strong>1.转Boolean</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在条件判断时，除了 <span class="literal">undefined</span>， <span class="literal">null</span>， <span class="literal">false</span>， <span class="literal">NaN</span>， <span class="string">''</span>， <span class="number">0</span>， <span class="number">-0</span>，其他所有值都转为 <span class="literal">true</span>，包括所有对象。</span><br></pre></td></tr></table></figure>
<p><strong>2.对象转基本类型</strong><br>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。</p>
<p><strong>3.四则运算符</strong><br>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。<br>其他运算只要其中一方是数字，那么另一方就转为数字。<br>加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"><span class="number">2</span> * <span class="string">'2'</span> <span class="comment">// 4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] + [<span class="number">2</span>, <span class="number">1</span>] <span class="comment">// '1,22,1'</span></span><br><span class="line"><span class="comment">// [1, 2].toString() -&gt; '1,2'</span></span><br><span class="line"><span class="comment">// [2, 1].toString() -&gt; '2,1'</span></span><br><span class="line"><span class="comment">// '1,2' + '2,1' = '1,22,1'</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h3><p>将值从一种类型转换成另一种类型称为类型转换（type casting）,这是显式的情况；隐式的转换称为强制类型转换（coercion）。</p>
<p>区分: 类型转换发生在静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时（runtime）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">''</span>; <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">String</span>(a); <span class="comment">// 显示转换</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里先插入下几个重要的点，先看先知：&lt;br&gt;&lt;strong&gt;1.转Boolean&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在条件判断时，除了 &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;， &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;， &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;， &lt;span class=&quot;literal&quot;&gt;NaN&lt;/span&gt;， &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;， &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;， &lt;span class=&quot;number&quot;&gt;-0&lt;/span&gt;，其他所有值都转为 &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;，包括所有对象。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2.对象转基本类型&lt;/strong&gt;&lt;br&gt;对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.四则运算符&lt;/strong&gt;&lt;br&gt;只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。&lt;br&gt;其他运算只要其中一方是数字，那么另一方就转为数字。&lt;br&gt;加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// &#39;11&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] + [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;// &#39;1,22,1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [1, 2].toString() -&amp;gt; &#39;1,2&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [2, 1].toString() -&amp;gt; &#39;2,1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &#39;1,2&#39; + &#39;2,1&#39; = &#39;1,22,1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="https://callmejay.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记（原生函数）</title>
    <link href="https://callmejay.github.io/2018/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/07/29/学习笔记（原生函数）/</id>
    <published>2018-07-29T01:26:00.000Z</published>
    <updated>2018-07-29T09:04:57.042Z</updated>
    
    <content type="html"><![CDATA[<p>原生函数（native function）,也是JavaScript的内建函数（built-in function）.<br>常见的原生函数有：</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Array()</li>
<li>Object()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Date()</li>
<li>Error()</li>
<li>Symbol()</li>
</ul>
<a id="more"></a>
<p>原生函数可以被当做构造函数来使用，但是构造出来的对象和我们设想的不太一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// 'object' 不是 ‘string’</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.Prototype.toString.call(a) <span class="comment">// '[object String]'</span></span><br></pre></td></tr></table></figure>
<p><strong>通过构造函数(如 <code>new String(&#39;abc&#39;)</code>)创造出来的是封装了基本类型值（如‘abc’）的封装对象。</strong></p>
<p>可以通过<code>console.log(a)</code>来查看封装对象。</p>
<p>需要注意的是，<code>new String(&#39;abc&#39;)</code>创造出来的是字符串’abc’的封装对象，而不是基本类型值’abc’。</p>
<h3 id="内部属性-class"><a href="#内部属性-class" class="headerlink" title="内部属性[[class]]"></a>内部属性[[class]]</h3><p>所有typeof返回值为“object”的对象都包含一个内部属性[[class]],这个属性无法访问，只能通过<code>Object.prototype.toString()</code>来查看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toSting([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>
<p>数组的内部[[class]]属性值是“Array”。对象的内部[[class]]属性和创建该对象的内建函数相对应。但是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="literal">null</span>) <span class="comment">// '[object Null]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="literal">undefined</span>) <span class="comment">// '[object Undefined]'</span></span><br></pre></td></tr></table></figure>
<p>虽然是’null’和’undefined’这样的原生函数并不存在，但是内部[[class]]的属性值仍然是‘Null’和‘Undefined’</p>
<p>其他的基本类型值（如字符串，布尔，数字）的情况有所不同，通常称为‘包装’（boxing）;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="string">'123'</span>) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="number">123</span>) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="literal">false</span>) <span class="comment">// [object Boolean]</span></span><br></pre></td></tr></table></figure>
<p>上面的基本类型值被各自的封装对象包装，所以他们的内部[[class]]属性值“String”,“Number”,“Boolean”。</p>
<h3 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h3><p>封装对象（object wrapper）扮演者重要的角色。我们都知道基本类型没有.length和.toString()这样的属性和方法，那他们是如何做到的呢？没错！就是通过封装对象访问的。此时JavaScript会自动为 基本类型值 包装（box或者wrap）一个封装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line">a.length <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase() <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure>
<p>这时候我们会想：如果我们要经常使用属性和方法。为甚不一开始就创建封装对象，这样JavaScript引擎就不用每次都自动创建了。But~~实际上 <strong>浏览器已经做了性能优化，直接使用封装对象反而会降低执行效率</strong>。所以我们不需要直接使用封装对象，让JS引擎自己去决定什么时候使用封装对象。</p>
<h3 id="封装对象释疑"><a href="#封装对象释疑" class="headerlink" title="封装对象释疑"></a>封装对象释疑</h3><p>比如Boolean</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Oops'</span>); <span class="comment">// 实际上不会执行到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为false创建了一个封装对象，然而该对象总是返回真值（truthy）。</p>
<p>✔️如果想要自行封装基本类型值，可以使用<code>Object(..)</code>函数（不带new关键字）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(a);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> b  <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> c  <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(b); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure>
<p>再次强调，<strong>我们一般不推荐使用封装对象。</strong></p>
<h3 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h3><p>✔️如果想得到封装对象中的基本类型值，可以使用<code>valueOf()</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">22</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">a.valueOf();<span class="comment">// 'abc'</span></span><br><span class="line">b.valueOf();<span class="comment">// 22</span></span><br><span class="line">c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在需要用到封装对象中的基本类型值得地方会发生隐式拆封。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a;<span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure>
<h3 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h3><p>关于数组（array），对象（object），函数（function）和正则表达式，实际上，使用常量和使用构造函数效果是一样的。（创建的值都是通过封装对象来包装）。</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array(..)"></a>Array(..)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数Array(..)不要求必须带 new 关键字，不带时，它会被自动补上</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">a; <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">b; <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>Array构造函数只带一个参数时，会被作为数组的预设长度(length),创造出来的只是一个空数组。</p>
<blockquote>
<p>我们将包含至少一个“空单元”的数组称为“稀疏数组”.</p>
</blockquote>
<h4 id="Date-和Error"><a href="#Date-和Error" class="headerlink" title="Date(..)和Error(..)"></a>Date(..)和Error(..)</h4><p>创建日期对象必须使用 new Date()。 Date(..)主要是用来获取当前的Unix时间戳（从1970年1月1日开始计算。以秒为单位）。</p>
<p>构造函数Error(..)带不带new关键字都可以。<br>创建错误对象（error object）主要是为了获得当前运行栈的上下文。栈的上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。</p>
<p>错误对象通常与throw一起使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x was not be provided'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误对象至少包含一个message属性。最好的办法是调用toSting()来获得经过格式化的便于阅读的错误信息。</p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol()"></a>Symbol()</h4><p>ES6中新加入了一个基本数据类型–符号（Symbol）。符号是具有唯一性的特殊值（并非绝对）。用它来命名对象属性不容易导致重名。</p>
<p>符号可以用作属性名，但是无论是在代码还是控制台上都无法查看和访问它的值，只会显示为诸如<code>Symbol(Symbol.create)</code>这样的值。</p>
<p>ES6中有一些预定义符号，以Symbol的静态属性形式出现， 如Symbol.create,Symbol.iterator等。可以这样用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*..*/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>✔️我们可以使用Symbol(..)原生构造函数来自定义符号。但它比较特殊，不能带new关键字，否则会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysym = <span class="built_in">Symbol</span>(<span class="string">'my own symbol'</span>);</span><br><span class="line">mysym; <span class="comment">// Symbol(my own symbol)</span></span><br><span class="line">mysym.toString(); <span class="comment">// "Symbol(my own symbol)"</span></span><br><span class="line"><span class="keyword">typeof</span> mysym; <span class="comment">// 'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mysym] = <span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwmPropertySymbols(a); <span class="comment">// [Symbol(my own symbol)]</span></span><br></pre></td></tr></table></figure>
<p>虽然符号实际上并非私有属性（通过<code>Object.getOwmPropertySymbols(..)</code>便可以公开获得对象中的所有符号），但是它却主要用于私有或者特殊属性。很多人稀罕用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生函数（native function）,也是JavaScript的内建函数（built-in function）.&lt;br&gt;常见的原生函数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;Array()&lt;/li&gt;
&lt;li&gt;Object()&lt;/li&gt;
&lt;li&gt;Function()&lt;/li&gt;
&lt;li&gt;RegExp()&lt;/li&gt;
&lt;li&gt;Date()&lt;/li&gt;
&lt;li&gt;Error()&lt;/li&gt;
&lt;li&gt;Symbol()&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="https://callmejay.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面试知识点总结（1）</title>
    <link href="https://callmejay.github.io/2018/07/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%881%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/07/20/面试知识点总结（1）/</id>
    <published>2018-07-20T06:22:45.000Z</published>
    <updated>2018-09-05T07:49:22.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>
<p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。因为防抖动的轮子很多，这里也不重新自己造个轮子了，直接使用大神分析的 underscore 的源码来解释防抖动。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setUseAction = debounce(getUserAction, <span class="number">10000</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">container.onmousemove = setUseAction;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setUseAction.cancel();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">debounced解析</a></p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流的原理很简单：</p>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h4 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="number">0</span>, context, args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行条件</span></span><br><span class="line">        <span class="keyword">if</span>(now - time &gt; wait)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            time = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer, context, args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = argumens;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context,args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较两个方法：</p>
<ul>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ul>
<p>有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！</p>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="comment">//下次触发 func 剩余的时间</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果没有剩余的时间了或者你改了系统时间</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我有时也希望无头有尾，或者有头无尾，这个咋办？</p>
<p>那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p>
<p>leading：false 表示禁用第一次执行<br>trailing: false 表示禁用停止触发的回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">throttle解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。&lt;/p&gt;
&lt;p&gt;这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。因为防抖动的轮子很多，这里也不重新自己造个轮子了，直接使用大神分析的 underscore 的源码来解释防抖动。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://callmejay.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://callmejay.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript立即执行函数(IIFE)与闭包</title>
    <link href="https://callmejay.github.io/2018/06/22/JavaScript%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-IIFE-%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>https://callmejay.github.io/2018/06/22/JavaScript立即执行函数-IIFE-与闭包/</id>
    <published>2018-06-22T10:08:02.000Z</published>
    <updated>2018-07-20T06:16:14.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直没搞清楚立即执行函数和闭包之间的关系，总结一下：</p>
<ol>
<li>闭包有很多种理解：访问不到内部作用域，函数就是这样，所以函数就是闭包；</li>
<li>闭包还有一种理解：通过把函数内部的变量和方法返回出来，这样外部作用域就可以访问内部作用域了，并且</li>
<li>立即执行函数和闭包之间没有必然的联系，虽然它们经常结合一起使用；</li>
<li>立即执行函数只是一种函数的调用方式；</li>
<li>闭包的目的则是外部函数可以访问内部函数的作用域；</li>
</ol>
<a id="more"></a>
<h3 id="立即执行函数（IIFE）"><a href="#立即执行函数（IIFE）" class="headerlink" title="立即执行函数（IIFE）"></a>立即执行函数（IIFE）</h3><p>立即执行函数、立即执行表达式、IIFE（immediately invoked function expression）、自执行函数，叫法不同，都是一样的；</p>
<p>立即执行函数是指声明完之后便直接执行的函数，这类函数通常是一次性使用的，因此没必要给这类函数命名，直接让它执行就好了；</p>
<p>主要目的是做的一些封装，防止变量全局污染，以及保证内部变量的安全；</p>
<p>javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用IIFE可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p>
<p>JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。</p>
<p>定义一个函数，函数后面加上括号，即可完成调用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;();   <span class="comment">// SyntaxError: Unexpected token (</span></span><br><span class="line">    <span class="comment">//引擎在遇到关键字function时，会默认将其当做是一个函数声明，函数声明必须有一个函数名，所以在执行到第一个左括号时就报语法错误了；</span></span><br><span class="line">    <span class="comment">//函数表达式的函数名则可有可无；</span></span><br><span class="line">    <span class="comment">//在function前面加！、+、 -、=甚至是逗号等或者把函数用（）包起来都可以将函数声明转换成函数表达式；我们一般用（）把函数声明包起来或者用 = </span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>引擎在遇到关键字function时，会默认将其当做是一个函数声明，函数声明必须有一个函数名，所以在执行到第一个左括号时就报语法错误了；</p>
<p>然后我们给它加上函数名:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;&#125;();   <span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line">    <span class="comment">//在一个表达式后面加上括号，表示该表达式立即执行；</span></span><br><span class="line">    <span class="comment">//而如果是在一个语句后面加上括号，该括号完全和之前的语句没什么关系，而只是一个分组操作符，用来控制运算中的优先级（小括号里的先运算）。</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;&#125;;   </span><br><span class="line">    ();<span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line">    <span class="comment">//分组操作符内的表达式不能为空，执行到右括号时，发现表达式为空，所以报错。</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而函数表达式的函数名则可有可无；</p>
<p>在function前面加！、+、 -、=甚至是逗号等或者把函数用（）包起来都可以将函数声明转换成函数表达式；我们一般用（）把函数声明包起来或者用 = ；</p>
<p>我们在函数后面加上括号，然后再用另一个括号把它们都包起来；</p>
<p>javascript中，括号内不允许包含语句，但可以是表达式；</p>
<p>引擎先遇到括号，然后遇到关键字function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;());</span><br><span class="line">    <span class="comment">//javascript中，括号内不允许包含语句，但可以是表达式；</span></span><br><span class="line">    <span class="comment">//引擎先遇到括号，然后遇到关键字function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明 </span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;)(); <span class="comment">//也可以这样写</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;();</span><br><span class="line">    <span class="comment">//我们可以在函数表达式后面直接加括号，而不用把函数包起来；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//但还是推荐外部加上()：</span></span><br><span class="line">    <span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;());</span><br><span class="line">    <span class="keyword">var</span> c = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;)();</span><br><span class="line">    <span class="comment">//因为外部如果没有()，我们得去function()&#123;/*code*/&#125;后面看是否存在()，判断b/c是一个函数还是一个函数内部的返回值</span></span><br><span class="line">    <span class="comment">//为了代码的可读性，还是要在外部加上()，无论是否已经是表达式；</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>javascript只有函数拥有局部作用域，立即执行函数也有这一特点，我们可以利用它减少全局变量造成的空间污染；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(abc);<span class="comment">//function abc()&#123;...&#125;  </span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line">    &#125;)()</span><br><span class="line"><span class="comment">//    console.log(a); //ReferenceError: a is not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(abc);<span class="comment">//ReferenceError: abc is not defined</span></span><br><span class="line">    <span class="comment">//立即执行函数的函数名在外部也是找不到的</span></span><br><span class="line">    <span class="comment">//函数表达式的标识符在外部作用域是找不到的，只有内部作用域可以找到</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h3><p>闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作；简单的说，外部作用域就可以访问函数内部作用域的变量了。</p>
<p>由于作用域的关系，我们在函数外部是无法直接访问到函数内部的变量的，但是函数内部可以把这个变量传给全局变量或者返回出来，这样外部作用域就可以访问函数内部作用域的变量了；</p>
<p>简单的说，闭包就是有权限访问另一个函数内部作用域的变量的函数；</p>
<ol>
<li>javascript具有自动垃圾回收机制，函数运行完之后，其内部的变量和数据会被销毁；</li>
<li>但是闭包就是在外部可以访问此函数内部作用域的变量，所以闭包的一个特点就是只要存在引用函数内部变量的可能，JavaScript就需要在内存中保留这些变量。而且JavaScript运行时需要跟踪这个内部变量的所有外部引用，直到最后一个引用被解除（主动把外部引用赋为null或者页面关闭），JavaScript的垃圾收集器才能释放相应的内存空间；这句话不是很好理解，下面用代码展示；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> abc = outer();</span><br><span class="line">    <span class="comment">//outer()只要执行过，就有了引用函数内部变量的可能，然后就会被保存在内存中；</span></span><br><span class="line">    <span class="comment">//outer()如果没有执行过，由于作用域的关系，看不到内部作用域，更不会被保存在内存中了；</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(abc());<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(abc());<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//因为a已经在内存中了，所以再次执行abc()的时候，是在第一次的基础上累加的</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> def = outer(); </span><br><span class="line">    <span class="built_in">console</span>.log(def());<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(def());<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//再次把outer()函数赋给一个新的变量def，相当于绑定了一个新的outer实例；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//console.log(a);//ReferenceError: a is not defined</span></span><br><span class="line">    <span class="comment">//console.log(inner);//ReferenceError: a is not defined</span></span><br><span class="line">    <span class="comment">//由于作用域的关系我们在外部还是无法直接访问内部作用域的变量名和函数名</span></span><br><span class="line">    </span><br><span class="line">    abc = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，释放内存；</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>立即执行函数能配合闭包保存状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);    <span class="comment">//3 3 3</span></span><br><span class="line">            <span class="comment">//在执行到这一行时，发现匿名函数里没有i，然后向往外部作用域找，然后找到的其实是for循环执行完了的i，也就是2++，3</span></span><br><span class="line">        &#125;,<span class="number">0</span>);  </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(x);    <span class="comment">//0 1 2</span></span><br><span class="line">        &#125;)(i),<span class="number">0</span>);  </span><br><span class="line">        <span class="comment">//在立即执行函数内部i传给了x，并且锁在内存中，所以不会变</span></span><br><span class="line">    &#125;; </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>用立即函数配合闭包写插件，防止变量全局污染，以及保证内部变量的安全；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sayName = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        str = str || <span class="string">'shane'</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _sayAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">        age = age || <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        SayName : _sayName,</span><br><span class="line">        SayAge : _sayAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过插件提供的API使用插件</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.SayName(<span class="string">'lucy'</span>)); <span class="comment">//lucy</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.SayName());<span class="comment">//shane</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.SayAge());<span class="comment">//18</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="一道经典面试题"><a href="#一道经典面试题" class="headerlink" title="一道经典面试题"></a>一道经典面试题</h4><p>下面的ul中，如何点击每一个 li 的时候弹出其下标?</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>index  00000<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>index  11111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>index  22222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>方法一： 闭包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>].children;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一种写法</span></span><br><span class="line">            (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                oLi[index].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(index);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;)(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二种写法</span></span><br><span class="line">            oLi[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>方法二： 将下标作为对象的一个属性，添加到每个数组元素中，（name: “ i “, value: i 的值）;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>].children;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++)&#123;</span><br><span class="line">            oLi[i].i = i;</span><br><span class="line">            oLi[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.i);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直没搞清楚立即执行函数和闭包之间的关系，总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;闭包有很多种理解：访问不到内部作用域，函数就是这样，所以函数就是闭包；&lt;/li&gt;
&lt;li&gt;闭包还有一种理解：通过把函数内部的变量和方法返回出来，这样外部作用域就可以访问内部作用域了，并且&lt;/li&gt;
&lt;li&gt;立即执行函数和闭包之间没有必然的联系，虽然它们经常结合一起使用；&lt;/li&gt;
&lt;li&gt;立即执行函数只是一种函数的调用方式；&lt;/li&gt;
&lt;li&gt;闭包的目的则是外部函数可以访问内部函数的作用域；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="闭包" scheme="https://callmejay.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之发布订阅模式</title>
    <link href="https://callmejay.github.io/2018/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://callmejay.github.io/2018/06/11/设计模式之发布订阅模式/</id>
    <published>2018-06-11T06:34:55.000Z</published>
    <updated>2018-06-11T08:10:30.669Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看设计模式的知识，而且在工作当中，做一些打点需求的时候，正好直接利用了发布订阅模式去实现的，这让我对发布订阅这种设计模式更加的感兴趣了，于是借此机会也和大家说说这个好东东吧！</p>
<p>其实在早期还是用jq开发的时代，有很多地方，我们都会出现发布订阅的影子，例如有trigger和on方法</p>
<p>再到现在的vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来</p>
<p>那么废话不多说了，先来看看发布订阅模式到底何方神圣吧</p>
<a id="more"></a>
<p>说到发布订阅模式，它其实是一种对象间一对多的依赖关系(不是综艺节目以一敌百那种)，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知.</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>广泛用于异步编程中（替代了传统回调函数）</li>
<li>对象之间松散耦合的编写代码</li>
</ol>
<p>当然，胖子也不是一天吃成的。所以我们要想实现一个自己的发布订阅模式，以后在工作中使用，也需要一点点来的，表捉急，先从最简单的说起。</p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> corp = &#123;&#125;;   <span class="comment">// 自定义一个公司对象</span></span><br><span class="line"><span class="comment">// 这里放一个列表用来缓存回调函数</span></span><br><span class="line">corp.list = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">corp.on = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 直接把fn先存到列表中</span></span><br><span class="line">    <span class="keyword">this</span>.list.push(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">corp.emit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当发布的时候再把列表里存的函数依次执行</span></span><br><span class="line">    <span class="keyword">this</span>.list.forEach( <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">corp.on(<span class="function"><span class="keyword">function</span> (<span class="params">position, salary</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的职位是：'</span> + position);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'期望薪水：'</span> + salary);</span><br><span class="line">&#125;);</span><br><span class="line">corp.on(<span class="function"><span class="keyword">function</span>(<span class="params">skill, hobby</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的技能有： '</span> + skill);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爱好： '</span> + hobby);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">corp.emit(<span class="string">'前端'</span>, <span class="number">10000</span>);</span><br><span class="line">corp.emit(<span class="string">'端茶和倒水'</span>, <span class="string">'足球'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    你的职位是：前端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的技能有： 前端</span></span><br><span class="line"><span class="comment">    爱好： 10000</span></span><br><span class="line"><span class="comment">    你的职位是：端茶和倒水</span></span><br><span class="line"><span class="comment">    期望薪水：足球</span></span><br><span class="line"><span class="comment">    你的技能有： 端茶和倒水</span></span><br><span class="line"><span class="comment">    爱好： 足球</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面通过自定义事件实现了一个简单的发布订阅模式，不过从打印出来的结果来看，有点小尴尬。Why？</p>
<p>因为在正常的情况下，希望打印的是酱紫的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    你的职位是：前端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的技能有： 端茶和倒水</span></span><br><span class="line"><span class="comment">    爱好： 足球</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>之所以出现此种情况，那是在on方法的时候一股脑的都将fn函数全部放到了列表中。然而需要的只是一个简单的key值，就可以解决了。让我们改写一下上面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> corp = &#123;&#125;;</span><br><span class="line"><span class="comment">// 这次换成一个对象类型的缓存列表</span></span><br><span class="line">corp.list = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">corp.on = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果对象中没有对应的key值</span></span><br><span class="line">    <span class="comment">// 也就是说明没有订阅过</span></span><br><span class="line">    <span class="comment">// 那就给key创建个缓存列表</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.list[key])&#123;</span><br><span class="line">        <span class="keyword">this</span>.list[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把函数添加到对应key的缓存列表里</span></span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">corp.emit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是对应的key值</span></span><br><span class="line">    <span class="comment">// 直接用数组的shift方法取出</span></span><br><span class="line">    <span class="keyword">let</span> key = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 获取该键值中存在的所有函数</span></span><br><span class="line">    fns = <span class="keyword">this</span>.list[key];</span><br><span class="line">    <span class="comment">// 如果不存在或者没有返回</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length ==== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历key值对应的缓存列表</span></span><br><span class="line">    <span class="comment">// 依次执行函数的方法</span></span><br><span class="line">    fns.forEach( <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">corp.on(<span class="string">'join'</span>, (position, salary) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的职位是：'</span> + position);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'期望薪水：'</span> + salary);</span><br><span class="line">&#125;);</span><br><span class="line">corp.on(<span class="string">'other'</span>, (skill, hobby) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的技能有： '</span> + skill);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爱好： '</span> + hobby);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">corp.emit(<span class="string">'join'</span>, <span class="string">'前端'</span>, <span class="number">10000</span>);</span><br><span class="line">corp.emit(<span class="string">'join'</span>, <span class="string">'后端'</span>, <span class="number">10000</span>);</span><br><span class="line">corp.emit(<span class="string">'other'</span>, <span class="string">'端茶和倒水'</span>, <span class="string">'足球'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    你的职位是：前端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的职位是：后端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的技能有： 端茶和倒水</span></span><br><span class="line"><span class="comment">    爱好： 足球</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="来个通用的"><a href="#来个通用的" class="headerlink" title="来个通用的"></a>来个通用的</h4><p>现在来搞个通用的发布订阅模式实现，和刚才的差不多，不过这次起名也要隆重些了，直接叫event吧，看代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">    list: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    on(key,fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.list[key])&#123;</span><br><span class="line">            <span class="keyword">this</span>.list[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list[key].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    emit()&#123;</span><br><span class="line">        <span class="keyword">let</span> key = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">        fns = <span class="keyword">this</span>.list[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fns.forEach( <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    remove(key,fn)&#123;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.list[key];</span><br><span class="line">        <span class="comment">// 如果不存在对应的key</span></span><br><span class="line">        <span class="keyword">if</span>(!fns) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果没有传入函数，就会将key值对应缓存列表中的函数都清空掉</span></span><br><span class="line">        <span class="keyword">if</span>(!fn) fns &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果都存在</span></span><br><span class="line">        fns.forEach( <span class="function">(<span class="params">cb,i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cb === fn) &#123;</span><br><span class="line">                fns.splice(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'一起喵喵喵'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'一起旺旺旺'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">'pet'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接收数据'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">event.on(<span class="string">'pet'</span>, cat);</span><br><span class="line">event.on(<span class="string">'pet'</span>, dog);</span><br><span class="line"><span class="comment">// 取消dog方法的订阅</span></span><br><span class="line">event.remove(<span class="string">'pet'</span>, dog);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">event.emit(<span class="string">'pet'</span>, [<span class="string">'二哈'</span>, <span class="string">'波斯猫'</span>]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    接收数据</span></span><br><span class="line"><span class="comment">    [ '二哈', '波斯猫' ]</span></span><br><span class="line"><span class="comment">    一起喵喵喵</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这样其实就实现了一个可以使用的发布订阅模式了，其实说起来也是比较简单的，来一起屡屡思路吧.</p>
<p><strong>思路</strong>：</p>
<ul>
<li>创建一个对象(缓存列表)</li>
<li>on方法用来把回调函数fn都加到缓存列表中</li>
<li>emit方法取到arguments里第一个当做key，根据key值去执行对应缓存列表中的函数</li>
<li>remove方法可以根据key值取消订阅</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>优点：</strong></p>
<ul>
<li>对象之间的解耦</li>
<li>异步编程中，可以更松耦合的代码编写</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>创建订阅者本身要消耗一定的时间和内存</li>
<li>多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护</li>
</ul>
<p>强如发布订阅模式，也是劲酒虽好，不要贪杯的道理哦。过度使用的话，都会出现上述缺点的问题。不过合理开发合理利用，这都不是什么大问题的。</p>
<p><a href="https://juejin.im/post/5b125ad3e51d450688133f22" target="_blank" rel="noopener">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看设计模式的知识，而且在工作当中，做一些打点需求的时候，正好直接利用了发布订阅模式去实现的，这让我对发布订阅这种设计模式更加的感兴趣了，于是借此机会也和大家说说这个好东东吧！&lt;/p&gt;
&lt;p&gt;其实在早期还是用jq开发的时代，有很多地方，我们都会出现发布订阅的影子，例如有trigger和on方法&lt;/p&gt;
&lt;p&gt;再到现在的vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来&lt;/p&gt;
&lt;p&gt;那么废话不多说了，先来看看发布订阅模式到底何方神圣吧&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="设计模式" scheme="https://callmejay.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://callmejay.github.io/2018/06/04/%E6%A0%91/"/>
    <id>https://callmejay.github.io/2018/06/04/树/</id>
    <published>2018-06-04T07:27:53.000Z</published>
    <updated>2018-06-11T06:27:17.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p>
<p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。<br><a id="more"></a></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&amp;h=267&amp;f=png&amp;s=11622" alt=""></p>
<h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p>
<p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&amp;h=485&amp;f=png&amp;s=36796" alt=""></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">this</span>.size++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p>
<p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p>
<p>以下都是递归实现，如果你想学习非递归实现，可以 <a href="../Algorithm/algorithm-ch.md#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">点击这里阅读</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._pre(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.left)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._mid(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._mid(node.left)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._back(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._back(node.left)</span><br><span class="line">    <span class="keyword">this</span>._back(node.right)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">breadthTraversal() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue()</span><br><span class="line">    <span class="built_in">console</span>.log(n.value)</span><br><span class="line">    <span class="keyword">if</span> (n.left) q.enQueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getMin() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMax(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">floor(v) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._floor(<span class="keyword">this</span>.root, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.value === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="keyword">this</span>._floor(node.right, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排名</strong>，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">select(k) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p>
<ul>
<li>需要删除的节点没有子树</li>
<li>需要删除的节点只有一条子树</li>
<li>需要删除的节点有左右两条树</li>
</ul>
<p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delectMin() &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delectMin(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = <span class="keyword">this</span>._delectMin(node.left)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</p>
<p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p>
<p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">delect(v) &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delect(<span class="keyword">this</span>.root, v)</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    node.right = <span class="keyword">this</span>._delect(node.right, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="keyword">this</span>._delect(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node.right</span><br><span class="line">    <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="keyword">this</span>._delectMin(node.right)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left</span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;p&gt;树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。&lt;/p&gt;
&lt;p&gt;二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://callmejay.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://callmejay.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://callmejay.github.io/2018/03/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://callmejay.github.io/2018/03/17/排序算法/</id>
    <published>2018-03-17T09:19:10.000Z</published>
    <updated>2018-03-27T14:22:14.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><blockquote>
<p>大家开始学习冒泡排序的，一般都是从冒泡排序开始，这是最简单的排序，，但是从运算时间来说，冒泡排序是最差的一个。</p>
</blockquote>
<a id="more"></a>
<p>算法描述</p>
<blockquote>
<p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>
</blockquote>
<p>先来实现一下冒泡排序：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意当算法执行外循环的第二轮时，最后两个数组已经是正确排序了，尽管如此，在后续的比较中，它们还一直在进行着比较，即便这是不必要的。因此，我们可以改进一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> pos; <span class="comment">// 先声明标志变量</span></span><br><span class="line">    <span class="keyword">var</span> i = len<span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变</span></span><br><span class="line">    <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j= <span class="number">0</span>; j&lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                pos= j; <span class="comment">//记录交换的位置</span></span><br><span class="line">                <span class="keyword">var</span> tmp = arr[j]; arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        i= pos; <span class="comment">//为下一趟排序作准备</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序动图演示<br><img src="http://oonulpk6h.bkt.clouddn.com/bubblesort.gif" alt="冒泡排序"></p>
<h3 id="选择排序（Select-Sort）"><a href="#选择排序（Select-Sort）" class="headerlink" title="选择排序（Select Sort）"></a>选择排序（Select Sort）</h3><blockquote>
<p>选择排序是一种简单直观的排序算法，它的工作原理是：首先找到数据结构中的最小值,然后将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelectSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> indexMin,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        indexMin = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(arr[indexMin] &gt; arr[j]) indexMin = j; <span class="comment">// 找到最小的值，保存其索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i !== indexMin) &#123; <span class="comment">// 交换位置sels</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[indexMin];</span><br><span class="line">            arr[indexMin] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序动图演示<br><img src="http://oonulpk6h.bkt.clouddn.com/selectSort.gif" alt="选择排序"></p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>算法介绍</p>
<blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<p>算法的描述和实现<br>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> temp, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp)&#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进插入排序：查找插入位置时使用二分查找的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> key=arr[i],left=<span class="number">0</span>,right=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left+right)/<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(key &lt; arr[middle])&#123;</span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   left = middle+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = i<span class="number">-1</span>;j&gt;=left;j--)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"arr is not an Array"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插入排序演示图示<br><img src="http://oonulpk6h.bkt.clouddn.com/insertSort.gif" alt="选择排序"></p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<p>算法介绍</p>
<blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<p>算法描述和实现<br>具体算法描述如下：</p>
<ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123; <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(arr &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);</span><br><span class="line">    left = arr.slice(<span class="number">0</span>,middle);</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">while</span>(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>])&#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left.length)</span><br><span class="line">    result.push(left.shift());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(right.length)</span><br><span class="line">    result.push(right.shift());</span><br><span class="line">    </span><br><span class="line">    result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序动图演示<br><img src="http://oonulpk6h.bkt.clouddn.com/mergeSort.gif" alt="选择排序"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;&lt;a href=&quot;#冒泡排序（Bubble-Sort）&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序（Bubble Sort）&quot;&gt;&lt;/a&gt;冒泡排序（Bubble Sort）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;大家开始学习冒泡排序的，一般都是从冒泡排序开始，这是最简单的排序，，但是从运算时间来说，冒泡排序是最差的一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="https://callmejay.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之对象的扩展</title>
    <link href="https://callmejay.github.io/2018/03/13/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://callmejay.github.io/2018/03/13/ES6入门之对象的扩展/</id>
    <published>2018-03-13T13:29:47.000Z</published>
    <updated>2018-03-16T15:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性的简洁表示"><a href="#属性的简洁表示" class="headerlink" title="属性的简洁表示"></a>属性的简洁表示</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: 'bar'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>除了属性简写，方法也可以简写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个实际的例子.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">'2000/01/01'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等同于birth: birth</span></span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">  hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法用于函数的返回值，将会非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getItem: getItem,</span><br><span class="line">  setItem: setItem,</span><br><span class="line">  clear: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> () </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个<code>Generator</code>函数，前面需要加上星号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  * m() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>JavaScript 定义对象的属性，有两种方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="literal">true</span>,</span><br><span class="line">  abc: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是另一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">'last word'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</span><br><span class="line">  [lastWord]: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">'first word'</span>] <span class="comment">// "hello"</span></span><br><span class="line">a[lastWord] <span class="comment">// "world"</span></span><br><span class="line">a[<span class="string">'last word'</span>] <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure></p>
<p>表达式还可以用于定义方法名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">'h'</span> + <span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure></p>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">'valueA'</span>,</span><br><span class="line">  [keyB]: <span class="string">'valueB'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: "valueB"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   <span class="comment">// "sayName"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，方法的name属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  get foo() &#123;&#125;,</span><br><span class="line">  set foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name <span class="comment">// "get foo"</span></span><br><span class="line">descriptor.set.name <span class="comment">// "set foo"</span></span><br></pre></td></tr></table></figure></p>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回<code>anonymous</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// 'anonymous'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// 'bound doSomething'</span></span><br></pre></td></tr></table></figure></p>
<p>如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">'description'</span>);</span><br><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name <span class="comment">// "[description]"</span></span><br><span class="line">obj[key2].name <span class="comment">// ""</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>key1</code>对应的 <code>Symbol</code> 值有描述，<code>key2</code>没有。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 可以通过下面的代码，部署Object.is。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'is'</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><hr>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>如果该参数不是对象，则会先转成对象，然后返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="string">'abc'</span>) <span class="comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">'c'</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">'hello'</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: 'c' &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为 <code>Symbol</code> 值的属性，也会被<code>Object.assign</code>拷贝。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="string">'b'</span> &#125;, &#123; [<span class="built_in">Symbol</span>(<span class="string">'c'</span>)]: <span class="string">'d'</span> &#125;)</span><br><span class="line"><span class="comment">// &#123; a: 'b', Symbol(c): 'd' &#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<h5 id="同名属性的替换"><a href="#同名属性的替换" class="headerlink" title="同名属性的替换"></a>同名属性的替换</h5><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'c'</span>, <span class="attr">d</span>: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供<code>Object.assign</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p>
<h5 id="数组的处理"><a href="#数组的处理" class="headerlink" title="数组的处理"></a>数组的处理</h5><p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。</p>
<h5 id="取值函数的处理"><a href="#取值函数的处理" class="headerlink" title="取值函数的处理"></a>取值函数的处理</h5><p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  get foo() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h4 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h4><p><code>Object.assign</code>方法有很多用处。</p>
<h5 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法通过<code>Object.assign</code>方法，将x属性和y属性添加到<code>Point</code>类的对象实例。</p>
<h5 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<h5 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h5><p>将多个对象合并到某个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (target, ...sources) =&gt; <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure></p>
<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (...sources) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure></p>
<h5 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">  <span class="built_in">console</span>.log(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  url: &#123;</span><br><span class="line">    host: <span class="string">'example.com'</span>,</span><br><span class="line">    port: <span class="number">7070</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">processContent(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的原意是将<code>url.port</code>改成 <code>8000</code>，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<h3 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h3><hr>
<h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的length属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">'toString'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 <code>Class</code> 的原型的方法都是不可枚举的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;foo() &#123;&#125;&#125;.prototype, <span class="string">'foo'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<h5 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h5><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<h5 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h5><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<h5 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h5><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<h5 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h5><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。</p>
<h3 id="原型的操作方法"><a href="#原型的操作方法" class="headerlink" title="原型的操作方法"></a>原型的操作方法</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法.</p>
<h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__ 属性"></a>__proto__ 属性</h4><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5 的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">let</span> _thisObj = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  set(proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">undefined</span> || <span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="built_in">Reflect</span>.setPrototypeOf(<span class="keyword">this</span>, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>该方法等同于下面的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">'foo'</span>, &#123;&#125;) === <span class="string">'foo'</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure></p>
<p>下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>如果参数不是对象，会被自动转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String('foo'))</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) === <span class="built_in">Number</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">'foo'</span>) === <span class="built_in">String</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) === <span class="built_in">Boolean</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure></p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'world'</span>,</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>obj</code>的<code>find</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让<code>JavaScript</code>引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h3 id="遍历对象的方法"><a href="#遍历对象的方法" class="headerlink" title="遍历对象的方法"></a>遍历对象的方法</h3><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>ES5 引入了<code>bject.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>:<span class="string">'bar'</span>,<span class="attr">baz</span>:<span class="number">42</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// ["foo", "baz"]</span></span><br></pre></td></tr></table></figure></p>
<p>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// ['a', 1], ['b', 2], ['c', 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// ["bar", 42]</span></span><br></pre></td></tr></table></figure></p>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// ["b", "c", "a"]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>.</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性p的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">'abc'</span> &#125;);</span><br><span class="line"><span class="comment">// ['abc']</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// ['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><p>《数组的扩展》一章中，已经介绍过扩展运算符（…）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">null</span>; <span class="comment">// 运行时错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">undefined</span>; <span class="comment">// 运行时错误</span></span><br></pre></td></tr></table></figure></p>
<p>解构赋值必须是最后一个参数，否则会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = obj; <span class="comment">// 句法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">o3.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>
<p>下面是另一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.create(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。</p>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这等同于使用Object.assign方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> clone1 = &#123;</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure></p>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="built_in">Object</span>.assign(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  name: <span class="string">'New Name'</span> <span class="comment">// Override the name property</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>newVersion</code>对象自定义了name属性，其他属性全部复制自<code>previousVersion</code>对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"> even <span class="keyword">if</span> property keys don’t clash, because objects record insertion order:</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br></pre></td></tr></table></figure></p>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果扩展运算符后面是一个空对象，则没有任何效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br><span class="line"> even <span class="keyword">if</span> property keys don’t clash, because objects record insertion order:</span><br></pre></td></tr></table></figure></p>
<p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这两个值会被忽略，不会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyObject = &#123; ...null, ...undefined &#125;; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure></p>
<p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  get x() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'not throw yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为 x 属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    get x() &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'throw now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;属性的简洁表示&quot;&gt;&lt;a href=&quot;#属性的简洁表示&quot; class=&quot;headerlink&quot; title=&quot;属性的简洁表示&quot;&gt;&lt;/a&gt;属性的简洁表示&lt;/h3&gt;&lt;p&gt;ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; baz = &amp;#123;foo&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baz &lt;span class=&quot;comment&quot;&gt;// &amp;#123;foo: &#39;bar&#39;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等同于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; baz = &amp;#123;&lt;span class=&quot;attr&quot;&gt;foo&lt;/span&gt;: foo&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="对象" scheme="https://callmejay.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入对象</title>
    <link href="https://callmejay.github.io/2018/03/07/JavaScript%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/"/>
    <id>https://callmejay.github.io/2018/03/07/JavaScript深入对象/</id>
    <published>2018-03-07T15:03:40.000Z</published>
    <updated>2018-03-12T15:12:20.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="简单做法"><a href="#简单做法" class="headerlink" title="简单做法"></a>简单做法</h4><h5 id="使用Object构造函数创建"><a href="#使用Object构造函数创建" class="headerlink" title="使用Object构造函数创建"></a>使用Object构造函数创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象实例的创建</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() </span><br><span class="line">obj.key = <span class="string">'value'</span>   <span class="comment">//使用构造函数创建一个空对象，并赋值s</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="使用对象字面量表示法创建"><a href="#使用对象字面量表示法创建" class="headerlink" title="使用对象字面量表示法创建"></a>使用对象字面量表示法创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    key1: <span class="string">'value1'</span>,</span><br><span class="line">    key2: <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字面量表示法与 Object 构造函数创建法唯一的区别是，在字面量表示法里你可以给对象添加多个 键/值 对，但是在构造形式中你必须逐个添加属性。</p>
<p>现在ES6可以使用更简洁的方式创建对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">'sexy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'jay'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简洁表示法，等同于 age: age</span></span><br><span class="line">    age, </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简洁表示法，等同于 sayName： function() &#123;&#125;</span></span><br><span class="line">    sayName()&#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性名表达式，等同于 lover:'rose'</span></span><br><span class="line">    [<span class="string">'lo'</span>+<span class="string">'ver'</span>]: <span class="string">'rose'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性名表达式，等同于 sexy: 'male'</span></span><br><span class="line">    [sex]: <span class="string">'male'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 ‘[object Object]’，这一点要特别小心。</p>
</blockquote>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>即用函数来封装创建对象的细节。多次调用该函数来创建多个相似对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">    o.name = name</span><br><span class="line">    o.age = age</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = createPerson(<span class="string">'a'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> b = createPerson(<span class="string">'b'</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure></p>
<p>工厂模式虽然解决多创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<h4 id="模仿‘类’的设计"><a href="#模仿‘类’的设计" class="headerlink" title="模仿‘类’的设计"></a>模仿‘类’的设计</h4><h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><p>构造函数包括像Array,Object这样的原生构造函数，他们在js运行时会自动出现在执行环境中。此外，我们可以创建自定义构造函数，从而定义自定义类型的属性和方法。现在构造函数重写上个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Person(<span class="string">'a'</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数就是普通的函数，不存在特殊语法。构造函数与其他函数唯一的区别就在于调用他们的方式不同。任何函数只要通过<code>new</code>操作符来调用，那它就可以作为构造函数。<br>使用<code>new</code>操作符调用函数，或者说发生构造函数调用时，会自动执行下面操作：</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个新对象会被执行[[Prototype]] 链接。</li>
<li>这个新对象会绑定到函数调用时的this。</li>
<li>如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象。</li>
</ol>
<p>由于构造函数调用时会自动执行 [[Prototype]] 链接，也就是把新对象的原型链指向构造函数的 prototype。所以使用<code>instanceof</code>或<code>isPrototypeOf</code>方法可以判断他们的类型。</p>
<p>上面这种构造函数解决了对象类型识别的问题，但是每个方法都要在每个实例上重新创建一遍，在上面的例子中，a 和 b 都有个名为<code>sayName()</code>的方法，这两个方法虽然名字、内容、功能相同，但却分别在 a 和 b 中都重新创建了一次，这是没有必要的。</p>
<p>更好的方法应该是将公用的方法放到他们的原型上，也就是接下来要说的原型模式。</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>所有函数都有一个不可枚举的prototype(原型)属性，这个属性时一个指针，指向一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上一节【构造函数模式】里面有说，<code>new</code>操作符会新建一个对象，并把该对象的原型链指向构造函数的 <code>prototype</code> 所指向的对象。</p>
<p>这里出现了一个重点词<strong>原型链</strong>，我们先解释下什么叫做原型链。</p>
<blockquote>
<p>原型链也被称为 [[Prototype]]链，是对象的内置属性。原型链是 ECMAScript 中实现继承的主要办法，其基本思想就是让一个引用类型继承另一个引用类型的属性和和方法。</p>
</blockquote>
<p>例如我们新建个对象 a，然后给它指定它的原型链的指向：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b)</span><br><span class="line"> </span><br><span class="line">a.x <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子中我们通过<code>Object.setPrototypeOf()</code>方法把 a 的原型链指向 b，然后 a 就继承了 b 的属性，当查询 a 中没有的 x 属性时，会指向到 b.x 的值。</p>
<p>这里原理上说是委托比说是继承更符合真实情况。因为真实情况如上段所说是 a 把自身没有的属性查询委托给 b，如果 b 中也没 x 属性的话，系统会继续循着原型链往上查。所有普通的 [[Prototype]] 链最终都会指向内置的 <code>Object.prototype</code>。如果 <code>Object.prototype</code> 也没有的话就会提示 <code>undefined</code>。</p>
<p>这里提示一下，由于所有普通的对象都”源于“（或者说把 [[Prototype]] 链的顶端设置为）这个 <code>Object.prototype</code> 对象，所以它包含 Javascript 中许多通用的功能。</p>
<p>上面说过，new操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 属性所指向的对象（即原型对象）。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'h'</span>,</span><br><span class="line">    sayName () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person()</span><br><span class="line"> </span><br><span class="line">a.sayName() <span class="comment">// h</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法因为重写了Person.prototype,所以默认的Person.prototype.constructor也会丢失，如果要修复constructor,可以使用<code>Object.defineProperty()</code>.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">'constructor'</span>,&#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>不过实例一般都是要有属于自己的全部属性的。所以日常开发中设计对象更常见的做法是构造函数模式跟原型模式组合使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>);</span><br><span class="line">a.sayName(); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure></p>
<p>这里很像一些面向“类”的语言的行为，a 和 b 是 Person 类的实例，a 和 b 继承了 Person 类的特性。但实际上 JavaScript 和面向类的语言不同，它并没有类作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。</p>
<h5 id="使用ES6-Class"><a href="#使用ES6-Class" class="headerlink" title="使用ES6 Class"></a>使用ES6 Class</h5><p>上面说的原型是通过构造函数，定义并生成新对象。但这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。</p>
<p>不过需要注意的是， ES6 的 class 语法是并不是向 JavaScript 中引入了一种新的“ 类” 机制。 <strong>class 基本上只是现有 [[Prototype]] 机制的一种语法糖。</strong></p>
<p>也就是说， class 并不会像传统面向类的语言一样在声明时静态复制所有行为。 如果你（ 有意或无意） 修改或者替换了父“ 类” 中的一个方法， 那子“ 类” 和所有实例都会受到影响， 因为它们在定义时并没有进行复制， 只是使用基于 [[Prototype]] 的实时委托。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Foo <span class="comment">// 'function'</span></span><br><span class="line">Foo === Foo.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayName () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Foo(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">a.sayName(); <span class="comment">// a</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数的prototype 属性，在ES6的‘类’上继续存在，事实上，类的所有方法都定义上类的prototype 属性上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;&#125;</span><br><span class="line">    toString () &#123;&#125;</span><br><span class="line">    toValue () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    toString()&#123;&#125;,</span><br><span class="line">    toValue () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.assign(Foo.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>ES6 Class 与 普通构造函数的不同点主要有 4 个：</p>
<p>(1)constructor 方法</p>
<p><code>constructor</code>方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<p><code>constructor</code>方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo    <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo()</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure></p>
<p>(2)类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与普通构造函数的行为不一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.keys(Foo.prototype)  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Foo.prototype)   <span class="comment">// ["constructor","sayName"]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.keys(Foo.prototype)  <span class="comment">// ["sayName"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Foo.prototype)   <span class="comment">// ["constructor", "sayName"]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，sayName方法是 Foo 类内部定义的方法，它是不可枚举的。而定义在 Foo.prototype 中的话则是可枚举的。</p>
<p>(3) Class不存在变量提升（hoist），这点与ES5完全不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p>(4)子类的继承</p>
<p>Class 之间可以通过 <code>extends</code> 关键字实现继承，这比普通构造函数通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了一个 Bar 类，该类通过extends关键字，继承了 Foo 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Foo 类。下面，我们在 Bar 内部加上代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name,age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayProfile () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name ,age, lover) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);<span class="comment">// 调用父类的 constructor(name,age), 约等于普通构造函数中的 Foo.call(this, name, age)</span></span><br><span class="line">        <span class="keyword">this</span>.age = <span class="built_in">Number</span>(<span class="keyword">this</span>.age) + <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">this</span>.lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayIntro() &#123;</span><br><span class="line">        alert(<span class="keyword">super</span>.sayProfile() + <span class="string">`, my lover is <span class="subst">$&#123;<span class="keyword">this</span>.lover&#125;</span>, again, I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'Jack'</span>, <span class="string">'20'</span>, <span class="string">'Rose'</span>)</span><br><span class="line"> </span><br><span class="line">a.sayIntro()    <span class="comment">// "hello, my name is Jack, 25 years old, my lover is Rose, again, I am</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，子类 Bar 的<code>constructor</code>方法和<code>sayIntro</code>方法之中，都出现了<code>super</code>关键字，<code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。在上面的代码中 子类 Bar 的构造函数中<code>super(name, age)</code>相当于<code>Foo.prototype.constructor.call(this, name, age)</code>。作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<p><strong>要注意的是，子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错</strong>。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到 this 对象。在子类的构造函数中，只有调用<code>super</code>之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p>
<p>普通构造函数的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面<code>（Foo.call(this)）</code>。<strong>ES6 Class 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改 this。</strong></p>
<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种情况，<strong><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong>上面代码代码中的 <code>super.sayProfile()</code>就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向 <code>Foo.prototype</code>，所以<code>super.sayProfile()</code>就相当于<code>Foo.prototype.sayProfile()</code>。</p>
<p>ES6 规定，通过<code>super</code>调用父类的方法时，<code>super</code>会绑定子类的 this。所以<code>sayProfile</code>输出的<code>this.age</code>是子类 Bar 的 age 25岁。</p>
<p>刚刚说到在静态方法中<code>super</code>指向父类。</p>
<blockquote>
<p>静态方法</p>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> sayHi () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.sayHi(); <span class="comment">// hello</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.sayHi(); <span class="comment">// TypeError: a.sayHi is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中<code>ayHi()</code>就是 Foo 的静态方法，它只能通过 Foo 调用，不能通过 Foo 的实例调用。</p>
<p>如果<code>super</code>作为对象用在静态方法中，这时<code>super</code>将指向父类，而不是父类的原型对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> sayHi() &#123;  <span class="comment">// 父类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi () &#123;  <span class="comment">// 原型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'oops'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> sayBob () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sayHi() + <span class="string">'Bob'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.sayBob (); <span class="comment">// 'hello Bob'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="面向委托的设计（对象关联风格）"><a href="#面向委托的设计（对象关联风格）" class="headerlink" title="面向委托的设计（对象关联风格）"></a>面向委托的设计（对象关联风格）</h4><p>有些开发者比较诟病这种模仿“类”的设计模式，因为继承意味着复制，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联（我们把这种关联成为原型链），这样对象就可以通过委托访问另一个对象的属性和函数。委托这个术语可以更加准确地描述 JavaScript 中的对象关联机制。</p>
<p>即便通过 ES6 class 让 js 看起来更像“类”，也只是一种模仿的假象。在传统的面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改，但是 Javascript 最强大的特性就是它的动态性，任何对象的定义都可以修改（除非你把它定义为不可变）。</p>
<p>一些开发者认为 ES6 的 class 想伪装成一种很好的语法问题的解决方案，但实际上却让问题更难解决且让 JavaScript 更难理解。因为它隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托机制。让本来简洁优雅的 [[Prototype]] 机制变的非常别扭。</p>
<p>我们比较下继承与委托设计的区别。</p>
<p>我们先想想类（继承）的设计方法：先定义一个通用的父类 F，在父类 F 中定义所有任务都有的行为，接着定义子类 a 和 b，他们都继承自父类并且会添加一些特殊行为来处理对应的任务。</p>
<p>再用委托的思想来考虑同样的问题：首先先定义一个对象 F，它包含所有任务都可以使用（委托）的具体行为。接着，对于每个任务你都会定义一个对象来储存对应的数据和行为，你会把特定的任务对象都关联到 F 功能对象上面，让他们在需要的时候可以进行委托。基本你可以想象成 a 和 F 之间是兄弟关系，a 完成不了的任务东西都委托给 F完成。</p>
<blockquote>
<p>JavaScript 中原型链实际上是委托的关系而不是继承。委托行为意味着某些对象在找不到属性或方法引用时会把这个请求委托给另一个对象。</p>
</blockquote>
<p>我们先看一个使用类设计风格的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Foo</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.intro = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Foo.call(<span class="keyword">this</span>,name);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="keyword">this</span>.intro())&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>);</span><br><span class="line">a.speak(); <span class="comment">// my name is a</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子里子类 Bar 继承了父类 Foo，然后生成了 a 这个实例，a 通过 new 构造函数委托了 <code>Bar.prototype</code>，<code>Bar.prototype</code> 通过<code>Object.create()</code>方法委托了 <code>Foo.prototype()</code>。这种风格很常见，你应该已经熟悉了。</p>
<p>当然我们可以用 class 让这段代码看起来更简洁明了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    intro() &#123; <span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123; alert(<span class="keyword">super</span>.intro()) &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>)</span><br><span class="line"> </span><br><span class="line">a.speak()</span><br></pre></td></tr></table></figure></p>
<p>现在再来看看同例的对象关联风格的设计：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Foo = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;,</span><br><span class="line">    intro: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'my name is '</span> + <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Bar = <span class="built_in">Object</span>.create(Foo)</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.intro())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(Bar)</span><br><span class="line">a.init(<span class="string">'a'</span>)</span><br><span class="line"> </span><br><span class="line">a.speak()</span><br></pre></td></tr></table></figure></p>
<p>这段代码中我们同样利用 [[Prototype]] 把 a 委托给 Bar 并把 Bar 委托给 Foo，和上段代码一样，我们仍然实现了三个对象的关联。</p>
<p>但非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。</p>
<h3 id="对象的内容"><a href="#对象的内容" class="headerlink" title="对象的内容"></a>对象的内容</h3><p>对象的内容是由一些储存在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p>
<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a>getter与setter</h4><h5 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h5><p>get 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。该方法会覆盖单个属性默认的 [[Get]] 操作（获得属性值的操作）。</p>
<p>用法：</p>
<blockquote>
<p>{get prop() { … } } // prop 为要绑定到给定函数的属性名</p>
<p>{get <a href="">expression</a> { … } } //从ECMAScript 2015 (ES6)开始，还可以使用一个计算的属性名的表达式绑定到给定的函数。</p>
</blockquote>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    get a () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 defineProperty 创建</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="string">'b'</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a*<span class="number">2</span>&#125;,</span><br><span class="line">    enumable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myObj.a <span class="comment">// 2</span></span><br><span class="line">myObj.b <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">3</span> </span><br><span class="line">myObj.a  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>如上面例子，不管是对象文字语法中的<code>get a() { .. }</code>， 还是<code>defineProperty(...)</code>中的显式定义， 二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。</p>
<p>同时由于我们只定义了 a 的 getter， 所以对 a 的值进行设置时 set 操作会忽略赋值操作，且不会抛出错误。 为了让属性更合理， 我们还应当定义 setter。</p>
<h5 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h5><p>set 语法会覆盖单个属性默认的 [[Put]] 操作（赋值操作）。</p>
<p>通常来说 getter 和 setter 是成对出现的（ 只定义一个的话通常会产生意料之外的行为）。</p>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    get a () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line">    set a(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">2</span>;</span><br><span class="line">myObj.a <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>注意，在本例中， 实际上我们把赋值（ [[Put]]） 操作中的值 2 存储到了另一个变量_a_中。 名称_a_只是一种惯例， 没有任何特殊的行为，和其他普通属性一样。</p>
<h4 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h4><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p><code>for keys in object</code> 循环可以遍历对象的可枚举属性列表（包括 [[Prototype]] 原型链）。</p>
<p><code>for..in</code>循环是无法直接获取属性值的，你需要手动获取属性值。</p>
<p>需要注意的是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。</p>
<h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><p><code>for..of</code>循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 <code>next()</code> 方法来遍历所有返回值。</p>
<p>我们先看一下迭代器的定义：</p>
<blockquote>
<p><strong>可迭代协议</strong></p>
<p>可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可遍历对象并且有默认的迭代行为, 比如 Array、Map, 另一些类型则不是 (比如 Object) 。</p>
<p>为了变成可遍历对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链上的某个对象）必须有一个名字是 Symbol.iterator 的属性:</p>
</blockquote>
<p>数组有内置的 <code>@@iterator</code>， 因此<code>for..of</code>可以直接应用在数组上:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> myArr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>我们再通过数组的<code>Symbol.iterator</code>属性看看<code>@@iterator</code>是怎么工作的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">it = myArr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">it.next()   <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next()   <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next()   <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next()   <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如你所见，调用迭代器的<code>next()</code>方法会返回形式为<code>{value: .., done: ..}</code>的值，<code>value</code>是当前的遍历值，<code>done</code>是一个布尔值，表示是否还有可以遍历的值。</p>
<p>上面示例中需要注意的一点，我们使用符号<code>Symbol.iterator</code>来获取对象的<code>@@iterator</code>内部属性。引用类似 <code>iterator</code> 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但<code>@@iterator</code>本身并不是迭代器对象，而是返回迭代器对象的函数——这点非常精妙并且重要。</p>
<p>可是普通对象没有内置的<code>@@iterator</code>，所以无法完成<code>for..of</code>遍历。制定者之所以这样做，有许多复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。</p>
<p>但我们可以给任何想遍历的对象自定义<code>@@iterator</code>，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="built_in">Symbol</span>.iterator, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    value: o[ks[idx++]],</span><br><span class="line">                    done: (idx &gt; ks.length)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 手动遍历 myObj</span></span><br><span class="line"><span class="keyword">var</span> it = myObj[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line">it.next()   <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next()   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next()   <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 for..of 遍历 myObj</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> myObj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="对象的代理Proxy"><a href="#对象的代理Proxy" class="headerlink" title="对象的代理Proxy"></a>对象的代理Proxy</h4><p>ES6 中引入的 Proxy 是一个元编程的特性。元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。</p>
<p>Proxy 对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。也就说它可以 “代理” 对象的原生行为，替换为执行自定义行为。</p>
<p>Proxy语法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>new Proxy()</code>表示生成一个Proxy实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>举个栗子，我们知道当我们要获取对象的属性值的时候，对象内部会调用 get 方法去获取这个属性，如果该属性不存在在该对象中，则会继续向 [[Prototype]] 原型链向上寻找，一直找到 Object.prototype。</p>
<p>如果我们按上一节的方法给该属性设置了<code>get()</code>方法，则查询该属性值时会返回<code>get()</code> 方法的返回值。Proxy 可以给所有查询不到的属性设置统一的<code>get()</code>方法。</p>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.x <span class="comment">// 2</span></span><br><span class="line">obj.y <span class="comment">// 3</span></span><br><span class="line">obj.z <span class="comment">// 3</span></span><br><span class="line">a.y <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a,&#123;&#125;)</span><br><span class="line"></span><br><span class="line">obj.y = <span class="number">3</span></span><br><span class="line">a.y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>有一个技巧是把 Proxy 实例作为其他对象的原型对象，这样就可以让其他对象继承（或者说委托？）Proxy 实例的拦截方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span> (&#123;&#125;,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"></span><br><span class="line">a.someprop <span class="comment">// 233</span></span><br></pre></td></tr></table></figure></p>
<p>此外，Proxy 对象还提供了一个revoke方法，可以随时注销所有的代理操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = p.proxy</span><br><span class="line">a.x <span class="comment">// 1</span></span><br><span class="line">p.revoke()</span><br><span class="line">a.x <span class="comment">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure></p>
<p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是 Proxy 实例，<code>revoke</code>属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行<code>revoke</code>函数之后，再访问 Proxy 实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<p>包括 <code>get()</code>、<code>set()</code> 在内，Proxy 支持的拦截操作有十多种，包含了大部分对象的方法操作的拦截。具体请查阅 ECMAScript 6 入门 及 MDN 文档</p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><h4 id="原型相关-create-setPrototypeOf-getPrototypeOf"><a href="#原型相关-create-setPrototypeOf-getPrototypeOf" class="headerlink" title="原型相关 create,setPrototypeOf,getPrototypeOf"></a>原型相关 create,setPrototypeOf,getPrototypeOf</h4><h5 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [ propertiesObject ])"></a>Object.create(proto, [ propertiesObject ])</h5><p>该方法使用指定的原型对象和其属性创建了一个新的对象。可理解为该方法会创建一个对象并把这个对象的 [[Prototype]]关联到指定对象。</p>
<p>需要注意的是，<code>Object.create(null)</code>会创建一个拥有空（或者 null）[[Prototype]] 链的对象，这个对象无法进行委托。由于这个对象没有原型链，所以<code>instanceof</code>操作符无法进行判断，因此总是返回 false。这些特殊的空 [[Prototype]] 对象通常被称作“字典”，他们完全不会受到原型链的干扰，因此非常适合用来储存数据。</p>
<h5 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h5><p>该方法是ES6的新方法，用于设置一个指定的对象的原型 ( 例如,内置的 [[Prototype]] 属性）到另一个对象或 null。可以代替 ES5 的<code>Object.create</code>。</p>
<p>例如有两个对象 a 和 b，我们需要把 b 设为 a 的原型，以便 a 可以继承 b 的属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</span><br><span class="line"></span><br><span class="line">a.x <span class="comment">//1</span></span><br><span class="line">a.y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a) <span class="comment">// ["x"]</span></span><br></pre></td></tr></table></figure></p>
<p>上例中把 b 设为 a 的原型，因此当向 a 查询 y 时，由于 a 本身没有 y 属性，所以会循着原型链查询到 b 的 y。</p>
<p>再例如有两个函数（函数也是对象哦！） Bar 和 Foo，我们需要把 Bar.prototype 关联到 Foo.prototype:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Foo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;<span class="keyword">this</span>.name = name&#125;</span><br><span class="line">Foo.prototype.sayName= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Bar</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name</span>)</span>&#123;Foo.call(<span class="keyword">this</span>, name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关联 prototype</span></span><br><span class="line"><span class="comment">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 开始可以直接修改现有的 Bar.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype, Foo.prototype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>)</span><br><span class="line">a.sayName()</span><br></pre></td></tr></table></figure></p>
<p>如果不考虑<code>Object.create(..)</code>方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它其实比 ES6 及其之后的方法更短切可读性更高。</p>
<h5 id="Object-getPrototypeOf-obj"><a href="#Object-getPrototypeOf-obj" class="headerlink" title="Object.getPrototypeOf(obj)"></a>Object.getPrototypeOf(obj)</h5><p>该方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。如果没有继承属性，则返回 null 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(b) === a <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;h4 id=&quot;简单做法&quot;&gt;&lt;a href=&quot;#简单做法&quot; class=&quot;headerlink&quot; title=&quot;简单做法&quot;&gt;&lt;/a&gt;简单做法&lt;/h4&gt;&lt;h5 id=&quot;使用Object构造函数创建&quot;&gt;&lt;a href=&quot;#使用Object构造函数创建&quot; class=&quot;headerlink&quot; title=&quot;使用Object构造函数创建&quot;&gt;&lt;/a&gt;使用Object构造函数创建&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对象实例的创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.key = &lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;//使用构造函数创建一个空对象，并赋值s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="对象" scheme="https://callmejay.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入数组</title>
    <link href="https://callmejay.github.io/2018/02/26/JavaScript%E6%B7%B1%E5%85%A5%E6%95%B0%E7%BB%84/"/>
    <id>https://callmejay.github.io/2018/02/26/JavaScript深入数组/</id>
    <published>2018-02-26T15:13:39.000Z</published>
    <updated>2018-03-07T15:17:14.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。<br><a id="more"></a><br><img src="http://oonulpk6h.bkt.clouddn.com/Array.png" alt="数组"></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><strong>length</strong><br>length属性表示数组的长度，即其中元素的个数。<br>JavaScript数组的length属性时可变的，当length属性被设置的更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大;当length属性被设置的比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。</p>
<p><strong>prptotype</strong><br>返回对象类型原型的引用。prototype属性是object共有的。<br>一般用来给数组实例添加方法。</p>
<p><strong>constructor</strong><br>表示创建对象的函数。<br>说明：constructor属性是所有具有prototype的对象的成员。constructor属性保存了对构造特定对象实例的函数的引用。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的创建</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 创建一个length为5的数组 [undefined, undefined, undefined, undefined, undefined]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 创建数组并赋值 [1,2,3]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">5</span>); <span class="comment">// 创建一个length为3的数组，并里面赋值均为5 [5,5,5] </span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">7</span>); <span class="comment">// 创建数组并赋值[7]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// 创建数组并赋值 [1,2,4]</span></span><br></pre></td></tr></table></figure>
<h5 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个对象是不是一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;&#125; <span class="comment">// 方法1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">'[object Array]'</span>) &#123;&#125;<span class="comment">// 方法2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr)) &#123;&#125; <span class="comment">// 方法3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(arr.constructor == <span class="built_in">Array</span>)&#123;&#125; <span class="comment">// 方法4</span></span><br></pre></td></tr></table></figure>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>Array.isArray(obj)</strong><br>检测对象是否Array,是则范湖true,否则为false.<br><strong>Array.from(arrayLike,mapFn,thisArg)</strong><br>该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg是可选参数，为执行 mapFn 函数时 this 的值。</p>
<p>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，<strong>任何有length属性的对象，都可以通过Array.from方法转为数组。</strong></p>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arrayLike2 = &#123;<span class="attr">length</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'abcd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArray = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a','b','c']</span></span><br><span class="line"><span class="keyword">let</span> newArray2 = <span class="built_in">Array</span>.from(arrayLike, (i) =&gt; &#123; i+ <span class="string">'1'</span>&#125;); <span class="comment">// ['a1','b1','c1']</span></span><br><span class="line"><span class="keyword">let</span> newArray3= <span class="built_in">Array</span>.from(arrayLike2); <span class="comment">// [undefined,undefined,undefined]</span></span><br><span class="line"><span class="keyword">let</span> newArray4= <span class="built_in">Array</span>.from(str); <span class="comment">// ['a','b','c','d']</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Array.of(item…)</strong><br>该方法用于创建数组实例。该方法用于替代 Array() 或 new Array()。Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// [7] </span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>);          <span class="comment">// [ , , , , , , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="数组实例方法"><a href="#数组实例方法" class="headerlink" title="数组实例方法"></a>数组实例方法</h4><h5 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h5><p><strong>arr.join(separator)</strong><br>把数组构构造成字符串，它先把数组中的每个元素转换成字符串，然后再用 separator 分隔符把它们链接在一起，separator 分隔符默认是逗号 “,”，要想做到无间隔链接，可以使用空字符串作为 separator：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.join(<span class="string">'|'</span>) <span class="comment">//"1|2|3|4|5"</span></span><br><span class="line">arr.join(<span class="string">""</span>) <span class="comment">//12345</span></span><br><span class="line"><span class="comment">//另所有对象有具有的 toLocaleString、toString、valueOf，可以看作是join的特殊用法，不常用</span></span><br></pre></td></tr></table></figure></p>
<h5 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h5><p><strong>arr.push(item…)</strong><br>将一个或多个新元素添加到数组结尾，并返回数组新长度。<br><strong>arr.pop()</strong><br>移除最后一个元素并返回该元素值。</p>
<h5 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h5><p><strong>arr.unshift(item…)</strong><br>将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度。<br><strong>arr.shift()</strong><br>移除第一个元素并返回该元素值，数组中元素自动前移.如果这个数组是空的，它会返回 undefined。shift 通常比 pop 慢的多。</p>
<h5 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h5><p><strong>arr.reverse()</strong><br>反转数组的顺序。<br><strong>arr.sort(compareFn)</strong><br>给数组排序，默认升序。</p>
<p>注意： sort 默认会将数组内容视为字符串来排序，所以对数字排序时默认的排序规则会错的离谱。一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数，如果两个参数相等则返回0，如果第一个参数应该排在前面则返回一个负数，如果第二个参数应该排在前面则返回一个正数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组排序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<h5 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h5><p><strong>arr.concat(item…)</strong><br>该方法产生一份 arr 的浅复制，并将多个数组（也可以是字符串，或者是数组和字符串的混合）附加在其后连接为一个数组，返回连接好的新的数组。</p>
<p><strong>arr.slice(start, end)</strong><br>该方法对数组中的一段做浅复制，首先复制数组 arr[start] 至 arr[end] 的部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素（或者理解成 end 的默认值为 arr.length）。字符串也有个同名方法 string.slice。</p>
<p><strong>arr.splice(start, deleteCount, item…)</strong><br>该方法从 arr 中移除一个或多个元素，并将新的 item 插入至移除元素的开始位置， 参数 start 是移除元素的开始位置，deleteCount 是要移除的元素的个数，item 是要被插入的元素。它返回一个包含被移除元素的数组。</p>
<p><strong>arr.copyWithin(target, start, end)</strong><br>该方法复制数组的一部分到同一数组中的另一个位置（会覆盖原成员），并返回修改后的数组。使用这个方法，会修改当前数组。参数 target 为开始替换数据的位置，若 target 大于等于 arr.length，将会不发生拷贝。start 是可选参数，为开始读取数据的位置，默认为0。end 是可选参数，为停止读取数据的位置，默认为 arr.length。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p><strong>arr.fill(value, start, end)</strong><br>该方法使用给定值填充一个数组，参数 value 是用来填充数组的值。start 是可选参数，为填充开始位置，默认为 0。end 是可选参数，为填充的结束位置，默认为 arr.length。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>)            <span class="comment">// [4, 4, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">4</span>, <span class="number">1</span> , <span class="number">2</span>)            <span class="comment">// [1, 4, 3]</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 位置方法</span></span><br><span class="line"><span class="string">**arr.indexOf(searchElement,start)**</span></span><br><span class="line"><span class="string">该方法返回要查找的项在数组中的位置，如果没找到返回 -1。接受两个参数，searchElement 是要查找的项，start 是查找起始位置的索引，默认是0。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**arr.lastIndexOf(searchElement, start)**</span></span><br><span class="line"><span class="string">从 start 位置开始向前查找，start 默认值为 arr.length – 1。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意该方法在比较查找项与数组中每一项时，会使用全等操作符，也就是要求查找的项必须严格相等。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**arr.includes(searchElement, fromIndex)**</span></span><br><span class="line"><span class="string">该方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。参数 searchElement 为需要查找的元素值。参数 fromIndex 是可选参数，从该索引处开始查找 searchElement，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索，默认为 0。 如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索。</span></span><br><span class="line"><span class="string">该方法属于ES7，但Babel转码器已经支持。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log([].includes.call(<span class="built_in">arguments</span>, <span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([].includes.call(<span class="built_in">arguments</span>, <span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p><strong>arr.every(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。callback 被调用时传入三个参数：元素值，元素的索引，原数组。thisArg 为可选参数，指定执行 callback 时使用的 this 值。</p>
<p><strong>arr.some(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，如果该函数对任意一项返回true,则返回true。</p>
<p><strong>arr.filter(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p>
<p><strong>arr.forEach(callback)</strong><br>对数组中的每一项运行给定函数，这个函数没有返回值。本质上和使用for一样。</p>
<p><strong>arr.map(callback)</strong><br>对数组中的每一项运行给定的函数，返回每次函数调用后结果组成的数组。</p>
<p><strong>arr.find(callback,thisArg)</strong><br>该方法对数组所有成员依次执行callback函数，直到找出第一个返回值为true的成员并返回。如果没有，则返回undefined.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-5</span>,<span class="number">19</span>].find(<span class="function">(<span class="params">v,i,arr</span>) =&gt;</span> v &lt; <span class="number">0</span>) <span class="comment">// -5</span></span><br></pre></td></tr></table></figure></p>
<p><strong>arr.findIndex(callback, thisArg)</strong><br>该方法与 arr.find() 类似，对数组中的成员依次执行 callback 函数，直至找到第一个返回值为 true 的成员，然后返回该成员的索引。如果没有符合条件的成员，则返回 -1。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function">(<span class="params">v, i , arr</span>)=&gt;</span>  v &gt; <span class="number">9</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>arr.entries()</strong><br><strong>arr.keys()</strong><br><strong>arr.values()</strong><br>这三个方法都返回一个新的Array iterator对象，可以用<code>for...of</code>循环进行遍历，区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123; <span class="built_in">console</span>.log(index); &#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123; <span class="built_in">console</span>.log(elem) ;&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123; <span class="built_in">console</span>.log(index, elem);&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries(); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(iterator); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);  <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);  <span class="comment">// [1, "b"]</span></span><br></pre></td></tr></table></figure></p>
<h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><p><strong>arr.reduce(callback,initialValue)</strong><br><strong>arr.reduceRight(callback,initialValue)</strong><br>这个两个方法都会迭代数组所有的项，然后返回一个最终值。reduce()方法从数组的第一项开始，逐个遍历到最后，而reduceRight()则从数组的最后一项开始，向前遍历到第一项。它们接受两个参数，callback 每一项上调用的函数，callback 被调用时传入四个参数：上一次调用回调返回的值、正在处理的元素、正在处理的元素的索引值（如果提供了 initialValue ，从0开始；否则从1开始）、原数组。initialValue 是可选项，作为归并基础的初始值，其值用于第一次调用 callback 的第一个参数。</p>
<h3 id="数组常见问题练习"><a href="#数组常见问题练习" class="headerlink" title="数组常见问题练习"></a>数组常见问题练习</h3><h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><h5 id="多个一维数组合并"><a href="#多个一维数组合并" class="headerlink" title="多个一维数组合并"></a>多个一维数组合并</h5><p>如有两个一维数组，要将他们合并成一个数组:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// =&gt; [1,2,3,4]</span></span><br></pre></td></tr></table></figure></p>
<p>Array.prototype.concat()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = arr1.concat(arr2) <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>
<p>for循环和Array.prototype.push()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flation</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">        arr1.push(arr2[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>reduce()或reduceRight()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span> (<span class="params">arr1,arr2</span>)</span>&#123;</span><br><span class="line">    arr2.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,curr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.push(curr);</span><br><span class="line">    &#125;,arr1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="多维（复合）数组合并成一维数组"><a href="#多维（复合）数组合并成一维数组" class="headerlink" title="多维（复合）数组合并成一维数组"></a>多维（复合）数组合并成一维数组</h5><p>例如有这么一组多维数组，要把它拍平成1维数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></span><br></pre></td></tr></table></figure></p>
<p>Array.prototype.push()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unction flatten(arr, result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].constructor == <span class="built_in">Array</span>) &#123;</span><br><span class="line">            flatten(arr[i], r)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></span><br></pre></td></tr></table></figure></p>
<p>Array.prototype.concat()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略对二维以上数组的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        result = result.concat(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9] </span></span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="number">10</span>,<span class="number">11</span>]);<span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure></p>
<p>可以通过Function.prototype.apply()方法，让其变得更简单:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略对二维以上数组的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ES6 中，还可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略对二维以上数组的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].concat(...arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要处理三维或更多维数组，则需要加一些判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    arr = [].concat.apply([], arr)</span><br><span class="line">    <span class="keyword">return</span> arr.some(<span class="built_in">Array</span>.isArray) ? flatten(arr) : arr</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></span><br></pre></td></tr></table></figure></p>
<p>使用join()和split()<br>利用数组实例的join()方法和字符串实例的split()方法，也可以将多维数组拍平：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">','</span>).split(<span class="string">','</span>)</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="comment">//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"]</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。</p>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><h5 id="双重循环去重"><a href="#双重循环去重" class="headerlink" title="双重循环去重"></a>双重循环去重</h5><p>思路：</p>
<ul>
<li>构建一个空数组来存放去重后的数组</li>
<li>对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比</li>
<li>如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    result[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> repeat = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j= <span class="number">0</span>;j&lt;result.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == result[j]) &#123;</span><br><span class="line">                repeat = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!repeat) &#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, "a", "b"]</span></span><br></pre></td></tr></table></figure>
<p>这种方法也可以采用forEach()方法和indexOf()方法模拟实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    result[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.includes(item)) result.push(item);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="排序遍历去重"><a href="#排序遍历去重" class="headerlink" title="排序遍历去重"></a>排序遍历去重</h5><p>思路：</p>
<ul>
<li>构建一个空数组来存放去重后的数组</li>
<li>用<code>sort()</code>方法对原数组做一个排序，排完序后对数组做遍历，检测数组中第i个元素与结果数组中的最后一个元素是否相同，如果不同，则放到结果数组中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    arr.sort();</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    arr.forEach( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item !== result[result.length <span class="number">-1</span>]) &#123;</span><br><span class="line">            result.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</span><br></pre></td></tr></table></figure>
<p>这种方法有两个特色：</p>
<ul>
<li>去重后的数组会做排序，主要是因为原数在去重前做了排序</li>
<li>去重后的数组，与数字相同的数字字符无法区分，比如‘1’和1</li>
</ul>
<h5 id="对象键值对法"><a href="#对象键值对法" class="headerlink" title="对象键值对法"></a>对象键值对法</h5><p>思路：</p>
<ul>
<li>创建一个js对象及新数组</li>
<li>遍历原数组，每次取出一个元素与js对象的键做对比</li>
<li>如果不包含，将存入对象的元素的值推入到结果数组中，并将object对象中该属性名的值设为1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">var</span> object = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!object[<span class="keyword">typeof</span>(arr[i]) + arr[i]]) &#123;  <span class="comment">//键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1`</span></span><br><span class="line">            result.push(arr[i])</span><br><span class="line">            object[<span class="keyword">typeof</span>(arr[i]) + arr[i]] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, "a", "b"]</span></span><br></pre></td></tr></table></figure>
<p>这种方法比较耗内存，但运行下来耗时最少，是较为优秀的方案。</p>
<h5 id="使用ES6的Set和Map方法"><a href="#使用ES6的Set和Map方法" class="headerlink" title="使用ES6的Set和Map方法"></a>使用ES6的Set和Map方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助Map数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !seen.has(item) &amp;&amp; seen.set(item,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助 Set 数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="comment">//或 return [...new Set(arr)]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, "1", "a", "b"]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h4><h5 id="递归的方法"><a href="#递归的方法" class="headerlink" title="递归的方法"></a>递归的方法</h5><p>思路:<br>不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr,newArr = []</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果原数组只有一个值</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        newArr.push(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> newArr; <span class="comment">// 递归结束</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> random = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*arr.length<span class="number">-1</span>);</span><br><span class="line">    newArr.push(arr[random]);</span><br><span class="line">    arr.splice(random,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> randomSort(arr,newArr);</span><br><span class="line">&#125;</span><br><span class="line">randomSort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">//[2, 3, 1, 5, 6, 7, 4]</span></span><br><span class="line">randomSort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">//[3, 4, 2, 5, 1, 6, 7]</span></span><br></pre></td></tr></table></figure></p>
<h5 id="随机交换数组内的元素-原理from-underscore-js）"><a href="#随机交换数组内的元素-原理from-underscore-js）" class="headerlink" title="随机交换数组内的元素 (原理from underscore.js）"></a>随机交换数组内的元素 (原理from underscore.js）</h5><p>思路：<br>遍历数组，每次从i位置后元素随机挑一个放到i位置，将原i位置元素放至被挑元素位置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">        arr = <span class="keyword">this</span>.slice(<span class="number">0</span>),</span><br><span class="line">        temp, index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        index = i + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - i))</span><br><span class="line">        [arr[i],arr[index]] = [arr[index],arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="随机从原数组抽取一个元素-加入到新数组"><a href="#随机从原数组抽取一个元素-加入到新数组" class="headerlink" title="随机从原数组抽取一个元素,加入到新数组"></a>随机从原数组抽取一个元素,加入到新数组</h5><p>思路：<br>遍历数组，每次从数组中随机挑一个元素（随机数最大值为原数组剩余长度），将该元素拿出来放入新数组。<br>```js<br>Array.prototype.shuffle = function() {<br>    var len = this.length,<br>        arr = this.slice(0),<br>        result = [],<br>        index;<br>    for (var i = 0; i &lt; len; i++) {<br>        index = Math.floor(Math.random() * (len - i))<br>        result.push(arr.splice(index, 1)[0])<br>    }<br>    return result;1<br>}<br>[1, 2, 3, 4, 5, 6, 7].shuffle()<br>//[5, 3, 2, 1, 7, 4, 6]</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="Array" scheme="https://callmejay.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入之继承的多种方式</title>
    <link href="https://callmejay.github.io/2018/02/26/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://callmejay.github.io/2018/02/26/JavaScript深入之继承的多种方式/</id>
    <published>2018-02-26T12:55:14.000Z</published>
    <updated>2018-02-26T15:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Jay'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// Jay</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>存在的问题：<br>1，引用类型的属性被所有的实例共享，eg:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">"Jhon"</span>,<span class="string">"Michel"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'Lili'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></span><br></pre></td></tr></table></figure></p>
<p>2，在创建Child的实例时，不能向Parent传参</p>
<h3 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.names = [<span class="string">"Jhon"</span>,<span class="string">"Michel"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">'Lili'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["Jhon","Michel"]</span></span><br></pre></td></tr></table></figure>
<p>优点：<br>1，避免了引用类型的属性被所有实例共享。<br>2，可以在Child中间向Parent传参. eg:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>,name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kaer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kaer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'james'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// james</span></span><br></pre></td></tr></table></figure></p>
<p>缺点：<br>方法都在构造函数里定义，每次创建实例都会创建一遍方法。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>原型链继承和经典继承的组合。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'cyan'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'xiaoming'</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name,child1.age,child1.colors); <span class="comment">// xiaoming 20 ["red", "cyan", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'david'</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name,child2.age,child2.colors); <span class="comment">// david 23 ["red", "cyan"]</span></span><br></pre></td></tr></table></figure></p>
<p>优点：融合原型链继承和构造函数的优点，是JavaScript中最常用的继承模式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是ES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：<br>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure></p>
<p>注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的name值，而是因为person1.name = ‘person1’，给person1添加了name值，并非修改了原型上的name值.</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缺点: 跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承最大的缺点就是虎调用两次父构造函数。<br>一次是设置子类型实例的原型的时候：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure></p>
<p>一次是在创建子类型实例的时候：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'david'</span>,<span class="number">23</span>);</span><br></pre></td></tr></table></figure></p>
<p>回想下new的模拟实现，其实在这句中，我们会执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>,name);</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们又会调用了一次Parent构造函数。<br>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[‘red’, ‘blue’, ‘green’]。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>
<p>看看如何实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'cyan'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>,name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype  = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child1 = <span class="keyword">new</span> Child(<span class="string">'david'</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure></p>
<p>最后封装一下这个函数方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    functin F () &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span> (<span class="params">child,parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候</span></span><br><span class="line">prototype(Child,Parent);</span><br></pre></td></tr></table></figure></p>
<p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<blockquote>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = &lt;span class=&quot;string&quot;&gt;&#39;Jay&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Parent.prototype.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Child.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Parent();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; child1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(child1.getName()); &lt;span class=&quot;comment&quot;&gt;// Jay&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="继承" scheme="https://callmejay.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础3</title>
    <link href="https://callmejay.github.io/2018/02/21/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%803/"/>
    <id>https://callmejay.github.io/2018/02/21/快速掌握JavaScript面试基础3/</id>
    <published>2018-02-21T08:49:21.000Z</published>
    <updated>2018-02-22T09:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>如果使用new关键字来调用函数式很特别的形式。我们把那些用new调用的函数叫做构造函数(constructor function)。</p>
<p>使用了new的函数到底做了什么事情呢？</p>
<ul>
<li>创建一个新的对象</li>
<li>将对象的prototype设置为构造函数的prototype</li>
<li>执行构造函数，this执行新构造的对象</li>
<li>返回该对象。如果构造函数返回对象，那么返回该构造对象。<a id="more"></a>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了更好地理解底层，我们来定义new关键字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">constructor, ...arguments</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">constructor</span>.prototype);</span><br><span class="line">  return <span class="keyword">constructor</span>.apply(obj, arguments) || obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用new和不使用的区别在哪里呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wings = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 普通的函数调用 */</span></span><br><span class="line"><span class="keyword">let</span> fakeBird = Bird();</span><br><span class="line"><span class="built_in">console</span>.log(fakeBird);    <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">/* 使用new调用 */</span></span><br><span class="line"><span class="keyword">let</span> realBird= <span class="keyword">new</span> Bird();</span><br><span class="line"><span class="built_in">console</span>.log(realBird)     <span class="comment">// &#123; wings: 2 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>为了便于对比理解，译者额外增加了测试了一种情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MBird</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wings =<span class="number">2</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> realMBrid = <span class="keyword">new</span> MBird();</span><br><span class="line"><span class="built_in">console</span>.log(realMBird) <span class="comment">// &#123; wings: 2 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>你会发现，这一句return “hello”并没有生效！</p>
<h3 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h3><p>原型(Prototype)是JavaScript中最容易搞混的概念，其中一个原因是prototype可以用在两个不同的情形下。</p>
<ul>
<li><p>原型关系<br>每一个对象都有一个prototype对象，里面包含了所有它的原型的属性。<br>.__proto__是一个不正规的机制(ES6中提供)，用来获取一个对象的prototype。你可以理解为它指向对象的parent。<br>所有普通的对象都继承.constructor属性，它指向该对象的构造函数。当一个对象通过构造函数实现的时候，__proto__属性指向构造函数的构造函数的.prototype。Object.getPrototypeOf()是ES5的标准函数，用来获取一个对象的原型。</p>
</li>
<li><p>原型属性<br>每一个函数都有一个.prototype属性，它包含了所有可以被继承的属性。该对象默认包含了指向原构造函数的.constructor属性。每一个使用构造函数创建的对象都有一个构造函数属性。</p>
</li>
</ul>
<p>接下来通过例子来帮助理解：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">breed, name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.breed = breed,</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.describe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is a <span class="subst">$&#123;<span class="keyword">this</span>.breed&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> rusty = <span class="keyword">new</span> Dog(<span class="string">'Beagle'</span>, <span class="string">'Rusty'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* .prototype 属性包含了构造函数以及构造函数中在prototype上定义的属性。*/</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype)  <span class="comment">// &#123; describe: ƒ , constructor: ƒ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用Dog构造函数构造的对象 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty)   <span class="comment">//  &#123; breed: "Beagle", name: "Rusty" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从构造函数的原型中继承下来的属性或函数 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty.describe())   <span class="comment">// "Rusty is a Beagle"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* .__proto__ 属性指向构造函数的.prototype属性 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty.__proto__)    <span class="comment">// &#123; describe: ƒ , constructor: ƒ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* .constructor 属性指向构造函数 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty.constructor)  <span class="comment">// ƒ Dog(breed, name) &#123; ... &#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是指对象之间通过prototype链接起来，形成一个有向的链条。当访问一个对象的某个属性的时候，JavaScript引擎会首先查看该对象是否包含该属性。如果没有，就去查找对象的prototype中是否包含。以此类推，直到找到该属性或则找到最后一个对象。最后一个对象的prototype默认为null。</p>
<h3 id="拥有vs继承"><a href="#拥有vs继承" class="headerlink" title="拥有vs继承"></a>拥有vs继承</h3><p>一个对象有两种属性，分别是它自身定义的和继承的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">Car.prototype.wheels = <span class="number">4</span>;</span><br><span class="line">Car.prototype.airbags = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line">myCar.color = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  原型链中的属性也可以通过in来查看:  */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'airbags'</span> <span class="keyword">in</span> myCar)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.wheels)        <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.year)          <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  通过hasOwnProperty来查看是否拥有该属性:  */</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.hasOwnProperty(<span class="string">'airbags'</span>))  <span class="comment">// false — Inherited</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.hasOwnProperty(<span class="string">'color'</span>))    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>Object.create(obj) 创建一个新的对象，prototype指向obj。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123; <span class="attr">legs</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> myDog = <span class="built_in">Object</span>.create(dog);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myDog.hasOwnProperty(<span class="string">'legs'</span>))  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.legs)                    <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.__proto__ === dog)       <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="继承是引用传值"><a href="#继承是引用传值" class="headerlink" title="继承是引用传值"></a>继承是引用传值</h3><p>继承属性都是通过引用的形式。看例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objProt = &#123; <span class="attr">text</span>: <span class="string">'original'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> objAttachedToProt = <span class="built_in">Object</span>.create(objProt);</span><br><span class="line"><span class="built_in">console</span>.log(objAttachedToProt.text)   <span class="comment">// original</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们更改objProt的text属性，objAttachedToProt的text属性同样更改了</span></span><br><span class="line">objProt.text = <span class="string">'prototype property changed'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objAttachedToProt.text)   <span class="comment">// prototype property changed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果我们讲一个新的对象赋值给objProt，那么objAttachedToProt的text属性不受影响</span></span><br><span class="line">objProt = &#123; <span class="attr">text</span>: <span class="string">'replacing property'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objAttachedToProt.text)   <span class="comment">// prototype property changed</span></span><br></pre></td></tr></table></figure></p>
<h3 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a>异步JavaScript</h3><p>JavaScript是一个单线程程序语言，也就是说JavaScript引擎一次只能执行某一段代码。它导致的问题就是：如果有一段代码需要耗费很长的时间执行，其它的操作就被卡住了。JavaScript使用Call Stack来记录函数的调用。一个Call Stack可以看成是一摞书。最后一本书放在最上面，也最先被移走。最先放的书在最底层，最后被移走。</p>
<p>为了避免复杂代码占用CPU太长时间，一个解法就是定义异步回调函数。我们自己来定义一个异步函数看看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetingAsync</span>(<span class="params">name, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> greeting = <span class="string">"hello, "</span> + name ;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> callback(greeting),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetingAsync(<span class="string">"fundebug"</span>, <span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start greeting"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们在greetingAsync中构造了greeting语句，然后通过setTimeout定义了异步，callback函数，是为了让用户自己去定义greeting的具体方式。为方便起见，我们时候直接使用console.log。</p>
<p>上面代码执行首先会打印start greeting，然后才是hello, fundebug。也就是说，greetingAsync的回调函数后执行。在网站开发中，和服务器交互的时候需要不断地发送各种请求，而一个页面可能有几十个请求。如果我们一个一个按照顺序来请求并等待结果，串行的执行会使得网页加载很慢。通过异步的方式，我们可以先发请求，然后在回调中处理请求结果，高效低并发处理。</p>
<p>下面通过一个例子来描述整个执行过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'First message'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> second = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Second message'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> third = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Third message'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">setTimeout(second, <span class="number">0</span>);</span><br><span class="line">third();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line">  <span class="comment">// First message</span></span><br><span class="line">  <span class="comment">// Third message</span></span><br><span class="line">  <span class="comment">// Second message</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>初始状态下，浏览器控制台没有输出，并且事件管理器(Event Manager)是空的；</li>
<li>first()被添加到调用栈</li>
<li>将console.log(“First message”)加到调用栈</li>
<li>console.log(“First message”)执行并输出“First message”到控制台</li>
<li>console.log(“First message”)从调用栈中移除</li>
<li>first()从调用栈中移除</li>
<li>setTimeout(second, 0)加到调用栈</li>
<li>setTimeout(second, 0)执行，0ms之后，second()被加到回调队列</li>
<li>setTimeout(second, 0)从调用栈中移除</li>
<li>third()加到调用栈</li>
<li>console.log(“Third message”)加到调用栈</li>
<li>console.log(“Third message”)执行并输出“Third message”到控制台</li>
<li>console.log(“Third message”)从调用栈中移除</li>
<li>third()从调用栈中移除</li>
<li>Event Loop 将second()从回调队列移到调用栈</li>
<li>console.log(“Second message”)加到调用栈</li>
<li>console.log(“Second message”)Second message”到控制台</li>
<li>console.log(“Second message”)从调用栈中移除</li>
<li>Second()从调用栈中移除</li>
</ol>
<p>特别注意的是：second()函数在0ms之后并没有立即执行，你传入到setTimeout()函数的时间和second()延迟执行的时间并不一定直接相关。事件管理器等到setTimeout()设置的时间到期才会将其加入回调队列，而回调队列中它执行的时间和它在队列中的位置以及它前面的函数的执行时间有关。</p>
<p><a href="https://blog.fundebug.com/2018/01/29/the-definitive-javascript-handbook-for-a-developer-interview-3/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;new关键字&quot;&gt;&lt;a href=&quot;#new关键字&quot; class=&quot;headerlink&quot; title=&quot;new关键字&quot;&gt;&lt;/a&gt;new关键字&lt;/h3&gt;&lt;p&gt;如果使用new关键字来调用函数式很特别的形式。我们把那些用new调用的函数叫做构造函数(constructor function)。&lt;/p&gt;
&lt;p&gt;使用了new的函数到底做了什么事情呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的对象&lt;/li&gt;
&lt;li&gt;将对象的prototype设置为构造函数的prototype&lt;/li&gt;
&lt;li&gt;执行构造函数，this执行新构造的对象&lt;/li&gt;
&lt;li&gt;返回该对象。如果构造函数返回对象，那么返回该构造对象。
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础2</title>
    <link href="https://callmejay.github.io/2018/02/21/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802/"/>
    <id>https://callmejay.github.io/2018/02/21/快速掌握JavaScript面试基础2/</id>
    <published>2018-02-21T04:47:09.000Z</published>
    <updated>2018-02-22T09:18:00.940Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包由一个函数以及该函数定义式所在的环境组成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">`Hi <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greeting();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayHiToJon = sayHi(<span class="string">'Jon'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sayHiToJon)     <span class="comment">// ƒ() &#123; console.log(message) &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHiToJon())   <span class="comment">// 'Hi Jon!'</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>请理解<code>var sayHiToJon=sayHi(&#39;Jon&#39;)</code>;这段代码的执行过程，sayHi函数执行，首先将message的值计算出来，然后定义了greeting函数，函数中引用了message变量，最后，返回greeting函数。<br>如果按照C/Java语言的思路，sayHiToJon就等价于greeting函数，那么就会报错：message为定义。但是在JavaScript中不一样，这里的sayHiToJon函数等于greeting函数以及一个环境，该环境中包含了message。因此，当我们调用sayHiToJon函数，可以成功将message打印出来。因此，这里的闭包就是greeting函数和一个包含message变量的环境。</p>
<p>闭包的一个优势在于<strong>数据隔离</strong>，下面用一个例子说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpringfieldSchool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> staff = [<span class="string">'Seymour Skinner'</span>, <span class="string">'Edna Krabappel'</span>];</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getStaff: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(staff) &#125;,</span><br><span class="line">    addStaff: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; staff.push(name) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elementary = SpringfieldSchool()</span><br><span class="line"><span class="built_in">console</span>.log(elementary)        <span class="comment">// &#123; getStaff: ƒ, addStaff: ƒ &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(staff)             <span class="comment">// ReferenceError: staff is not defined</span></span><br><span class="line"><span class="comment">/* Closure allows access to the staff variable */</span></span><br><span class="line">elementary.getStaff()          <span class="comment">// ["Seymour Skinner", "Edna Krabappel"]</span></span><br><span class="line">elementary.addStaff(<span class="string">'Otto Mann'</span>)</span><br><span class="line">elementary.getStaff()          <span class="comment">// ["Seymour Skinner", "Edna Krabappel", "Otto Mann"]</span></span><br></pre></td></tr></table></figure></p>
<p>在elementary被创建的时候，SpringfieldSchool已经返回。也就是说staff无法被外部访问。唯一可以访问的方式就是里面的闭包函数getStaff和addStaff。</p>
<p>我们来看一个面试题：下面的代码有什么问题，如何修复？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The value <span class="subst">$&#123;arr[i]&#125;</span> is at index: <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">  &#125;, (i+<span class="number">1</span>) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出的结果全部都一样：”The value undefined is at index: 4”。因为所有在setTimeout中定义的匿名函数都引用了同一个外部变量i。当匿名函数执行的时候，i的值为4。</p>
<p>这个问题可以改用IIFE(后面会介绍)方法来解决，通过对每一个匿名函数构建独立的外部作用域来实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`The value <span class="subst">$&#123;arr[j]&#125;</span> is at index: <span class="subst">$&#123;j&#125;</span>`</span>);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，还有一个方法，使用let来声明i。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;'</span>)</span><br><span class="line">    &#125;,(i)*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="立即调用的函数表达式-Immediate-Invoked-Function-Expression-IIFE"><a href="#立即调用的函数表达式-Immediate-Invoked-Function-Expression-IIFE" class="headerlink" title="立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)"></a>立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)</h3><p>一个IIFE是一个函数表达式在定义之后立即被调用。常用在你想对一个新声明的变量创建一个隔离的作用域。<br>它的格式为:<code>(function(){....})()</code>。前面的大括号用于告诉编译器这里不仅仅是函数定义，后面的大括号用于执行该函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i &#125; );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( result[<span class="number">1</span>]() ); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log( result[<span class="number">3</span>]() ); <span class="comment">// 5</span></span><br><span class="line">result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i; <span class="comment">// copy current value of i</span></span><br><span class="line">    result.push( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> j &#125; );</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( result[<span class="number">1</span>]() ); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( result[<span class="number">3</span>]() ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>使用IIFE可以：</p>
<ul>
<li>为函数绑定私有数据</li>
<li>创建一个新的环境</li>
<li>避免污染全局命名空间</li>
</ul>
<h3 id="环境（Context）"><a href="#环境（Context）" class="headerlink" title="环境（Context）"></a>环境（Context）</h3><p>我们往往容易将环境（Context）和作用域（Scope）搞混，解释一下：</p>
<ul>
<li><strong>环境（Context）</strong>：由函数如何被调用而决定，往往指this.</li>
<li><strong>作用域（Scope）</strong>：可访问的变量。</li>
</ul>
<h3 id="函数调用：call-apply-bind"><a href="#函数调用：call-apply-bind" class="headerlink" title="函数调用：call, apply, bind"></a>函数调用：call, apply, bind</h3><p>这三个方法都是为了将this绑定到函数，区别在于调用的方式。</p>
<ul>
<li>.call(a,b,c,d…)会理解执行函数，需要把参数按照顺序传入；</li>
<li>.apply([a,b,c,d…])会理解执行函数，需要把参数组合成数组传入了；</li>
</ul>
<p>.call()和.apply()几乎相同。哪个传入参数方便，你就选择哪个。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snow = &#123;<span class="attr">surename</span>: <span class="string">'Snow'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> char = &#123;</span><br><span class="line">  surename: <span class="string">'Stark'</span>,</span><br><span class="line">  knows: <span class="function"><span class="keyword">function</span>(<span class="params">arg, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You know <span class="subst">$&#123;arg&#125;</span>, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surename&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">char.knows(<span class="string">'something'</span>, <span class="string">'Bran'</span>);              <span class="comment">// You know something, Bran Stark</span></span><br><span class="line">char.knows.call(Snow, <span class="string">'nothing'</span>, <span class="string">'Jon'</span>);      <span class="comment">// You know nothing, Jon Snow</span></span><br><span class="line">char.knows.apply(Snow, [<span class="string">'nothing'</span>, <span class="string">'Jon'</span>]);   <span class="comment">// You know nothing, Jon Snow</span></span><br></pre></td></tr></table></figure></p>
<p>注意：如果你将数组传入call函数，它会认为只有一个参数。</p>
<p>ES6允许使用新的操作符将数组变换为一个序列。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char.knows.call(Snow, ...[<span class="string">"nothing"</span>, <span class="string">"Jon"</span>]);  <span class="comment">// You know nothing, Jon Snow</span></span><br></pre></td></tr></table></figure></p>
<p>.bind()返回一个新的函数，以及相应的环境和参数。如果你想该函数稍后调用，那么推荐使用bind。<br>.bind()函数的优点在于它可以记录一个执行环境，对于异步调用和事件驱动的编程很有用。</p>
<p>.bind()传参数的方式和call相同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snow = &#123;<span class="attr">surename</span>: <span class="string">'Snow'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> char = &#123;</span><br><span class="line">  surename: <span class="string">'Stark'</span>,</span><br><span class="line">  knows: <span class="function"><span class="keyword">function</span>(<span class="params">arg, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You know <span class="subst">$&#123;arg&#125;</span>, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surename&#125;</span>`</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> whoKnowsNothing = char.knows.bind(Snow, <span class="string">'nothing'</span>);</span><br><span class="line">whoKnowsNothing(<span class="string">'Jon'</span>);  <span class="comment">// You know nothing, Jon Snow</span></span><br></pre></td></tr></table></figure></p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>要理解JavaScript中this关键字，特别是它指向谁，有时候相当地复杂。this的值通常由函数的执行环境决定。简单的说，执行环境指函数如何被调用的。this像是一个占位符(placeholder)，它指向当方法被调用时，调用对应的方法的对象。</p>
<p>下面有序地列出了判断this指向的规则。如果第一条匹配，那么就不用去检查第二条了。</p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>当使用new关键字调用函数的时候，this指向新构建的对象(实例)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> = Rachel = <span class="keyword">new</span> Person(<span class="string">'Rachel'</span>,<span class="number">30</span>); <span class="comment">// &#123;name: 'Rachel',age: 30&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="显示绑定-Explicit-binding"><a href="#显示绑定-Explicit-binding" class="headerlink" title="显示绑定(Explicit binding)"></a>显示绑定(Explicit binding)</h4><p>当使用call或则apply的时候，我们显示的传入一个对象参数，该参数会绑定到this。 注意：.bind()函数不一样。用bind定义一个新的函数，但是依然绑定到原来的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> agent = &#123;<span class="attr">id</span>: <span class="string">'007'</span>&#125;;</span><br><span class="line">fn.call(agent);    <span class="comment">// &#123; id: '007' &#125;</span></span><br><span class="line">fn.apply(agent);   <span class="comment">// &#123; id: '007' &#125;</span></span><br><span class="line"><span class="keyword">var</span> boundFn = fn.bind(agent);</span><br><span class="line">boundFn();         <span class="comment">// &#123; id: '007' &#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>当一个函数在某个环境下调用(在某个对象里)，this指向该对象。也就是说该函数是对象的一个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> building = &#123;</span><br><span class="line">  floors: <span class="number">5</span>,</span><br><span class="line">  printThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">building.printThis();  <span class="comment">// &#123; floors: 5, printThis: function() &#123;…&#125; &#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>如果上面所有的规则都不满足，那么this指向全局对象(在浏览器中，就是window对象)。当函数没有绑定到某个对象，而单独定义的时候，该函数默认绑定到全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">printWindow();  <span class="comment">// window object</span></span><br></pre></td></tr></table></figure></p>
<p>注意：下面的情况中，inner函数中的this指向全局。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dinosaur</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  inner();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>);        <span class="comment">// window object — the function has overwritten the 'this' context</span></span><br><span class="line">    <span class="built_in">console</span>.log(self);  <span class="comment">// &#123;name: 'Dino'&#125; — referencing the stored value from the outer context</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myDinosaur = <span class="keyword">new</span> Dinosaur(<span class="string">'Dino'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="词法-Lexical-this"><a href="#词法-Lexical-this" class="headerlink" title="词法(Lexical) this"></a>词法(Lexical) this</h4><p>当是使用<code>=&gt;</code>来定义函数时，this指向定义该函数时候外层的this。<br>备注：大概是和定义的词法(=&gt;)有关，把它称作Lexical this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);   <span class="comment">// &#123; name: 'Garfield' &#125;</span></span><br><span class="line">  ( <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>) )();   <span class="comment">// &#123; name: 'Garfield' &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Cat(<span class="string">'Garfield'</span>);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.fundebug.com/2018/01/22/the-definitive-javascript-handbook-for-a-developer-interview-2/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h3&gt;&lt;p&gt;闭包由一个函数以及该函数定义式所在的环境组成。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;`Hi &lt;span class=&quot;subst&quot;&gt;$&amp;#123;name&amp;#125;&lt;/span&gt;`&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;greeting&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; greeting();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sayHiToJon = sayHi(&lt;span class=&quot;string&quot;&gt;&#39;Jon&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sayHiToJon)     &lt;span class=&quot;comment&quot;&gt;// ƒ() &amp;#123; console.log(message) &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sayHiToJon())   &lt;span class=&quot;comment&quot;&gt;// &#39;Hi Jon!&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础1</title>
    <link href="https://callmejay.github.io/2018/02/20/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%801/"/>
    <id>https://callmejay.github.io/2018/02/20/快速掌握JavaScript面试基础1/</id>
    <published>2018-02-20T10:15:33.000Z</published>
    <updated>2018-02-22T09:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类型和类型转换"><a href="#类型和类型转换" class="headerlink" title="类型和类型转换"></a>类型和类型转换</h3><p>在JavaScript中有7个内置类型：null,undefined,boolean,number,string,object和symbol（ES6)。</p>
<p>除了object以外，其他都叫做基本类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">0</span> <span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'Hi'</span>) <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<ul>
<li>Null vs. Undefined</li>
</ul>
<p><strong>Undefined</strong>表示未定义。对于没有初始化的变量，函数调用时未提供的函数参数，不存在的对象属性，它们的默认值就是undefined。如果一个函数没有返回语句，那么默认的返回值也是undefined。</p>
<p><strong>Null</strong>表示值为空。一个变量我们可以将其赋值为null,表示当前没有值。</p>
<ul>
<li>隐士转换</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Joey'</span>;</span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">" doesn't share food!"</span>)  <span class="comment">// Joey doesn’t share food!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在if语句的条件判断中，name从字符串转换为布尔型。在if的代码块中，在控制台将name原原本本打印出来。你知道在什么情况下字符串会转换为真，什么时候为假么？</p>
<p><code>&quot;&quot;，0， null，undefined, NaN, false 会自动转换为false</code>。其它的都会转换为真：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>)         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'hello'</span>)      <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'0'</span>)          <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">' '</span>)          <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>([])           <span class="comment">// true </span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>空数组、对象、函数定义都会自动转换为真。</p>
<ul>
<li>String &amp; Number之间的转换</li>
<li>第一个你要非常小心的是<code>+</code>操作符。因为它同时用于数字相加和字符串拼接。</li>
</ul>
<p><code>*,/,-</code>只用于数字运算，当这些操作符和字符串一起使用，那么字符串会被强制转换为数字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">"2"</span> = <span class="string">"12"</span></span><br><span class="line"><span class="string">""</span> + <span class="number">1</span> + <span class="number">0</span> = <span class="string">"10"</span></span><br><span class="line"><span class="string">""</span> - <span class="number">1</span> + <span class="number">0</span> = <span class="number">-1</span></span><br><span class="line"><span class="string">"-9\n"</span> + <span class="number">5</span> = <span class="string">"-9\n5"</span></span><br><span class="line"><span class="string">"-9\n"</span> - <span class="number">5</span> = <span class="number">-14</span></span><br><span class="line"><span class="string">"2"</span> * <span class="string">"3"</span> = <span class="number">6</span></span><br><span class="line"><span class="number">4</span> + <span class="number">5</span> + <span class="string">"px"</span> = <span class="string">"9px"</span></span><br><span class="line"><span class="string">"$"</span> + <span class="number">4</span> + <span class="number">5</span> = <span class="string">"$45"</span></span><br><span class="line"><span class="string">"4"</span> - <span class="number">2</span> = <span class="number">2</span></span><br><span class="line"><span class="string">"4px"</span> - <span class="number">2</span> = <span class="literal">NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>== vs. ===</li>
</ul>
<p>一个广泛被接受的认知就是：==判断值是否相等，===同时判断值是否相等和类型是否相同。但是，这里有些误解。</p>
<p>实际上，==在验证相等性的时候，会对类型不同的值做一个类型转换。===对要判断的值不做类型转换。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> == <span class="string">'2'</span>            <span class="comment">// True</span></span><br><span class="line"><span class="number">2</span> === <span class="string">'2'</span>           <span class="comment">// False</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>   <span class="comment">// True</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>  <span class="comment">// False</span></span><br></pre></td></tr></table></figure></p>
<p>类型转换有很多取巧的地方，要注意：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(a)); <span class="comment">// True</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(b)); <span class="comment">// False</span></span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">你认为下面的相等判断会输出什么值呢?</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br></pre></td></tr></table></figure></p>
<p>实际上会返回true。知道为什么吗？</p>
<p><strong>如果你将一个布尔类型的和非布尔类型的判断，JavaScript会将布尔类型的转换为数字然后再比对。</strong><br>执行过程如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'0'</span> == <span class="literal">false</span>   (<span class="number">1</span>)</span><br><span class="line"><span class="string">'0'</span> == <span class="number">0</span>       (<span class="number">2</span>)</span><br><span class="line"> <span class="number">0</span>  == <span class="number">0</span>       (<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>所以，最终变成了0==0，当然返回true啦。</p>
<p>一些比较容易掉坑的比较，我在这里列出来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="string">""</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == []  <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == &#123;&#125;  <span class="comment">// false</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>      <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == []     <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == &#123;&#125;     <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == []      <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == &#123;&#125;      <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span>    <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="值-vs-引用"><a href="#值-vs-引用" class="headerlink" title="值 vs. 引用"></a>值 vs. 引用</h3><p>对于基本类型的值，赋值是通过值拷贝的形式；比如：null，undefined，boolean，number，string和ES6的symbol。对于复杂类型的值，通过引用拷贝的形式赋值。比如：对象、对象包括数组和函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;        <span class="comment">// 'a' hold a copy of the value 2.</span></span><br><span class="line"><span class="keyword">var</span> b = a;        <span class="comment">// 'b' is always a copy of the value in 'a'</span></span><br><span class="line">b++;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c;        <span class="comment">// 'd' is a reference to the shared value</span></span><br><span class="line">d.push( <span class="number">4</span> );      <span class="comment">// Mutates the referenced value (object)</span></span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(d);   <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="comment">/* Compound values are equal by reference */</span></span><br><span class="line"><span class="keyword">var</span> e = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c === d);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(c === e);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>如果想对复杂类型的值进行值拷贝，你需要自己去对所有子元素进行拷贝。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copy = c.slice()    <span class="comment">// 'copy' 即使copy和c相同，但是copy指向新的值</span></span><br><span class="line"><span class="built_in">console</span>.log(c);           <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);        <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(c === copy);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h3><p>作用域是程序的执行环境，它包含了在当前位置可访问的变量和函数。</p>
<p>全局作用域是最外层的作用域，在函数外面定义的变量属于全局作用域，可以被任何其他子作用域访问。在浏览器中，window对象就是全局作用域。</p>
<p>局部作用域是在函数内部的作用域。在局部作用域定义的变量只能在该作用域以及其子作用域被访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innermost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(a, b, c);   <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    innermost();</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);        <span class="comment">// 1 2 — 'c' is not defined</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">  <span class="built_in">console</span>.log(a);             <span class="comment">// 1 — 'b' and 'c' are not defined</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p>
<p>你可以将作用域想象成一系列不断变小的门。如果一个个子不高的人可以穿过最小的门(局部最小作用域)，那么必然可以穿过任何比它大的门(外部作用域)。</p>
<h3 id="提升-Hoisting"><a href="#提升-Hoisting" class="headerlink" title="提升(Hoisting)"></a>提升(Hoisting)</h3><p>在编译过程中，将var和function的定义移动到他们作用域最前面的行为叫做提升。</p>
<p>整个函数定义会被提升。所以，你可以在函数还未定义之前调用它，而不用担心找不到该函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(toSquare(<span class="number">3</span>));  <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toSquare</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变量只会被部分提升。而且只有变量的声明会被提升，赋值不会动。</p>
<p>let和const不会被提升。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="comment">/* Original code */</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">/* Compilation phase */</span></span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// undefined</span></span><br><span class="line">  i = <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6 let &amp; const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line">  <span class="keyword">const</span> i = <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h3><ul>
<li>函数表达式</li>
</ul>
<p>一个函数表达式是在函数执行到函数表达式定义的位置才开始创建，并被使用。它不会被提升。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数声明</li>
</ul>
<p>函数声明的函数可以在文件中任意位置调用，因为它会被提升。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="变量：var，let和const"><a href="#变量：var，let和const" class="headerlink" title="变量：var，let和const"></a>变量：var，let和const</h3><p>在ES6之前，只能使用var来声明变量。在一个函数体中声明的变量和函数，周围的作用域内无法访问。在块作用域if和for中声明的变量，可以在if和for的外部被访问。</p>
<p>注意：如果没有使用var,let或则const关键字声明的变量将会绑定到全局作用域上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">'Hi'</span>;</span><br><span class="line">    undeclaredVar = <span class="string">'I am automatically created in global scope'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(s) <span class="comment">// 'Hi'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// Error — ReferenceError: s is not defined</span></span><br><span class="line">greeting();</span><br><span class="line"><span class="built_in">console</span>.log(undeclaredVar) <span class="comment">// 'I am automatically created in global scope'</span></span><br></pre></td></tr></table></figure></p>
<p>ES6的let和const都是新引入的关键字。它们不会被提升，而且是块作用域。也就是说被大括号包围起来的区域声明的变量外部将不可访问。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g1 = <span class="string">'global 1'</span></span><br><span class="line"><span class="keyword">let</span> g2 = <span class="string">'global 2'</span></span><br><span class="line">&#123;   <span class="comment">/* Creating a new block scope */</span></span><br><span class="line">    g1 = <span class="string">'new global 1'</span></span><br><span class="line">    <span class="keyword">let</span> g2 = <span class="string">'local global 2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(g1)   <span class="comment">// 'new global 1'</span></span><br><span class="line">    <span class="built_in">console</span>.log(g2)   <span class="comment">// 'local global 2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(g3)   <span class="comment">// ReferenceError: g3 is not defined</span></span><br><span class="line">    <span class="keyword">let</span> g3 = <span class="string">'I am not hoisted'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(g1)    <span class="comment">// 'new global 1'</span></span><br><span class="line"><span class="built_in">console</span>.log(g2)    <span class="comment">// 'global 2'</span></span><br></pre></td></tr></table></figure></p>
<p>一个常见的误解是：使用const声明的变量，其值不可更改。准确地说它不可以被重新赋值，但是可以更改。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tryMe = <span class="string">'initial assignment'</span>;</span><br><span class="line">tryMe = <span class="string">'this has been reassigned'</span>;  <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You cannot reassign but you can change it…</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">'Ted'</span>, <span class="string">'is'</span>, <span class="string">'awesome!'</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'Barney'</span>;</span><br><span class="line">array[<span class="number">3</span>] = <span class="string">'Suit up!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array);     <span class="comment">// [“Barney”, “is”, “awesome!”, “Suit up!”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> airplane = &#123;&#125;;</span><br><span class="line">airplane.wings = <span class="number">2</span>;</span><br><span class="line">airplane.passengers = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(airplane);   <span class="comment">// &#123;passengers: 200, wings: 2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.fundebug.com/2018/01/15/the-definitive-javascript-handbook-for-a-developer-interview/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;类型和类型转换&quot;&gt;&lt;a href=&quot;#类型和类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型和类型转换&quot;&gt;&lt;/a&gt;类型和类型转换&lt;/h3&gt;&lt;p&gt;在JavaScript中有7个内置类型：null,undefined,boolean,number,string,object和symbol（ES6)。&lt;/p&gt;
&lt;p&gt;除了object以外，其他都叫做基本类型。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;//number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// boolean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;Hi&#39;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// symbol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之原型和原型链</title>
    <link href="https://callmejay.github.io/2018/02/08/JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://callmejay.github.io/2018/02/08/JavaScript之原型和原型链/</id>
    <published>2018-02-08T14:02:47.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p>我们先使用构造函数创建一个对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">'lili'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// lili</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。<br><a id="more"></a></p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每一个<strong>函数都有一个prototype属性</strong>，就是我们经常在各种例子中看到那个prototype,比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*虽然写在注释了，但是要注意：prototype是函数才会有的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.prototype.name = <span class="string">'Jay'</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// jay</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// jay</span></span><br></pre></td></tr></table></figure></p>
<p>那这个函数的prototype属性到底指向的是什么呢？</p>
<p>其实，函数的prototype属性指向了一个对象，这个对象正是<strong>调用该构造函数而创建的实例</strong>的原型，也就是这个例子中的person1和person2的原型。</p>
<p>那什么是原型呢？可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype1.png" alt=""><br>在这张图中我们用的<code>Object.prototype</code>表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢？</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>这是每一个JavaScript对象（null除外）都具有的一个属性，叫__proto__，这个属性会指向该对象的原型，证明如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype2.png" alt=""><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就是第三个属性: constructor，每个原型都有一个constructor属性指向关联的构造函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === <span class="built_in">Object</span>.prototype.constructor);</span><br></pre></td></tr></table></figure></p>
<p>再更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype3.png" alt=""><br>综上所述:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor = Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系。</p>
<h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br>举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'jay'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'John'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// jay</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们给实例对象person添加了name属性，当我们打印person.name的时候，结果自然为John。</p>
<p>但是当我们删除了person的name属性时，读取person.name,从person对象中找不到name属性就会从person的原型也就是person.__proto__,也就是Person.prototype中查找，幸运的是我们找打name属性，结果为jay。</p>
<p>但是万一没找到呢，原型的原型又是什么呢？</p>
<h3 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h3><p>在前面，我们已经讲了原型也是一个对象，既然是对象，那我们就可以用最原始的方式创建它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'Kevin'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure></p>
<p>其实原型对象就是通过Object构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的prototype,所以载更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype4.png" alt=""></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>那Object.prototype的原型呢？<br>null, 我们可以打印：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>然而null究竟代表了什么呢？</p>
<blockquote>
<p>null代表’没有对象’，即该处不该有值。</p>
</blockquote>
<p><img src="http://oonulpk6h.bkt.clouddn.com/null&amp;undefined.png" alt=""><br>所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype5.png" alt=""></p>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是<strong>原型链</strong>，也就是蓝色的这条线。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h4><p>首先是constructor属性，例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor == Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有这个属性，所以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor = Person.prototype.constructor</span><br></pre></td></tr></table></figure></p>
<h4 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h4><p>其次是__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h4 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h4><p>最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性的说法， 引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建了一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和方法，所以与其叫继承，委托的说法反而更准确些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;构造函数创建对象&quot;&gt;&lt;a href=&quot;#构造函数创建对象&quot; class=&quot;headerlink&quot; title=&quot;构造函数创建对象&quot;&gt;&lt;/a&gt;构造函数创建对象&lt;/h3&gt;&lt;p&gt;我们先使用构造函数创建一个对象：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&#39;lili&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person.name); &lt;span class=&quot;comment&quot;&gt;// lili&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="原型" scheme="https://callmejay.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="https://callmejay.github.io/2018/02/07/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>https://callmejay.github.io/2018/02/07/前端跨域整理/</id>
    <published>2018-02-07T15:41:20.000Z</published>
    <updated>2018-02-10T09:29:37.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><blockquote>
<p>跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。</p>
</blockquote>
<a id="more"></a>
<p>下面是具体的跨域情况详解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">URL                      说明       是否允许通信</span><br><span class="line">http://www.a.com/a.js</span><br><span class="line">http://www.a.com/b.js     同一域名下   允许</span><br><span class="line"></span><br><span class="line">http://www.a.com/lab/a.js</span><br><span class="line">http://www.a.com/script/b.js 同一域名下不同文件夹 允许</span><br><span class="line"></span><br><span class="line">http://www.a.com:8000/a.js</span><br><span class="line">http://www.a.com/b.js     同一域名，不同端口  不允许</span><br><span class="line"></span><br><span class="line">http://www.a.com/a.js</span><br><span class="line">https://www.a.com/b.js 同一域名，不同协议 不允许</span><br><span class="line"></span><br><span class="line">http://www.a.com/a.js</span><br><span class="line">http://70.32.92.74/b.js 域名和域名对应ip 不允许</span><br><span class="line"></span><br><span class="line">http://www.a.com/a.js</span><br><span class="line">http://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</span><br><span class="line"></span><br><span class="line">http://www.a.com/a.js</span><br><span class="line">http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</span><br><span class="line"></span><br><span class="line">http://www.cnblogs.com/a.js</span><br><span class="line">http://www.a.com/b.js 不同域名 不允许</span><br></pre></td></tr></table></figure></p>
<p><strong>这里我们需要注意两点:</strong></p>
<ul>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</li>
</ul>
<h3 id="通过document-domain跨域"><a href="#通过document-domain跨域" class="headerlink" title="通过document.domain跨域"></a>通过document.domain跨域</h3><blockquote>
<p>前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<code>www.damonare.cn/a.html</code> ， 在这个页面里面有一个iframe，它的src是<code>damonare.cn/b.html</code>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'ifame'</span>);</span><br><span class="line">        <span class="keyword">var</span> win = iframe.contentWindow;<span class="comment">//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span></span><br><span class="line">        <span class="keyword">var</span> doc = win.document;<span class="comment">//这里获取不到iframe里的document对象</span></span><br><span class="line">        <span class="keyword">var</span> name = win.name;<span class="comment">//这里同样获取不到window对象的name属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;iframe id = "iframe" src="http:/</span><span class="regexp">/damonare.cn/</span>b.html<span class="string">" onload = "</span>test()<span class="string">"&gt;&lt;/iframe&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，<code>document.domain</code>就可以派上用场了，我们只要把<code>www.damonare.cn/a.html</code>和<code>damonare.cn/b.html</code>这两个页面的<code>document.domain</code>都设成相同的域名就可以了。但要注意的是，<code>document.domain</code>的设置是有限制的，我们只能把<code>document.domain</code>设置成自身或更高一级的父域，且主域必须相同。</p>
</blockquote>
<p>在页面<code>www.damonare.cn/a.html</code>中设置<code>document.domain</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://damonare.cn/b.html"</span> onload = <span class="string">"test()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//设置成主域</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在页面<code>damonare.cn/b.html</code>中也设置<code>document.domain</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>修改<code>document.domain</code>的方法只适用于不同子域的框架间的交互。</strong></p>
<h3 id="通过location-hash跨域"><a href="#通过location-hash跨域" class="headerlink" title="通过location.hash跨域"></a>通过location.hash跨域</h3><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。</p>
</blockquote>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。<br>1, a.html传送数据到b.html</p>
<ul>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
</ul>
<p>2, b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</p>
<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”www.baidu.com/proxy.html#…”</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
<p>b.html页面的关键代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    parent.location.hash = <span class="string">'data'</span>;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </span><br><span class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，  </span></span><br><span class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </span><br><span class="line">    ifrproxy.style.display = <span class="string">'none'</span>;  </span><br><span class="line">    ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html#data"</span>;  </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>proxy.html页面的关键代码如下 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span></span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="通过HTML5的postMessage方法跨域"><a href="#通过HTML5的postMessage方法跨域" class="headerlink" title="通过HTML5的postMessage方法跨域"></a>通过HTML5的postMessage方法跨域</h3><blockquote>
<p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。</p>
</blockquote>
<p>比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。</p>
<p>A页面通过postMessage方法发送消息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);</span><br><span class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">'http://www.google.com'</span>;</span><br><span class="line">    ifr.contentWindow.postMessage(<span class="string">'hello'</span>,targetOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>postMessage的使用方法：</strong></p>
<ul>
<li>otherWindow.postMessage(message, targetOrigin);</li>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames属性的成员或者由window.open方法创建的窗口</li>
<li>message:是要发送的消息，类型为String、Object(IE8、9 不支持)<br>targetOrigin:是限定消息接收范围，不限制请使用 ‘*’</li>
</ul>
<p>B页面通过message事件监听并接受消息:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = ev.data; <span class="comment">// 消息</span></span><br><span class="line">    <span class="keyword">var</span> origin = ev.origin; <span class="comment">// 消息来源地址</span></span><br><span class="line">    <span class="keyword">var</span> source = ev.source; <span class="comment">// 源window对象 </span></span><br><span class="line">    <span class="keyword">if</span>(origin == <span class="string">'http://www.baidu.com'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data); <span class="comment">// hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,onmessage,<span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123; <span class="comment">// ie</span></span><br><span class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">'message'</span>,onmessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<h3 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h3><blockquote>
<p>刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
</blockquote>
<p>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是damonare.cn/data.php, 那么a.html中的代码就可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dosomething</span>(<span class="params">jsondata</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//处理获得的json数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/example.com/</span>data.php?callback=dosomething<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</p>
<p>因为是当做一个js文件来引入的，所以<code>damonare.cn/data.php</code>返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></span><br><span class="line">$data = array(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></span><br><span class="line">echo $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</span><br><span class="line">        <span class="comment">//处理获得的json数据</span></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<p>JSONP的优缺点：</p>
<ul>
<li>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</li>
<li>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h3 id="通过CORS跨域"><a href="#通过CORS跨域" class="headerlink" title="通过CORS跨域"></a>通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。<strong>CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</strong>目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<p>平时的ajax请求可能是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> xhr = XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">'/getSomething'</span>,<span class="literal">true</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上getSomething部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> xhr = XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">'http://jaybein.site/getSomething'</span>,<span class="literal">true</span>);</span><br><span class="line">    xhr.send();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>
<p>服务器端对于CORS的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享CORS详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;什么是跨域？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="https://callmejay.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>对缓存的一点理解</title>
    <link href="https://callmejay.github.io/2018/02/07/%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>https://callmejay.github.io/2018/02/07/对缓存的一点理解/</id>
    <published>2018-02-07T13:44:29.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p>
</blockquote>
<h3 id="缓存的种类"><a href="#缓存的种类" class="headerlink" title="缓存的种类"></a>缓存的种类</h3><p>很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。<br><a id="more"></a><br>实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。</p>
<p>缓存好处有很多：</p>
<ul>
<li>缓解服务器压力(不用每次去请求资源)；</li>
<li>提升性能(打开本地资源速度当然比请求回来再打开要快得多)；</li>
<li>减少带宽消耗(我相信你可以理解)；</li>
</ul>
<h3 id="浏览器的缓存策略"><a href="#浏览器的缓存策略" class="headerlink" title="浏览器的缓存策略"></a>浏览器的缓存策略</h3><p><strong>缓存的目标:</strong></p>
<ul>
<li>一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；</li>
<li>不变的重定向: 响应状态码：301；</li>
<li>可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；</li>
<li>错误响应: 响应状态码：404 的一个页面；</li>
<li>不完全的响应: 响应状态码 206，只返回局部的信息；</li>
<li>除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；</li>
</ul>
<p><strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</strong><br>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Age:23146</span><br><span class="line">Cache-Control:max-age=2592000</span><br><span class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</span><br><span class="line">ETag:W/&quot;5a1cf09a-63c6&quot;</span><br><span class="line">Expires:Thu, 28 Dec 2017 05:27:45 GMT</span><br><span class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</span><br><span class="line">Vary:Accept-Encoding</span><br></pre></td></tr></table></figure></p>
<h4 id="强缓存阶段"><a href="#强缓存阶段" class="headerlink" title="强缓存阶段"></a>强缓存阶段</h4><p>以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，<code>Expires</code>是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。<code>Cache-Control:max-age=2592000</code>是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，<code>max-age &gt; Expires</code>。</p>
<p>这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️</p>
<p>Firefox浏览器表现为一个灰色的200状态码。</p>
<p>Chrome浏览器状态码表现为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 (from disk cache)或是200 OK (from memory cache)</span><br></pre></td></tr></table></figure></p>
<p><strong>多说一点：</strong>关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是<code>from memory cache</code>有时是<code>from disk cache</code>的问题了。</p>
<h4 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h4><p>那么当这个CSS文件过期了怎么办?<code>ETag</code>和<code>Last-Modified</code>就该闪亮登场了。</p>
<p>先说<code>Last-Modified</code>，这个字段是文件最后一次修改的时间；</p>
<p><code>ETag</code>呢？<code>ETag</code>是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。</p>
<p>利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带<code>If-Moified-Since</code>和<code>If-None-Match</code>这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑</p>
<p>具体两个字段携带的内容如下(分别和上面的<code>Last-Modified</code>、<code>ETag</code>携带的值对应)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT</span><br><span class="line">If-None-Match: W/&quot;5a1cf09a-63c6&quot;</span><br></pre></td></tr></table></figure></p>
<p>到这协商缓存结束。</p>
<h4 id="启发式缓存阶段"><a href="#启发式缓存阶段" class="headerlink" title="启发式缓存阶段"></a>启发式缓存阶段</h4><p>我们把上面的响应头改下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Age:23146</span><br><span class="line">Cache-Control: public</span><br><span class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</span><br><span class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</span><br><span class="line">Vary:Accept-Encoding</span><br></pre></td></tr></table></figure></p>
<p>发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带<code>If-Moified-Since</code>呗，不是的，浏览器还有个启发式缓存阶段。</p>
<p><strong>根据响应头中2个时间字段<code>Date</code>和<code>Last-Modified</code>之间的时间差值，取其值的10%作为缓存时间周期</strong>。</p>
<p>这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种<code>默认缓存</code>的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。<br>下面用一张图，来解释浏览器整个缓存策略的过程：<br><img src="http://oonulpk6h.bkt.clouddn.com/broswer_cache" alt="浏览器缓存过程"><br>对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。</p>
<blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7?utm_source=gold_browser_extension" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;缓存的种类&quot;&gt;&lt;a href=&quot;#缓存的种类&quot; class=&quot;headerlink&quot; title=&quot;缓存的种类&quot;&gt;&lt;/a&gt;缓存的种类&lt;/h3&gt;&lt;p&gt;很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。&lt;br&gt;
    
    </summary>
    
      <category term="浏览器" scheme="https://callmejay.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="cache" scheme="https://callmejay.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript:彻底理解同步、异步和事件循环（Event Loop）</title>
    <link href="https://callmejay.github.io/2018/02/06/JavaScript-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/02/06/JavaScript-彻底理解同步、异步和事件循环（Event-Loop）/</id>
    <published>2018-02-06T13:05:10.000Z</published>
    <updated>2018-09-10T07:43:22.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。</p>
</blockquote>
<a id="more"></a>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<p>如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在函数返回时，获得了预期值，即2的平方根</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面两个函数就是同步的。<br><strong>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</strong></p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<p>如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">fs.readFile(<span class="string">'hello.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//网络请求</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url);</span><br><span class="line">xhr.send(); <span class="comment">// 发起函数</span></span><br></pre></td></tr></table></figure></p>
<p>上述示例中读取文件函数 <code>readFile</code>和网络请求的发起函数  <code>send</code>都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在<code>JavaScript</code>中通过回调函数<code>function(err, data) { console.log(data); }</code>和 <code>onreadystatechange</code>，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行<code>JavaScript</code>代码的线程执行回调。</p>
<p><strong>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</strong></p>
<h3 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h3><p>在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？</p>
<p>JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。</p>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。<br>一个浏览器通常由以下几个常驻的线程：</p>
<ul>
<li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li>
<li>JS引擎线程：负责JS的解析和执行</li>
<li>定时触发器线程：处理定时事件，比如setTimeout, setInterval</li>
<li>事件触发线程：处理DOM事件</li>
<li>异步http请求线程：处理http请求</li>
</ul>
<p>需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。</p>
<h4 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h4><p>通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。</p>
<p>JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤：</p>
<ul>
<li>词法分析：将源代码分解为有意义的分词</li>
<li>语法分析：用语法分析器将分词解析成语法树</li>
<li>代码生成：生成机器能运行的代码</li>
<li>代码执行</li>
</ul>
<p>不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。</p>
<p>之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。</p>
<p><strong>所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</strong></p>
<h3 id="消息队列与事件循环"><a href="#消息队列与事件循环" class="headerlink" title="消息队列与事件循环"></a>消息队列与事件循环</h3><p>通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？</p>
<p>这一切的解释就需要继续了解消息队列和事件循环。</p>
<p><img src="http://oonulpk6h.bkt.clouddn.com/message&amp;queue" alt="消息队列"></p>
<p>如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。</p>
<p>JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫<strong>事件循环</strong>。</p>
<p><img src="http://oonulpk6h.bkt.clouddn.com/ajax%E7%BA%BF%E7%A8%8B" alt="AJAX过程"></p>
<p>上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。</p>
<p>从上文中我们也可以得到这样一个明显的结论，就是：</p>
<blockquote>
<p>异步过程的回调函数，一定不在当前这一轮事件循环中执行。</p>
</blockquote>
<h3 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h3><p><strong>宏队列，macrotask，也叫tasks。</strong> 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate (Node独有)</li>
<li>requestAnimationFrame (浏览器独有)</li>
<li>I/O</li>
<li>UI rendering (浏览器独有)</li>
</ul>
<p><strong>微队列，microtask，也叫jobs。</strong> 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：</p>
<ul>
<li>process.nextTick (Node独有)</li>
<li>Promise</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<p>（注：这里只针对浏览器和NodeJS）</p>
<h3 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h3><p><img src="http://oonulpk6h.bkt.clouddn.com/event_loop.png" alt="event loop"></p>
<p>这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：</p>
<ol>
<li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li>
<li>全局Script代码执行完毕后，调用栈Stack会清空；</li>
<li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li>
<li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。<strong>注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行</strong>；</li>
<li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li>
<li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li>
<li>执行完毕后，调用栈Stack为空；</li>
<li>重复第3-7个步骤；</li>
<li>重复第3-7个步骤；</li>
<li>……</li>
</ol>
<p><strong>可以看到，这就是浏览器的事件循环Event Loop这里归纳3个重点：</strong></p>
<ol>
<li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；</li>
<li>微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；</li>
<li>图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。</p>
<blockquote>
<p>执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer a'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer b'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitFiveSeconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="keyword">while</span>(((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - now) &lt; <span class="number">5000</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finished waiting'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'click begin'</span>);</span><br><span class="line">waitFiveSeconds();</span><br></pre></td></tr></table></figure>
<p>要想了解上述代码的输出结果，首先介绍下定时器。</p>
<p><code>setTimeout</code>的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，<strong>所以间隔的时间一般会大于等于指定的时间</strong>。</p>
<p><code>setTimeout(fn, 0)</code>的意思是，将回调函数<code>fn</code>立刻插入消息队列，等待执行，而不是立即执行。看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b a</span><br></pre></td></tr></table></figure>
<p>打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。</p>
<p>理解了定时器的作用，那么对于输出结果就容易得出了。</p>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达5s。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">click begin</span><br><span class="line">finished waiting</span><br></pre></td></tr></table></figure></p>
<p>然后，在JS引擎线程执行的时候，<code>&#39;timer a&#39;</code>对应的定时器产生的回调、 <code>&#39;timer b&#39;</code>对应的定时器产生的回调和两次<code>click</code>对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">click</span><br><span class="line">timer a</span><br><span class="line">timer b</span><br></pre></td></tr></table></figure></p>
<p>最后，5s 后的两次<code>click</code>事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">click</span><br><span class="line">click</span><br></pre></td></tr></table></figure></p>
<h3 id="异步与事件"><a href="#异步与事件" class="headerlink" title="异步与事件"></a>异步与事件</h3><p>上文中说的“事件循环”，为什么里面有个事件呢？那是因为：</p>
<blockquote>
<p>消息队列中的每条消息实际上都对应着一个事件。</p>
</blockquote>
<p>上文中一直没有提到一类很重要的异步过程：<code>DOM事件</code>。<br>举例说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElement(<span class="string">'#btn'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'lalla'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。</p>
<p>从异步过程的角度看，<code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。</p>
<p>这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些.</p>
<p><strong>参考文章</strong>：<br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p>
<blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5a6ad46ef265da3e513352c8?utm_source=gold_browser_extension" target="_blank" rel="noopener">传送门</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="Event Loop" scheme="https://callmejay.github.io/tags/Event-Loop/"/>
    
  </entry>
  
</feed>
