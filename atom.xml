<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay Bein&#39;s Blog</title>
  <subtitle>有事做，有人爱，有所期待。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://callmejay.github.io/"/>
  <updated>2019-06-26T02:45:12.959Z</updated>
  <id>https://callmejay.github.io/</id>
  
  <author>
    <name>Jay Bein</name>
    <email>291977464@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础知识总结-3</title>
    <link href="https://callmejay.github.io/2019/06/10/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-3/"/>
    <id>https://callmejay.github.io/2019/06/10/基础知识总结-3/</id>
    <published>2019-06-10T08:50:37.000Z</published>
    <updated>2019-06-26T02:45:12.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>主要是针对面试中口述问题</p>
</blockquote>
<h3 id="说一下JS的Event-Loop"><a href="#说一下JS的Event-Loop" class="headerlink" title="说一下JS的Event Loop"></a>说一下JS的Event Loop</h3><p>简单总结如下：</p>
<ol>
<li>JS是单线程的，其上面的所有任务都是在两个地方执行：执行栈和任务队列。前者是存放同步任务；后者是异步任务有结果后，就在其中放入一个事件。</li>
<li>当执行栈的任务都执行完了（栈空），js会读取任务队列，并将可以执行的任务从任务队列丢到执行栈中执行。</li>
<li>这个过程是循环进行，所以称作Loop。</li>
</ol>
<a id="more"></a>
<h3 id="解释下js的闭包"><a href="#解释下js的闭包" class="headerlink" title="解释下js的闭包"></a>解释下js的闭包</h3><p>直接上MDN的解释：<code>闭包是函数和声明该函数的词法环境的组合</code>。</p>
<p>而在JavaScript中，函数是被作为一级对象使用的，它既可以本当作值返回，还可以当作参数传递。理解了：<code>“Js中的函数运行在它们被定义的作用域，而不是它们被执行的作用域”</code>（摘自《JavaScript语言精粹》） 这句话即可。</p>
<h3 id="解释下Set和Map"><a href="#解释下Set和Map" class="headerlink" title="解释下Set和Map"></a>解释下Set和Map</h3><ul>
<li>Set元素不允许重复</li>
<li>Map类似对象，但是它的键（key）可以是任意数据类型</li>
</ul>
<p>Set的常用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历set</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素，返回Set本身</span></span><br><span class="line">set.add(<span class="number">5</span>).add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set大小</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查元素存在</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定元素，返回bool</span></span><br><span class="line"><span class="keyword">let</span> success = set.delete(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(success);</span><br><span class="line"></span><br><span class="line">set.clear();</span><br></pre></td></tr></table></figure>
<p>Map接口基本和Set一致。不同的是增加/获取新元素的API是：set/get(key, value)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以任意对象为 Key 值</span></span><br><span class="line"><span class="comment">// 这里以 Date 对象为例</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">map.set(key, <span class="string">"today"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key));</span><br></pre></td></tr></table></figure>
<h3 id="JS隐式转换及应用场景"><a href="#JS隐式转换及应用场景" class="headerlink" title="JS隐式转换及应用场景"></a>JS隐式转换及应用场景</h3><ul>
<li>-、*、/、% ：一律转换成数值后计算</li>
<li><p>+：</p>
<p>数字 + 字符串 = 字符串， 运算顺序是从左到右</p>
<p>数字 + 对象， 优先调用对象的valueOf -&gt; toString</p>
<p>数字 + boolean/null -&gt; 数字</p>
<p>数字 + undefined -&gt; NaN</p>
</li>
<li><p>[1].toString() === ‘1’</p>
</li>
<li>{}.toString() === ‘[object object]’</li>
<li>NaN !== NaN 、+undefined 为 NaN</li>
<li>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<h4 id="哪些元素可以产生BFC"><a href="#哪些元素可以产生BFC" class="headerlink" title="哪些元素可以产生BFC"></a>哪些元素可以产生BFC</h4><ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h4 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h4><ul>
<li>内部的Box会在垂直方向，一个接一个地放置</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin-box的左边， 与包含块border-box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
</ul>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）</p>
<ul>
<li>当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。</li>
<li>任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。</li>
<li>当函数运行结束后，解释器将它从堆栈中移除，并在主代码列表中继续执行代码。</li>
<li>如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要是针对面试中口述问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;说一下JS的Event-Loop&quot;&gt;&lt;a href=&quot;#说一下JS的Event-Loop&quot; class=&quot;headerlink&quot; title=&quot;说一下JS的Event Loop&quot;&gt;&lt;/a&gt;说一下JS的Event Loop&lt;/h3&gt;&lt;p&gt;简单总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JS是单线程的，其上面的所有任务都是在两个地方执行：执行栈和任务队列。前者是存放同步任务；后者是异步任务有结果后，就在其中放入一个事件。&lt;/li&gt;
&lt;li&gt;当执行栈的任务都执行完了（栈空），js会读取任务队列，并将可以执行的任务从任务队列丢到执行栈中执行。&lt;/li&gt;
&lt;li&gt;这个过程是循环进行，所以称作Loop。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="基础" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>学习react</title>
    <link href="https://callmejay.github.io/2019/05/29/%E5%AD%A6%E4%B9%A0react/"/>
    <id>https://callmejay.github.io/2019/05/29/学习react/</id>
    <published>2019-05-29T02:44:39.000Z</published>
    <updated>2019-06-26T04:02:15.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。这是一个从无到有的过程，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。</p>
</blockquote>
<a id="more"></a>
<p>挂载过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; constructor()</span><br><span class="line">-&gt; componentWillMount()</span><br><span class="line">-&gt; render()</span><br><span class="line">// 然后构造 DOM 元素插入页面</span><br><span class="line">-&gt; componentDidMount()</span><br><span class="line">// ...</span><br><span class="line">// 即将从页面中删除</span><br><span class="line">-&gt; componentWillUnmount()</span><br><span class="line">// 从页面中删除</span><br></pre></td></tr></table></figure>
<blockquote>
<p>组件的私有方法都用 <code>_</code> 开头，所有事件监听的方法都用 <code>handle</code> 开头。把事件监听方法传给组件的时候，属性名用 <code>on</code> 开头。</p>
</blockquote>
<h4 id="组件的内容编写顺序如下"><a href="#组件的内容编写顺序如下" class="headerlink" title="组件的内容编写顺序如下"></a>组件的内容编写顺序如下</h4><ol>
<li>static 开头的类属性，如 <code>defaultProps</code>、<code>propTypes</code>。</li>
<li>构造函数，<code>constructor</code>。</li>
<li>getter/setter（还不了解的同学可以暂时忽略）。</li>
<li>组件生命周期。</li>
<li><code>_</code> 开头的私有方法。</li>
<li>事件监听方法，<code>handle*</code>。</li>
<li><code>render*</code>开头的方法，有时候 <code>render()</code> 方法里面的内容会分开到不同函数里面进行，这些函数都以 <code>render*</code> 开头。</li>
<li><code>render()</code> 方法。</li>
</ol>
<h4 id="什么是高阶组件（Higher-Order-Component）"><a href="#什么是高阶组件（Higher-Order-Component）" class="headerlink" title="什么是高阶组件（Higher-Order Component）"></a>什么是高阶组件（Higher-Order Component）</h4><blockquote>
<p>高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。新的组件使用传入的组件作为子组件。</p>
</blockquote>
<p>作用：高阶组件的作用是用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。新的组件和传入的组件通过 props 传递信息。</p>
<h3 id="纯函数（Pure-Function）"><a href="#纯函数（Pure-Function）" class="headerlink" title="纯函数（Pure Function）"></a>纯函数（Pure Function）</h3><blockquote>
<p>一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用</p>
</blockquote>
<p>除了修改外部的变量，一个函数在执行过程中还有很多方式产生外部可观察的变化，比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，还有调用 window.reload 刷新浏览器，甚至是 console.log 往控制台打印数据也是副作用。</p>
<p>纯函数很严格，也就是说你几乎除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据。</p>
<p>为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;组件的挂载指的是将组件渲染并且构造 DOM 元素然后插入页面的过程。这是一个从无到有的过程，React.js 提供一些生命周期函数可以给我们在这个过程中做一些操作。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://callmejay.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>必会的手写面试题</title>
    <link href="https://callmejay.github.io/2019/04/09/%E5%BF%85%E4%BC%9A%E7%9A%84%E6%89%8B%E5%86%99%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://callmejay.github.io/2019/04/09/必会的手写面试题/</id>
    <published>2019-04-09T10:15:04.000Z</published>
    <updated>2019-06-26T02:50:38.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><blockquote>
<p>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。  用途是实现多参函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><p>浅拷贝的方法有： <code>Object.assign()</code>,<code>Array.from()</code>,<code>Array.slice()</code>,<code>Array.concat()</code></p>
<blockquote>
<p>递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义检测数据类型的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkedType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现深度克隆---对象/数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断拷贝的数据类型</span></span><br><span class="line">  <span class="comment">//初始化变量result 成为最终克隆的数据</span></span><br><span class="line">  <span class="keyword">let</span> result,</span><br><span class="line">    targetType = checkedType(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="string">'Object'</span>) &#123;</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType === <span class="string">'Array'</span>) &#123;</span><br><span class="line">    result = []</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历目标数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">//获取遍历数据结构的每一项值。</span></span><br><span class="line">    <span class="keyword">let</span> value = target[i]</span><br><span class="line">    <span class="comment">//判断目标结构里的每一值是否存在对象/数组</span></span><br><span class="line">    <span class="keyword">if</span> (checkedType(value) === <span class="string">'Object'</span> || checkedType(value) === <span class="string">'Array'</span>) &#123;</span><br><span class="line">      <span class="comment">//对象/数组里嵌套了对象/数组</span></span><br><span class="line">      <span class="comment">//继续遍历获取到value值</span></span><br><span class="line">      result[i] = clone(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取到value值是基本的数据类型或者是函数。</span></span><br><span class="line">      result[i] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数柯里化&quot;&gt;&lt;a href=&quot;#函数柯里化&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化&quot;&gt;&lt;/a&gt;函数柯里化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。  用途是实现多参函数。
    
    </summary>
    
    
      <category term="手写" scheme="https://callmejay.github.io/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>基础知识总结-2</title>
    <link href="https://callmejay.github.io/2019/02/18/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-2/"/>
    <id>https://callmejay.github.io/2019/02/18/基础知识总结-2/</id>
    <published>2019-02-18T10:39:09.000Z</published>
    <updated>2019-06-26T03:03:29.107Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/cd3fee40ef59" target="_blank" rel="noopener">前端基础进阶系列</a></p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>每次当控制器转到可执行代码的时候，就会进入一个执行上下文。<strong>执行上下文可以理解为当前代码的执行环境，它会形成一个作用域</strong>。JavaScript中的运行环境大概包括三种情况。</p>
<ul>
<li>全局环境：JavaScript代码运行起来会首先进入该环境</li>
<li>函数环境：当函数被调用执行时，会进入当前函数中执行代码</li>
<li>eval（不建议使用，可忽略）</li>
</ul>
<a id="more"></a>
<p>因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为 <strong>函数调用栈(call stack)</strong>。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p>
<p>当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。</p>
<blockquote>
<p>执行上下文可以理解为函数执行的环境，每一个函数执行时，都会给对应的函数创建这样一个执行环境。<br>注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">'red'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/599584-58d31e5b80737ca0.png" alt="执行过程"></p>
<p>详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。</p>
<ul>
<li>单线程</li>
<li>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li>
<li>函数的执行上下文的个数没有限制</li>
<li>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li>
</ul>
<p>我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。</p>
<ul>
<li><p><strong>创建阶段</strong><br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</p>
</li>
<li><p><strong>代码执行阶段</strong><br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/19704583/60147757-43b78280-9801-11e9-8527-5e81d3bb687f.png" alt="执行上下文生命周期"></p>
<h4 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h4><p>变量对象的变化的创建，依次经历了下面过程：</p>
<ol>
<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>
<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>
<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改（注意只是创建过程，不是执行过程）。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// function foo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先将所有函数声明放入变量对象中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'function foo'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过undefined的赋值</span></span><br><span class="line"><span class="comment">// var foo = undefined;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后开始执行阶段代码的执行</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// function foo</span></span><br><span class="line">foo = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(foo());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建阶段</span></span><br><span class="line">testEC = &#123;</span><br><span class="line">  VO: &#123;&#125;,  <span class="comment">//变量对象</span></span><br><span class="line">  scopeChain: &#123;&#125; <span class="comment">// 作用域链</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明</span></span><br><span class="line"></span><br><span class="line">VO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;...&#125;, <span class="comment">//注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理</span></span><br><span class="line">  foo: <span class="xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>,  // 表示foo的地址引用</span></span><br><span class="line"><span class="xml">  a: undefined</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<blockquote>
<p>这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">VO -&gt;  AO   <span class="comment">// Active Object</span></span><br><span class="line">AO = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;...&#125;,</span><br><span class="line">    foo: <span class="xml"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    a: 1,</span></span><br><span class="line"><span class="xml">    this: Window</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h4><p>以浏览器中为例，全局对象为window。<br>全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以浏览器中为例，全局对象为window</span></span><br><span class="line"><span class="comment">// 全局上下文</span></span><br><span class="line">windowEC = &#123;</span><br><span class="line">    VO: Window,</span><br><span class="line">    scopeChain: &#123;&#125;,</span><br><span class="line">    <span class="keyword">this</span>: Window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</li>
</ul>
<blockquote>
<p>这里的标识符，指的是变量名或者函数名</p>
</blockquote>
<ul>
<li>JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。</li>
<li>作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。</li>
</ul>
<blockquote>
<p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/19704583/60147832-72cdf400-9801-11e9-9381-eecd02475369.png" alt="代码执行过程"></p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote>
<p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
</blockquote>
<p>举个栗子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> innerTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">innerTestEC = &#123;</span><br><span class="line">    VO: &#123;...&#125;,  <span class="comment">// 变量对象</span></span><br><span class="line">    scopeChain: [VO(innerTest), VO(test), VO(global)], <span class="comment">// 作用域链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。<br>很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。</p>
<p><img src="https://user-images.githubusercontent.com/19704583/60147875-94c77680-9801-11e9-85c1-39c161f5c78f.png" alt="作用域链示意"></p>
<blockquote>
<p>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object</p>
</blockquote>
<p>作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包是一种特殊的对象</strong>。</p>
<p><strong>它由两部分组成。执行上下文A,以及在该执行上下文中创建的函数B</strong>。</p>
<p><strong>当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生</strong>。</p>
<p>因此，闭包的形成需要两个条件:</p>
<ul>
<li>闭包是在函数被调用执行的时候才被确认创建的。</li>
<li>在函数内部创建新的函数;</li>
<li>新的函数在执行时，访问了函数的变量对象。</li>
</ul>
<p><strong>在大多数理解中，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包</strong>。</p>
<p>我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innnerFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn = innnerFoo; <span class="comment">// 将 innnerFoo的引用，赋值给全局变量中的fn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn(); <span class="comment">// 此处的保留的innerFoo的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>foo()</code>执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过<code>fn = innerFoo</code>，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。</p>
<p>闭包造成内存泄露？</p>
<p><strong>内存泄露</strong>是指 <code>你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来</code>。</p>
<p>闭包里面的变量明明就是我们需要的变量（lives），所以不是内存泄露</p>
<p>为何有人说是？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。</p>
<blockquote>
<p>在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。</p>
</blockquote>
<h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>首先我们需要得出一个非常重要一定要牢记于心的结论，<strong>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的</strong>。除此之外 <strong>在函数执行过程中，this一旦被确定，就不可更改了。</strong></p>
<p>在一个 <strong>函数上下文</strong> 中，this由调用者提供，由调用函数的方式来决定。<strong>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined</strong>。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>
<p>从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  <span class="comment">// fn是调用者，独立调用  undifined</span></span><br><span class="line"><span class="built_in">window</span>.fn();  <span class="comment">// fn是调用者，被window所拥有  Window</span></span><br></pre></td></tr></table></figure>
<h4 id="使用apply-call实现继承"><a href="#使用apply-call实现继承" class="headerlink" title="使用apply/call实现继承"></a>使用apply/call实现继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父级的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age  = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, high</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use call</span></span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name:'</span>+<span class="keyword">this</span>.name+<span class="string">', age:'</span>+<span class="keyword">this</span>.age+<span class="string">', high:'</span>+<span class="keyword">this</span>.high+<span class="string">', gender:'</span>+<span class="keyword">this</span>.gender[<span class="number">0</span>]+<span class="string">';'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Student(<span class="string">'xiaom'</span>, <span class="number">12</span>, <span class="string">'150cm'</span>).message();</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line"><span class="comment">// ----------</span></span><br><span class="line"><span class="comment">// name:xiaom, age:12, high:150cm, gender:man;</span></span><br></pre></td></tr></table></figure>
<p>简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, high</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age  = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>];</span><br><span class="line">    <span class="comment">// Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承</span></span><br><span class="line">    <span class="keyword">this</span>.high = high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结一"><a href="#总结一" class="headerlink" title="总结一"></a>总结一</h3><p><strong>函数在被调用执行时，会创建一个当前函数的执行上下文。在该执行上下文的创建阶段，变量对象、作用域链、闭包、this指向会分别被确定。而一个JavaScript程序中一般来说会有多个函数，JavaScript引擎使用函数调用栈来管理这些函数的调用顺序。函数调用栈的调用顺序与栈数据结构一致</strong>。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>在ECMAScript-262中，对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。</p>
<p>也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。</p>
<p>假如我们有一个简单的对象如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'TOM'</span>,</span><br><span class="line">    age: <span class="string">'20'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们想要访问他的name属性时，可以用如下两种方式访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">person[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>
<p>如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问person的name与age，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'name'</span>, <span class="string">'age'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(person[item]);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方式一定要重视，记住它以后在我们处理复杂数据的时候会有很大的帮助。</p>
</blockquote>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createPerson = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象就是工厂模式的模子</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次添加我们需要的属性与方法</span></span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个实例</span></span><br><span class="line"><span class="keyword">var</span> perTom = createPerson(<span class="string">'TOM'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> PerJake = createPerson(<span class="string">'Jake'</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将构造函数以参数形式传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将实例的原型指向构造函数的原型</span></span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象</span></span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></span><br><span class="line"><span class="keyword">var</span> p1 = New(Person, <span class="string">'tom'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过prototye属性，将方法挂载到原型对象上</span></span><br><span class="line"><span class="comment">// 实现复用 避免每次都生成一个新的 getName 方法</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'tim'</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'jak'</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName === p2.getName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/19704583/60147945-c3455180-9801-11e9-868b-bcd82fae5812.png" alt="图示"></p>
<p>通过图示我们可以看出，构造函数的prototype与所有实例对象的 <code>__proto__</code> 都指向原型对象。而原型对象的constructor指向构造函数。</p>
<p>除此之外，还可以从图中看出，实例对象实际上对前面我们所说的中间对象的复制，而中间对象中的属性与方法都在构造函数中添加。于是根据构造函数与原型的特性，我们就可以将在构造函数中，通过this声明的属性与方法称为私有变量与方法，它们被当前被某一个实例对象所独有。而通过原型声明的属性与方法，我们可以称之为共有属性与方法，它们可以被所有的实例对象访问。</p>
<p><strong>当我们访问实例对象中的属性或者方法时，会优先访问实例对象自身的属性和方法</strong>。</p>
<p>我们可以通过in来判断，一个对象是否拥有某一个属性/方法，无论是该属性/方法存在与实例对象还是原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'tim'</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>in的这种特性最常用的场景之一，就是判断当前页面是否在移动端打开。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很多人喜欢用浏览器UA的方式来判断，但并不是很好的方式</span></span><br><span class="line">isMobile = <span class="string">'ontouchstart'</span> <span class="keyword">in</span> <span class="built_in">document</span>;</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还可以使用更为简单的原型写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    getName: function() &#123;&#125;,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person.prototype = {}</code> 实际上是重新创建了一个 <code>{}</code> 对象并赋值给 <code>Person.prototype</code>，这里的 <code>{}</code> 并不是最初的那个原型对象。因此它里面并不包含 <code>constructor</code> 属性。为了保证正确性，我们必须在新创建的 <code>{}</code> 对象中显示的设置 <code>constructor</code> 的指向。即上面的 <code>constructor: Person</code>。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型对象其实也是普通的对象。几乎所有的对象都可能是原型对象，也可能是实例对象，而且还可以同时是原型对象与实例对象。这样的一个对象，正是构成原型链的一个节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/19704583/60147997-f5ef4a00-9801-11e9-8eb7-9be4340d69ed.png" alt="普通函数原型链"></p>
<p>其中add是Function对象的实例。而Function的原型对象同时又是Object原型的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。</p>
<p>基于原型链的特性，我们可以很轻松的实现继承。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>我们常常结合构造函数与原型来创建一个对象。因为构造函数与原型的不同特性，分别解决了我们不同的困扰。因此当我们想要实现继承时，就必须得根据构造函数与原型的不同而采取不同的策略。</p>
<p>首先我们来看构造函数的继承。在上面我们已经理解了构造函数的本质，它其实是在new内部实现的一个复制过程。而我们在继承时想要的，就是想父级构造函数中的操作在子级的构造函数中重现一遍即可。我们可以通过call方法来达到目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数的继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而原型的继承，则只需要将子级的原型对象设置为父级的一个实例，加入到原型链中即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承原型</span></span><br><span class="line">cPerson.prototype = <span class="keyword">new</span> Person(name, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更多方法</span></span><br><span class="line">cPerson.prototype.getLive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/cd3fee40ef59&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端基础进阶系列&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;执行上下文&quot;&gt;&lt;a href=&quot;#执行上下文&quot; class=&quot;headerlink&quot; title=&quot;执行上下文&quot;&gt;&lt;/a&gt;执行上下文&lt;/h3&gt;&lt;p&gt;每次当控制器转到可执行代码的时候，就会进入一个执行上下文。&lt;strong&gt;执行上下文可以理解为当前代码的执行环境，它会形成一个作用域&lt;/strong&gt;。JavaScript中的运行环境大概包括三种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局环境：JavaScript代码运行起来会首先进入该环境&lt;/li&gt;
&lt;li&gt;函数环境：当函数被调用执行时，会进入当前函数中执行代码&lt;/li&gt;
&lt;li&gt;eval（不建议使用，可忽略）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="基础" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常用几种继承方案</title>
    <link href="https://callmejay.github.io/2019/01/14/JavaScript%E5%B8%B8%E7%94%A8%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88/"/>
    <id>https://callmejay.github.io/2019/01/14/JavaScript常用几种继承方案/</id>
    <published>2019-01-14T01:59:22.000Z</published>
    <updated>2019-02-18T10:45:02.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><blockquote>
<p>构造函数，原型和实例之间的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个原型对象的指针。</p>
</blockquote>
<p>继承的本质是复制，即重写原型对象，代之以新类型的实例。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">"animals"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animals.prototype.getType = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"cat"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里是关键，创建 Animals 的实例，并将该实例赋值给 Cat.prototype</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animals();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.getType());</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0107fd80c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="原型链继承"></p>
<p>原型链方案存在的缺点：多个实例对<em>引用类型</em>的操作会被篡改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure>
<h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//继承自Animals</span></span><br><span class="line">  Animals.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">alert(cat1.colors); <span class="comment">//"red,green,blue,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat();</span><br><span class="line">alert(cat2.colors); <span class="comment">//"red,green,blue"</span></span><br></pre></td></tr></table></figure>
<p>核心代码是<em>Animals.call(this)</em>，创建子类实例时调用<em>Animals</em>构造函数，于是<em>Cat</em>的每个实例都会将<em>Animals</em>中的属性复制一份。</p>
<p>缺点：</p>
<ul>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c010c537ff8imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="组合继承"></p>
<p>缺点：</p>
<ul>
<li>第一次调用<em>SuperType()</em>：给<em>SubType.prototype</em>写入两个属性 name，color。</li>
<li>第二次调用<em>SuperType()</em>：给<em>instance1</em>写入两个属性 name，color。</li>
</ul>
<p>实例对象<em>instance1</em>上的两个属性就屏蔽了其原型对象<em>SubType.prototype</em>的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p>
<h3 id="原生式继承"><a href="#原生式继承" class="headerlink" title="原生式继承"></a>原生式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  fuction F()&#123;&#125;;</span><br><span class="line">  fn.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>create()对传入其中的对象执行了一次<em>浅复制</em>，将构造函数 F 的原型直接指向传入的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<p>另外，ES5 中存在<em>Object.create()</em>的方法，能够代替上面的 object 方法。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = create(original); <span class="comment">// 通过调用 create() 函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以某种方式来增强对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>
<p>缺点（同原型式继承）;</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inhertPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类初始化实例属性和原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">"red"</span>, <span class="string">"yellow"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父类原型指向子类</span></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"xyc"</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"lxy"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance1.colors.push(<span class="string">"2"</span>); <span class="comment">// ["red", "blue", "green", "2"]</span></span><br><span class="line">instance1.colors.push(<span class="string">"3"</span>); <span class="comment">// ["red", "blue", "green", "3"]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0109df5438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="寄生式组合继承"></p>
<p>这个例子的高效率体现在它只调用了一次<em>SuperType</em>构造函数，并且因此避免了在<em>SubType.prototype</em>  上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<em>instanceof</em>和<em>isPrototypeOf()</em></p>
<p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p>
<h3 id="ES6-类继承-extends"><a href="#ES6-类继承-extends" class="headerlink" title="ES6 类继承 extends"></a>ES6 类继承 extends</h3><p><em>extends</em>关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中<em>constructor</em>表示构造函数，一个类中只能有一个构造函数，有多个会报出<em>SyntaxError</em>错误,如果没有显式指定构造方法，则会添加默认的<em>constructor</em>方法，使用例子如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter</span></span><br><span class="line">    get area() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method</span></span><br><span class="line">    calcArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rectangle.area);</span><br><span class="line"><span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Square'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> Square(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.area);</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure>
<p><em>extends</em>继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建对象，创建父类原型的一个副本</span></span><br><span class="line">  <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">  subType.prototype = <span class="built_in">Object</span>.create(superType &amp;&amp; superType.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">      value: subType,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (superType) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">      ? <span class="built_in">Object</span>.setPrototypeOf(subType, superType)</span><br><span class="line">      : (subType.__proto__ = superType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、函数声明和类声明的区别<br>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个 ReferenceError。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Rectangle();</span><br><span class="line"><span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>2、ES5 继承和 ES6 继承的区别</p>
<ul>
<li>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.call(this)）.</li>
<li>ES6 的继承有所不同，实质上是先创建父类的实例对象 this，然后再用子类的构造函数修改 this。因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法，否则新建实例报错。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;构造函数，原型和实例之间的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，实例都包含一个原型对象的指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;继承的本质是复制，即重写原型对象，代之以新类型的实例。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="继承" scheme="https://callmejay.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>基础知识总结-1</title>
    <link href="https://callmejay.github.io/2018/10/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-1/"/>
    <id>https://callmejay.github.io/2018/10/30/基础知识总结-1/</id>
    <published>2018-10-30T12:49:11.000Z</published>
    <updated>2019-02-18T10:52:46.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-语法糖的实现"><a href="#new-语法糖的实现" class="headerlink" title="new 语法糖的实现"></a>new 语法糖的实现</h3><p>1, 创建一个新的对象<br>2, 链接到原型<br>3, 绑定this<br>4, 返回新的对象</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个新的对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 获得构造函数</span></span><br><span class="line">  <span class="keyword">var</span> fn = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接到原型</span></span><br><span class="line">  obj.__proto__ = fn.prototype;</span><br><span class="line">  <span class="comment">// 绑定this 执行构造函数</span></span><br><span class="line">  <span class="keyword">var</span> result = fn.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 确保返回的是对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span>(result) === <span class="string">'object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟实现Call-和-apply"><a href="#模拟实现Call-和-apply" class="headerlink" title="模拟实现Call 和 apply"></a>模拟实现Call 和 apply</h3><p>可以从以下几点来考虑如何实现</p>
<ul>
<li>不传入第一个参数，那么默认为 window</li>
<li>改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="keyword">this</span>; <span class="comment">// this就是调用call的函数</span></span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 call 的思路，apply 的实现也类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否存在第二个参数 且为数组</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>] &amp;&amp; <span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>[<span class="number">1</span>]))&#123;</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vue双向绑定的简单实现（数据劫持和发布订阅）"><a href="#Vue双向绑定的简单实现（数据劫持和发布订阅）" class="headerlink" title="Vue双向绑定的简单实现（数据劫持和发布订阅）"></a>Vue双向绑定的简单实现（数据劫持和发布订阅）</h3><p>Vue内部实现实用了<code>Object.defineProperty()</code>和发布订阅模式来实现双向数据绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是不是对象</span></span><br><span class="line">  <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历对象，</span></span><br><span class="line">  <span class="keyword">for</span>(key <span class="keyword">in</span> data)&#123;</span><br><span class="line">    defineReactive(data,key,obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归子属性值</span></span><br><span class="line">  observe(value);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data,key,&#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      value = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">'Jay'</span>&#125;;</span><br><span class="line"></span><br><span class="line">observe(data);</span><br><span class="line"></span><br><span class="line">data.name = <span class="string">'John'</span>;  <span class="comment">// set value</span></span><br><span class="line">data.name; <span class="comment">// get value</span></span><br></pre></td></tr></table></figure>
<p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在解析compile如上模板代码时，遇上 <code></code> 就会给属性 <code>name</code> 添加发布订阅。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  addSub( sub )&#123;</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  notify()&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach( <span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher 是watcher和dep关联的唯一桥梁，任何时候，都必须保证Dep.target只有一个值。</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj,key,cb)&#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]; <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空 保证只有一个</span></span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update()&#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="comment">// this.value = this.obj[this.key]; ？？ 上面已经获取 这里应该不用二次获取了</span></span><br><span class="line">    <span class="comment">// 调用 update 更新Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;;</span><br><span class="line">observe(data);</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update);</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'yyy'</span>;</span><br></pre></td></tr></table></figure>
<p>接下来对 <code>defineReactive</code>改造</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,value</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  observe(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> dp = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data,key,&#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span>(Dep.target)&#123;</span><br><span class="line">        dp.addSub(Dep.target);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'set value'</span>)</span><br><span class="line">      value = newVal;</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。</p>
<h3 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h3><p>在介绍缓存的时候，我们习惯将缓存分为强缓存和协商缓存两种。两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强制缓存判断HTTP首部字段：Cache-control，Expires。</p>
<p>Expires是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。但是该方法存在一个问题：服务器时间与客户端时间可能不一致。因此该字段已经很少使用，是HTTP1.0标准下的字段。</p>
<p>Cache-control中的max-age保存一个相对时间。例如Cache-Control: max-age = 484200，表示浏览器收到文件后，缓存在484200s内均有效。如果同时存在Cache-control和Expires，浏览器总是使用Cache-control。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存通过HTTP的Last-Modified，Etag字段进行判断。</p>
<p>Last-Modified是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送If-Modified-Since字段。服务器用本地Last-Modified时间与If-Modified-Since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。</p>
<p>Etag：资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。</p>
<blockquote>
<p>附<a href="https://juejin.im/post/5c136bd16fb9a049d37efc47" target="_blank" rel="noopener">前端缓存最佳实践</a></p>
</blockquote>
<h3 id="JS函数-add-1-2-3-4-实现无限极累加"><a href="#JS函数-add-1-2-3-4-实现无限极累加" class="headerlink" title="JS函数 add(1)(2)(3)(4) 实现无限极累加"></a>JS函数 add(1)(2)(3)(4) 实现无限极累加</h3><p>问题：用 JS 实现一个无限累加的函数 <code>add</code>，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)； <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)； <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以此类推</span></span><br></pre></td></tr></table></figure>
<p>思考🤔：我们知道打印函数时会自动调用 <code>toString()</code>方法，函数 <code>add(a)</code> 返回一个闭包 <code>sum(b)</code>，函数 <code>sum()</code> 中累加计算 <code>a = a + b</code>，只需要重写<code>sum.toString()</code>方法返回变量 <code>a</code> 就OK了。</p>
<p>实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  count = a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    count += b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sum.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="详细解析赋值、浅拷贝和深拷贝的区别"><a href="#详细解析赋值、浅拷贝和深拷贝的区别" class="headerlink" title="详细解析赋值、浅拷贝和深拷贝的区别"></a>详细解析赋值、浅拷贝和深拷贝的区别</h3><p>一、赋值（Copy）<br>赋值是将某一数值或对象赋给某个变量的过程，分为下面 2 部分</p>
<ul>
<li>基本数据类型：赋值，赋值之后两个变量互不影响</li>
<li>引用数据类型：赋<strong>址</strong>，两个变量具有相同的引用，指向同一个对象，相互之间有影响</li>
</ul>
<p>二、浅拷贝（Shallow Copy）</p>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p>简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的<strong>基本类型值</strong>，以及第一层的<strong>引用类型地址</strong>。</p>
<p>浅拷贝使用场景</p>
<ul>
<li><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>
<li>展开运算符 <code>Spread</code> 实际效果和 <code>Object.assign()</code> 是一样的</li>
<li><code>Array.prototype.slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code>和 <code>end</code>（不包括<code>end</code>）决定的原数组的<strong>浅拷贝</strong>。原始数组不会被改变。 相应的还有<code>concat</code>等.</li>
</ul>
<p>浅拷贝的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">      target[key] = source[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、深拷贝（Deep Copy）</p>
<p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p>
<p>深拷贝使用场景</p>
<ul>
<li><code>JSON.parse(JSON.stringify(object))</code> 存在问题：<ul>
<li><code>undefined</code>、<code>symbol</code> 和函数这三种情况，会直接忽略。</li>
<li>循环引用情况下，会报错。</li>
<li><code>new Date</code> 情况下，转换结果不正确。解决方法转成字符串或者时间戳就好了。</li>
</ul>
</li>
<li><code>jQuery.extend()</code></li>
<li><code>lodash.cloneDeep()</code></li>
</ul>
<p>深拷贝的自实现</p>
<p>其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判是否是对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep2</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; <span class="comment">// 非对象返回自身</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">        target[key] = cloneDeep2(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target[key] = source[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><code>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。</code></p>
<p>编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p>
<ul>
<li>词法作用域是在写代码或者定义时确定的，关注函数 <strong>在何处声明</strong>，作用域链基于代码嵌套。</li>
<li>动态作用域是在运行时确定的（<strong>this也是</strong>），关注函数 <strong>从何处调用</strong>，作用域链基于调用栈。</li>
<li>JavaScript并 <strong>不具备</strong> 动态作用域，它 <strong>只有词法作用域</strong>。但是<code>this</code>机制某种程度上很像动态作用域。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 词法作用域，关注函数在何处声明，a通过RHS引用到了全局作用域中的a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<h3 id="理解-let-循环"><a href="#理解-let-循环" class="headerlink" title="理解 let 循环"></a>理解 let 循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = j; <span class="comment">// 每个迭代重新绑定!</span></span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><ul>
<li>任何声明在某个作用域内的变量，都将附属于这个作用域。</li>
<li>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</li>
<li><code>var a = 2;</code>会被看成两个声明，<code>var a;</code>和<code>a = 2;</code>，第一个声明在 <strong>编译阶段</strong> 进行，第二个赋值声明会被留在原地等待 <strong>执行阶段</strong>。</li>
<li>所有的声明（变量和函数）都会被 <strong>移动到各自作用域的最顶端，这个过程叫做提升</strong></li>
<li>只有声明本身会被提升，而包括函数表达式在内的赋值或其他运行逻辑并不会提升。</li>
<li>函数声明和变量声明都会被提升，但是， <strong>函数首先被提升，然后才是变量</strong>。</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>当函数可以记住并访问所在的词法作用域，即使函数名是在当前词法作用域之外执行，这时就产生了闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 ---- 这就是闭包的效果</span></span><br></pre></td></tr></table></figure>
<p>bar()在自己定义的词法作用域以外的地方执行。</p>
<p>bar()拥有覆盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用，不会被垃圾回收器回收</p>
<p><code>bar()持有对foo()内部作用域的引用，这个引用就叫做闭包。</code></p>
<p><code>定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;new-语法糖的实现&quot;&gt;&lt;a href=&quot;#new-语法糖的实现&quot; class=&quot;headerlink&quot; title=&quot;new 语法糖的实现&quot;&gt;&lt;/a&gt;new 语法糖的实现&lt;/h3&gt;&lt;p&gt;1, 创建一个新的对象&lt;br&gt;2, 链接到原型&lt;br&gt;3, 绑定this&lt;br&gt;4, 返回新的对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>编写更优雅的JavaScript代码</title>
    <link href="https://callmejay.github.io/2018/09/10/%E7%BC%96%E5%86%99%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81/"/>
    <id>https://callmejay.github.io/2018/09/10/编写更优雅的JavaScript代码/</id>
    <published>2018-09-10T05:46:33.000Z</published>
    <updated>2019-02-18T10:51:10.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码技巧"><a href="#代码技巧" class="headerlink" title="代码技巧"></a>代码技巧</h3><h4 id="优先-ES6-新特性写法"><a href="#优先-ES6-新特性写法" class="headerlink" title="优先 ES6 新特性写法"></a>优先 ES6 新特性写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> formatArray = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组合并</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...arr1, ...arr2, <span class="string">'value'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...obj&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">'bao'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = person</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见对象属性取值前判断对象是否存在</span></span><br><span class="line"><span class="comment">// 如下是 react + antd 渲染 table 的简单代码，对象存在性判断 + 默认值设置</span></span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; downloadList &#125; = <span class="keyword">this</span>.props.store.downloadList</span><br><span class="line">  <span class="keyword">let</span> items = downloadList &amp;&amp; downloadList.items || []</span><br><span class="line">  <span class="keyword">let</span> itemCount = downloadList &amp;&amp; downloadList.itemCount || <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Table</span> <span class="attr">dataSource</span>=<span class="string">&#123;items&#125;</span> <span class="attr">pagination</span>=<span class="string">&#123;&#123;total:</span> <span class="attr">itemCount</span>&#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// 优化后</span></span><br><span class="line"><span class="xml">render()&#123;</span></span><br><span class="line"><span class="xml">  const &#123; items, itemCount &#125; = this.props.manageStore.downloadList || &#123;&#125;</span></span><br><span class="line">  return &lt;Table dataSource=&#123;items || []&#125; pagination=&#123;&#123;total: itemCount || 10&#125;&#125;/&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="优化逻辑判断语句"><a href="#优化逻辑判断语句" class="headerlink" title="优化逻辑判断语句"></a>优化逻辑判断语句</h4><p>大量的 if else 逻辑判断难以维护，且性能较差，可用多种方式代替</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象配置法</span></span><br><span class="line"><span class="comment">// 函数内部有条件判断，且 return 值时，满足条件立即return，而不要在结尾return</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v === <span class="string">"name"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"bao"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v === <span class="string">"age"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"18"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v === <span class="string">"height"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"180"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> cfg = &#123;</span><br><span class="line">  name: <span class="string">"bao"</span>,</span><br><span class="line">  age: <span class="string">"18"</span>,</span><br><span class="line">  height: <span class="string">"180"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">v</span> =&gt;</span> cfg[v];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组配置法</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="string">"hello"</span> || value === <span class="string">"world"</span> || value === <span class="string">"blabla"</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置数组形式</span></span><br><span class="line"><span class="keyword">const</span> rightValue = [<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"blabla"</span>];</span><br><span class="line"><span class="keyword">if</span> (rightValue.includes[value]) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="善用-amp-amp-、-和-三元运算"><a href="#善用-amp-amp-、-和-三元运算" class="headerlink" title="善用 &amp;&amp; 、 || 和 三元运算"></a>善用 &amp;&amp; 、 || 和 三元运算</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name === <span class="string">"bao"</span>) &#123;</span><br><span class="line">  someFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name === <span class="string">"bao"</span> &amp;&amp; someFunc();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">"bao"</span>) &#123;</span><br><span class="line">  someFunc();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  elseFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name === <span class="string">"bao"</span> ? someFunc() : elseFunc();</span><br></pre></td></tr></table></figure>
<h4 id="对象属性变量应用"><a href="#对象属性变量应用" class="headerlink" title="对象属性变量应用"></a>对象属性变量应用</h4><p>如在 react 中，调用 action 方法来获取数据，不同条件执行不同方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isMember) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> actions.getMemberInfo(params);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> actions.getCommonUserInfo(params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actionName = isMember ? <span class="string">"getMemberInfo"</span> : <span class="string">"getCommonUserInfo"</span>;</span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> actions[actionName](params);</span><br></pre></td></tr></table></figure>
<h4 id="用-Array-map-Array-filter-代替数组-for-循环实现简易写法"><a href="#用-Array-map-Array-filter-代替数组-for-循环实现简易写法" class="headerlink" title="用 Array.map(), Array.filter() 代替数组 for 循环实现简易写法"></a>用 Array.map(), Array.filter() 代替数组 for 循环实现简易写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">"A"</span>, <span class="string">"B"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 取出 arr 中数字项为新数组</span></span><br><span class="line"><span class="keyword">let</span> numArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arr[i] === <span class="string">"number"</span>) &#123;</span><br><span class="line">    numArr.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改用filter</span></span><br><span class="line"><span class="keyword">let</span> numArr2 = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">"number"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(numArr2); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获得新数组，元素是 arr 每个元素作为 value, key 为 arr 下标的对象, 不修改 arr</span></span><br><span class="line"><span class="keyword">let</span> strArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  strArr.push(&#123; [i]: arr[i] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改用 map</span></span><br><span class="line"><span class="keyword">let</span> strArr2 = arr.map(<span class="function">(<span class="params">item, i</span>) =&gt;</span> (&#123; [i]: arr[i] &#125;));</span><br><span class="line"><span class="built_in">console</span>.log(strArr2); <span class="comment">// [ &#123; '0': 1 &#125;,&#123; '1': 2 &#125;,&#123; '2': 3 &#125;, &#123; '3': 4 &#125;, &#123; '4': 'A' &#125;, &#123; '5': 'B' &#125; ]</span></span><br></pre></td></tr></table></figure>
<h4 id="浅拷贝、深拷贝-复杂数据类型对象深拷贝建议使用库来实现，如-lodash-cloneDeep"><a href="#浅拷贝、深拷贝-复杂数据类型对象深拷贝建议使用库来实现，如-lodash-cloneDeep" class="headerlink" title="浅拷贝、深拷贝 复杂数据类型对象深拷贝建议使用库来实现，如 lodash.cloneDeep"></a>浅拷贝、深拷贝 复杂数据类型对象深拷贝建议使用库来实现，如 <a href="http://lodash.think2011.net/cloneDeep" target="_blank" rel="noopener">lodash.cloneDeep</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">11</span>, <span class="attr">b</span>: &#123; <span class="attr">ba</span>: <span class="number">22</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.b === obj1.b); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝，这种方法需要对象能够被 json 序列化</span></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line"><span class="built_in">console</span>.log(obj3); <span class="comment">//  ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3 === obj1); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.b === obj1.b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="更高效的代码"><a href="#更高效的代码" class="headerlink" title="更高效的代码"></a>更高效的代码</h3><h4 id="使用局部变量代替引用类型查找"><a href="#使用局部变量代替引用类型查找" class="headerlink" title="使用局部变量代替引用类型查找"></a>使用局部变量代替引用类型查找</h4><p>局部变量的读取速度最快，而引用类型的数据读取需要按引用指针去查找，所以可以对多次使用的引用类型属性 使用局部变量读取一次，重复使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  person: &#123;</span><br><span class="line">    man: &#123;</span><br><span class="line">      bao: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = obj.person.man.bao.age;</span><br><span class="line"><span class="comment">// use age do many things</span></span><br></pre></td></tr></table></figure>
<h4 id="删除多个对象属性时先使属性为-null"><a href="#删除多个对象属性时先使属性为-null" class="headerlink" title="删除多个对象属性时先使属性为 null"></a>删除多个对象属性时先使属性为 null</h4><p>删除属性时，js 引擎会去查找该属性的值是否是其他对象的引用，所以删除前提前赋值为 null，可以减少 js 引擎的检测过程，提高效率</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  person: &#123;</span><br><span class="line">    man: &#123;</span><br><span class="line">      bao: &#123;</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.person = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.person;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代码技巧&quot;&gt;&lt;a href=&quot;#代码技巧&quot; class=&quot;headerlink&quot; title=&quot;代码技巧&quot;&gt;&lt;/a&gt;代码技巧&lt;/h3&gt;&lt;h4 id=&quot;优先-ES6-新特性写法&quot;&gt;&lt;a href=&quot;#优先-ES6-新特性写法&quot; class=&quot;headerlink&quot; title=&quot;优先 ES6 新特性写法&quot;&gt;&lt;/a&gt;优先 ES6 新特性写法&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 箭头函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; foo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组去重&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; formatArray = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt; =&amp;gt;&lt;/span&gt; [...new &lt;span class=&quot;built_in&quot;&gt;Set&lt;/span&gt;(arr)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组合并&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; newArr = [...arr1, ...arr2, &lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对象浅拷贝&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; newObj = &amp;#123;...obj&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 解构赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; person = &amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;bao&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; name, age &amp;#125; = person&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 常见对象属性取值前判断对象是否存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如下是 react + antd 渲染 table 的简单代码，对象存在性判断 + 默认值设置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; downloadList &amp;#125; = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.props.store.downloadList&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; items = downloadList &amp;amp;&amp;amp; downloadList.items || []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; itemCount = downloadList &amp;amp;&amp;amp; downloadList.itemCount || &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;Table&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;dataSource&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;items&amp;#125;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;pagination&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;#123;&amp;#123;total:&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;itemCount&lt;/span&gt;&amp;#125;&amp;#125; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;// 优化后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;render()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;  const &amp;#123; items, itemCount &amp;#125; = this.props.manageStore.downloadList || &amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &amp;lt;Table dataSource=&amp;#123;items || []&amp;#125; pagination=&amp;#123;&amp;#123;total: itemCount || 10&amp;#125;&amp;#125;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3之animation</title>
    <link href="https://callmejay.github.io/2018/08/17/CSS3%E4%B9%8Banimation/"/>
    <id>https://callmejay.github.io/2018/08/17/CSS3之animation/</id>
    <published>2018-08-17T08:43:59.000Z</published>
    <updated>2019-02-18T10:44:10.026Z</updated>
    
    <content type="html"><![CDATA[<p>首先，CSS Animation 需要指定动画一个周期持续的时间，以及动画效果的名称。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> <span class="number">1s</span> rainbow linear <span class="number">3</span> forwards normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>用 keyframes 关键字，定义 rainbow 效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#c00</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">background</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 animation 属性是简写，可以拆分成多个单独的属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  animation-name: rainbow; // 效果名称</span><br><span class="line">  animation-duration: 1s; // 执行一次所需是时间</span><br><span class="line">  animation-timing-function: linear; // 动画的速度曲线, linear是匀速，还有ease, ease-in加速,ease-out减速，cubic-bezier(http://cubic-bezier.com) 自定义速度模式等</span><br><span class="line">  animation-delay: 1s; // 延时多久执行动画</span><br><span class="line">  animation-fill-mode: forwards; // 动画保持在结束状态, forwards是停在结束时，backwards 是停在开始时，none 回到动画没开始状态</span><br><span class="line">  animation-direction: normal; // 动画播放的方向, 有alternate（start-end -&gt; end-start -&gt; start-end）、reverse(end-start -&gt; end-start)</span><br><span class="line">  animation-iteration-count: 3; // 动画执行次数 还有infinite</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: rainbow <span class="number">1s</span> linear infinite;</span><br><span class="line">  animation-play-state: paused; // 没有鼠标没有悬停时，动画状态是暂停；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  animation-play-state: running; // 一旦悬停，动画状态改为继续播放。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个栗子：实现动画的播放，暂停和重新开始<br><img src="http://oonulpk6h.bkt.clouddn.com/animation.gif" alt="效果图"></p>
<p>html 部分</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"control"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"play"</span> <span class="attr">value</span>=<span class="string">"播放"</span>&gt;</span>播放<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"pause"</span> <span class="attr">value</span>=<span class="string">"暂停"</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"restart"</span> <span class="attr">value</span>=<span class="string">"重新开始"</span>&gt;</span>重新开始<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css 部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">400</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes mymove1 &#123;</span><br><span class="line">  <span class="number">0</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">400</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100</span>% &#123;</span><br><span class="line">    margin-left: <span class="number">0</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  margin: <span class="number">50</span>px <span class="number">0</span>;</span><br><span class="line">  width: <span class="number">100</span>px;</span><br><span class="line">  height: <span class="number">100</span>px;</span><br><span class="line">  background-color: #5578a2;</span><br><span class="line">&#125;</span><br><span class="line">.play &#123;</span><br><span class="line">  animation: mymove <span class="number">5</span>s infinite ease;</span><br><span class="line">&#125;</span><br><span class="line">.restart &#123;</span><br><span class="line">  animation: mymove1 <span class="number">5</span>s infinite ease;</span><br><span class="line">&#125;</span><br><span class="line">.pause &#123;</span><br><span class="line">  animation-play-state: paused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>js 部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> play = <span class="built_in">document</span>.getElementById(<span class="string">"play"</span>),</span><br><span class="line">  pause = <span class="built_in">document</span>.getElementById(<span class="string">"pause"</span>),</span><br><span class="line">  restart = <span class="built_in">document</span>.getElementById(<span class="string">"restart"</span>),</span><br><span class="line">  text = <span class="built_in">document</span>.getElementById(<span class="string">"text"</span>),</span><br><span class="line">  box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"><span class="comment">// 暂停</span></span><br><span class="line">pause.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (box.classList.contains(<span class="string">"play"</span>)) &#123;</span><br><span class="line">    box.className = <span class="string">"pause play box"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    box.className = <span class="string">"pause restart box"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text.innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 播放</span></span><br><span class="line">play.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (box.classList.contains(<span class="string">"play"</span>)) &#123;</span><br><span class="line">    box.className = <span class="string">"play box"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    box.className = <span class="string">"restart box"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text.innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 重新开始</span></span><br><span class="line">restart.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (box.classList.contains(<span class="string">"play"</span>)) &#123;</span><br><span class="line">    box.className = <span class="string">"restart box"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    box.className = <span class="string">"play box"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text.innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考资料<br><a href="https://aotu.io/notes/2016/11/28/css3-animation-properties/index.html" target="_blank" rel="noopener">CSS3 animation 属性妙用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，CSS Animation 需要指定动画一个周期持续的时间，以及动画效果的名称。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:hover&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;animation&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1s&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1s&lt;/span&gt; rainbow linear &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; forwards normal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://callmejay.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记（原生函数）</title>
    <link href="https://callmejay.github.io/2018/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/07/29/学习笔记（原生函数）/</id>
    <published>2018-07-29T01:26:00.000Z</published>
    <updated>2019-02-18T10:49:14.270Z</updated>
    
    <content type="html"><![CDATA[<p>原生函数（native function）,也是 JavaScript 的内建函数（built-in function）.<br>常见的原生函数有：</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Array()</li>
<li>Object()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Date()</li>
<li>Error()</li>
<li>Symbol()</li>
</ul>
<a id="more"></a>
<p>原生函数可以被当做构造函数来使用，但是构造出来的对象和我们设想的不太一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// 'object' 不是 ‘string’</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.Prototype.toString.call(a) <span class="comment">// '[object String]'</span></span><br></pre></td></tr></table></figure>
<p><strong>通过构造函数(如 <code>new String(&#39;abc&#39;)</code>)创造出来的是封装了基本类型值（如‘abc’）的封装对象。</strong></p>
<p>可以通过<code>console.log(a)</code>来查看封装对象。</p>
<p>需要注意的是，<code>new String(&#39;abc&#39;)</code>创造出来的是字符串’abc’的封装对象，而不是基本类型值’abc’。</p>
<h3 id="内部属性-class"><a href="#内部属性-class" class="headerlink" title="内部属性[[class]]"></a>内部属性[[class]]</h3><p>所有 typeof 返回值为“object”的对象都包含一个内部属性[[class]],这个属性无法访问，只能通过<code>Object.prototype.toString()</code>来查看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toSting([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure>
<p>数组的内部[[class]]属性值是“Array”。对象的内部[[class]]属性和创建该对象的内建函数相对应。但是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="literal">null</span>); <span class="comment">// '[object Null]'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="literal">undefined</span>); <span class="comment">// '[object Undefined]'</span></span><br></pre></td></tr></table></figure>
<p>虽然是’null’和’undefined’这样的原生函数并不存在，但是内部[[class]]的属性值仍然是‘Null’和‘Undefined’</p>
<p>其他的基本类型值（如字符串，布尔，数字）的情况有所不同，通常称为‘包装’（boxing）;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="string">"123"</span>); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="number">123</span>); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString(<span class="literal">false</span>); <span class="comment">// [object Boolean]</span></span><br></pre></td></tr></table></figure>
<p>上面的基本类型值被各自的封装对象包装，所以他们的内部[[class]]属性值“String”,“Number”,“Boolean”。</p>
<h3 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h3><p>封装对象（object wrapper）扮演者重要的角色。我们都知道基本类型没有.length 和.toString()这样的属性和方法，那他们是如何做到的呢？没错！就是通过封装对象访问的。此时 JavaScript 会自动为 基本类型值 包装（box 或者 wrap）一个封装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase(); <span class="comment">// ABC</span></span><br></pre></td></tr></table></figure>
<p>这时候我们会想：如果我们要经常使用属性和方法。为甚不一开始就创建封装对象，这样 JavaScript 引擎就不用每次都自动创建了。But~~实际上 <strong>浏览器已经做了性能优化，直接使用封装对象反而会降低执行效率</strong>。所以我们不需要直接使用封装对象，让 JS 引擎自己去决定什么时候使用封装对象。</p>
<h3 id="封装对象释疑"><a href="#封装对象释疑" class="headerlink" title="封装对象释疑"></a>封装对象释疑</h3><p>比如 Boolean</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops"</span>); <span class="comment">// 实际上不会执行到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为 false 创建了一个封装对象，然而该对象总是返回真值（truthy）。</p>
<p>✔️ 如果想要自行封装基本类型值，可以使用<code>Object(..)</code>函数（不带 new 关键字）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(a);</span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> c; <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(b); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure>
<p>再次强调，<strong>我们一般不推荐使用封装对象。</strong></p>
<h3 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h3><p>✔️ 如果想得到封装对象中的基本类型值，可以使用<code>valueOf()</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">22</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">a.valueOf(); <span class="comment">// 'abc'</span></span><br><span class="line">b.valueOf(); <span class="comment">// 22</span></span><br><span class="line">c.valueOf(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在需要用到封装对象中的基本类型值得地方会发生隐式拆封。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure>
<h3 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h3><p>关于数组（array），对象（object），函数（function）和正则表达式，实际上，使用常量和使用构造函数效果是一样的。（创建的值都是通过封装对象来包装）。</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array(..)"></a>Array(..)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数Array(..)不要求必须带 new 关键字，不带时，它会被自动补上</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">a; <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">b; <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>Array 构造函数只带一个参数时，会被作为数组的预设长度(length),创造出来的只是一个空数组。</p>
<blockquote>
<p>我们将包含至少一个“空单元”的数组称为“稀疏数组”.</p>
</blockquote>
<h4 id="Date-和-Error"><a href="#Date-和-Error" class="headerlink" title="Date(..)和 Error(..)"></a>Date(..)和 Error(..)</h4><p>创建日期对象必须使用 new Date()。 Date(..)主要是用来获取当前的 Unix 时间戳（从 1970 年 1 月 1 日开始计算。以秒为单位）。</p>
<p>构造函数 Error(..)带不带 new 关键字都可以。<br>创建错误对象（error object）主要是为了获得当前运行栈的上下文。栈的上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。</p>
<p>错误对象通常与 throw 一起使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"x was not be provided"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误对象至少包含一个 message 属性。最好的办法是调用 toSting()来获得经过格式化的便于阅读的错误信息。</p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol()"></a>Symbol()</h4><p>ES6 中新加入了一个基本数据类型–符号（Symbol）。符号是具有唯一性的特殊值（并非绝对）。用它来命名对象属性不容易导致重名。</p>
<p>符号可以用作属性名，但是无论是在代码还是控制台上都无法查看和访问它的值，只会显示为诸如<code>Symbol(Symbol.create)</code>这样的值。</p>
<p>ES6 中有一些预定义符号，以 Symbol 的静态属性形式出现， 如 Symbol.create,Symbol.iterator 等。可以这样用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*..*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>✔️ 我们可以使用 Symbol(..)原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysym = <span class="built_in">Symbol</span>(<span class="string">"my own symbol"</span>);</span><br><span class="line">mysym; <span class="comment">// Symbol(my own symbol)</span></span><br><span class="line">mysym.toString(); <span class="comment">// "Symbol(my own symbol)"</span></span><br><span class="line"><span class="keyword">typeof</span> mysym; <span class="comment">// 'symbol'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mysym] = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwmPropertySymbols(a); <span class="comment">// [Symbol(my own symbol)]</span></span><br></pre></td></tr></table></figure>
<p>虽然符号实际上并非私有属性（通过<code>Object.getOwmPropertySymbols(..)</code>便可以公开获得对象中的所有符号），但是它却主要用于私有或者特殊属性。很多人稀罕用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生函数（native function）,也是 JavaScript 的内建函数（built-in function）.&lt;br&gt;常见的原生函数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String()&lt;/li&gt;
&lt;li&gt;Number()&lt;/li&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;li&gt;Array()&lt;/li&gt;
&lt;li&gt;Object()&lt;/li&gt;
&lt;li&gt;Function()&lt;/li&gt;
&lt;li&gt;RegExp()&lt;/li&gt;
&lt;li&gt;Date()&lt;/li&gt;
&lt;li&gt;Error()&lt;/li&gt;
&lt;li&gt;Symbol()&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="https://callmejay.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流</title>
    <link href="https://callmejay.github.io/2018/07/20/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://callmejay.github.io/2018/07/20/防抖节流/</id>
    <published>2018-07-20T06:22:45.000Z</published>
    <updated>2019-01-18T10:26:07.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>
<p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。因为防抖动的轮子很多，这里也不重新自己造个轮子了，直接使用大神分析的 underscore 的源码来解释防抖动。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        回调函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> debounced = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 如果已经执行过，不再执行</span></span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAction</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    container.innerHTML = count++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setUseAction = debounce(getUserAction, <span class="number">10000</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">container.onmousemove = setUseAction;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setUseAction.cancel();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">debounced解析</a></p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流的原理很简单：</p>
<p>如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h4 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="number">0</span>, context, args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行条件</span></span><br><span class="line">        <span class="keyword">if</span>(now - time &gt; wait)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            time = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer, context, args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = argumens;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context,args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较两个方法：</p>
<ul>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ul>
<p>有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！</p>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="comment">//下次触发 func 剩余的时间</span></span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果没有剩余的时间了或者你改了系统时间</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我有时也希望无头有尾，或者有头无尾，这个咋办？</p>
<p>那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:</p>
<p>leading：false 表示禁用第一次执行<br>trailing: false 表示禁用停止触发的回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">throttle解析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h3&gt;&lt;p&gt;你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。&lt;/p&gt;
&lt;p&gt;这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。因为防抖动的轮子很多，这里也不重新自己造个轮子了，直接使用大神分析的 underscore 的源码来解释防抖动。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript立即执行函数(IIFE)与闭包</title>
    <link href="https://callmejay.github.io/2018/06/22/JavaScript%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-IIFE-%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>https://callmejay.github.io/2018/06/22/JavaScript立即执行函数-IIFE-与闭包/</id>
    <published>2018-06-22T10:08:02.000Z</published>
    <updated>2019-02-24T04:55:45.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直没搞清楚立即执行函数和闭包之间的关系，总结一下：</p>
<ol>
<li>闭包有很多种理解：访问不到内部作用域，函数就是这样，所以函数就是闭包；</li>
<li>闭包还有一种理解：通过把函数内部的变量和方法返回出来，这样外部作用域就可以访问内部作用域了，并且立即执行函数和闭包之间没有必然的联系，虽然它们经常结合一起使用；</li>
<li>立即执行函数只是一种函数的调用方式；</li>
<li>闭包的目的则是外部函数可以访问内部函数的作用域；</li>
</ol>
<a id="more"></a>
<h3 id="立即执行函数（IIFE）"><a href="#立即执行函数（IIFE）" class="headerlink" title="立即执行函数（IIFE）"></a>立即执行函数（IIFE）</h3><p>立即执行函数是指声明完之后便直接执行的函数，这类函数通常是一次性使用的，因此没必要给这类函数命名，直接让它执行就好了；</p>
<p>一般情况下，只对匿名函数使用这种 <strong>立即执行函数</strong> 。它的核心是 <strong>闭包</strong> ，实现的目的有以下几个：</p>
<ul>
<li>不必为函数命名，避免污染全局变量；</li>
<li>*内部形成单独的块级作用域，封装一些私有变量；</li>
<li>内部变量执行完即销毁，不会占用更多的内存。</li>
</ul>
<p>javascript 中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 javascript 函数作用域链的特性，可以使用 IIFE 可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p>
<p>定义一个函数，函数后面加上括号，即可完成调用；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;();   <span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>
<p>引擎在遇到关键字 function 时，会默认将其当做是一个函数声明，函数声明必须有一个函数名，所以在执行到第一个左括号时就报语法错误了；</p>
<p>然后我们给它加上函数名:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;&#125;(); <span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line"><span class="comment">//在一个表达式后面加上括号，表示该表达式立即执行；</span></span><br><span class="line"><span class="comment">//而如果是在一个语句后面加上括号，该括号完全和之前的语句没什么关系，而只是一个分组操作符，用来控制运算中的优先级（小括号里的先运算）。</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以写成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;&#125;; ();<span class="comment">// SyntaxError: Unexpected token )</span></span><br><span class="line"><span class="comment">//分组操作符内的表达式不能为空，执行到右括号时，发现表达式为空，所以报错。</span></span><br></pre></td></tr></table></figure>
<p>然而函数表达式的函数名则可有可无；</p>
<p>在 function 前面加！、+、 -、=甚至是逗号等或者把函数用（）包起来都可以将函数声明转换成函数表达式；我们一般用（）把函数声明包起来或者用 = ；</p>
<p>我们在函数后面加上括号，然后再用另一个括号把它们都包起来；</p>
<p>javascript 中，括号内不允许包含语句，但可以是表达式；</p>
<p>引擎先遇到括号，然后遇到关键字 function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;());</span><br><span class="line"><span class="comment">//javascript中，括号内不允许包含语句，但可以是表达式；</span></span><br><span class="line"><span class="comment">//引擎先遇到括号，然后遇到关键字function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明 </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;)(); <span class="comment">//也可以这样写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;();</span><br><span class="line"><span class="comment">//我们可以在函数表达式后面直接加括号，而不用把函数包起来；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但还是推荐外部加上()：</span></span><br><span class="line"><span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;());</span><br><span class="line"><span class="keyword">var</span> c = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*code*/</span>&#125;)();</span><br><span class="line"><span class="comment">//因为外部如果没有()，我们得去function()&#123;/*code*/&#125;后面看是否存在()，判断b/c是一个函数还是一个函数内部的返回值</span></span><br><span class="line"><span class="comment">//为了代码的可读性，还是要在外部加上()，无论是否已经是表达式；</span></span><br></pre></td></tr></table></figure>
<p>javascript 只有函数拥有局部作用域，立即执行函数也有这一特点，我们可以利用它减少全局变量造成的空间污染；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(abc);<span class="comment">//function abc()&#123;...&#125;</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc);<span class="comment">//ReferenceError: abc is not defined</span></span><br><span class="line"><span class="comment">//函数表达式的标识符在外部作用域是找不到的，只有内部作用域可以找到</span></span><br><span class="line"><span class="comment">//立即执行函数的函数名在外部也是找不到的</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h3><p>闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作；简单的说，外部作用域就可以访问函数内部作用域的变量了。</p>
<p>由于作用域的关系，我们在函数外部是无法直接访问到函数内部的变量的，但是函数内部可以把这个变量传给全局变量或者返回出来，这样外部作用域就可以访问函数内部作用域的变量了；</p>
<p>简单的说，闭包就是有权限访问另一个函数内部作用域的变量的函数；</p>
<ol>
<li>javascript 具有自动垃圾回收机制，函数运行完之后，其内部的变量和数据会被销毁；</li>
<li>但是闭包就是在外部可以访问此函数内部作用域的变量，所以闭包的一个特点就是只要存在引用函数内部变量的可能，JavaScript 就需要在内存中保留这些变量。而且 JavaScript 运行时需要跟踪这个内部变量的所有外部引用，直到最后一个引用被解除（主动把外部引用赋为 null 或者页面关闭），JavaScript 的垃圾收集器才能释放相应的内存空间；这句话不是很好理解，下面用代码展示；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> abc = outer();</span><br><span class="line"><span class="comment">//outer()只要执行过，就有了引用函数内部变量的可能，然后就会被保存在内存中；</span></span><br><span class="line"><span class="comment">//outer()如果没有执行过，由于作用域的关系，看不到内部作用域，更不会被保存在内存中了；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc());<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(abc());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//因为a已经在内存中了，所以再次执行abc()的时候，是在第一次的基础上累加的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> def = outer();</span><br><span class="line"><span class="built_in">console</span>.log(def());<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(def());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//再次把outer()函数赋给一个新的变量def，相当于绑定了一个新的outer实例；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(a);//ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">//console.log(inner);//ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">//由于作用域的关系我们在外部还是无法直接访问内部作用域的变量名和函数名</span></span><br><span class="line"></span><br><span class="line">abc = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，释放内存；</span></span><br></pre></td></tr></table></figure>
<p>立即执行函数能配合闭包保存状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);    <span class="comment">//3 3 3</span></span><br><span class="line">        <span class="comment">//在执行到这一行时，发现匿名函数里没有i，然后向往外部作用域找，然后找到的其实是for循环执行完了的i，也就是2++，3</span></span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);    <span class="comment">//0 1 2</span></span><br><span class="line">    &#125;)(i),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//在立即执行函数内部i传给了x，并且锁在内存中，所以不会变</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>用立即函数配合闭包写插件，防止变量全局污染，以及保证内部变量的安全；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _sayName = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        str = str || <span class="string">'shane'</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _sayAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">        age = age || <span class="number">18</span>;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        SayName : _sayName,</span><br><span class="line">        SayAge : _sayAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过插件提供的API使用插件</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.SayName(<span class="string">'lucy'</span>)); <span class="comment">//lucy</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.SayName());<span class="comment">//shane</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.SayAge());<span class="comment">//18</span></span><br></pre></td></tr></table></figure>
<h4 id="一道经典面试题"><a href="#一道经典面试题" class="headerlink" title="一道经典面试题"></a>一道经典面试题</h4><p>下面的 ul 中，如何点击每一个 li 的时候弹出其下标?</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index 00000<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index 11111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>index 22222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>方法一： 闭包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>].children;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">            oLi[index].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(index);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        oLi[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二： 将下标作为对象的一个属性，添加到每个数组元素中，（name: “ i “, value: i 的值）;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>].children;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oLi.length; i++)&#123;</span><br><span class="line">        oLi[i].i = i;</span><br><span class="line">        oLi[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.i);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一直没搞清楚立即执行函数和闭包之间的关系，总结一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;闭包有很多种理解：访问不到内部作用域，函数就是这样，所以函数就是闭包；&lt;/li&gt;
&lt;li&gt;闭包还有一种理解：通过把函数内部的变量和方法返回出来，这样外部作用域就可以访问内部作用域了，并且立即执行函数和闭包之间没有必然的联系，虽然它们经常结合一起使用；&lt;/li&gt;
&lt;li&gt;立即执行函数只是一种函数的调用方式；&lt;/li&gt;
&lt;li&gt;闭包的目的则是外部函数可以访问内部函数的作用域；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="闭包" scheme="https://callmejay.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之发布订阅模式</title>
    <link href="https://callmejay.github.io/2018/06/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://callmejay.github.io/2018/06/11/设计模式之发布订阅模式/</id>
    <published>2018-06-11T06:34:55.000Z</published>
    <updated>2019-02-18T10:51:42.171Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看设计模式的知识，而且在工作当中，做一些打点需求的时候，正好直接利用了发布订阅模式去实现的，这让我对发布订阅这种设计模式更加的感兴趣了，于是借此机会也和大家说说这个好东东吧！</p>
<p>其实在早期还是用jq开发的时代，有很多地方，我们都会出现发布订阅的影子，例如有trigger和on方法</p>
<p>再到现在的vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来</p>
<p>那么废话不多说了，先来看看发布订阅模式到底何方神圣吧</p>
<a id="more"></a>
<p>说到发布订阅模式，它其实是一种对象间一对多的依赖关系(不是综艺节目以一敌百那种)，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知.</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>广泛用于异步编程中（替代了传统回调函数）</li>
<li>对象之间松散耦合的编写代码</li>
</ol>
<p>当然，胖子也不是一天吃成的。所以我们要想实现一个自己的发布订阅模式，以后在工作中使用，也需要一点点来的，表捉急，先从最简单的说起。</p>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> corp = &#123;&#125;;   <span class="comment">// 自定义一个公司对象</span></span><br><span class="line"><span class="comment">// 这里放一个列表用来缓存回调函数</span></span><br><span class="line">corp.list = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">corp.on = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 直接把fn先存到列表中</span></span><br><span class="line">    <span class="keyword">this</span>.list.push(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">corp.emit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当发布的时候再把列表里存的函数依次执行</span></span><br><span class="line">    <span class="keyword">this</span>.list.forEach( <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">corp.on(<span class="function"><span class="keyword">function</span> (<span class="params">position, salary</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的职位是：'</span> + position);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'期望薪水：'</span> + salary);</span><br><span class="line">&#125;);</span><br><span class="line">corp.on(<span class="function"><span class="keyword">function</span>(<span class="params">skill, hobby</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的技能有： '</span> + skill);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爱好： '</span> + hobby);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">corp.emit(<span class="string">'前端'</span>, <span class="number">10000</span>);</span><br><span class="line">corp.emit(<span class="string">'端茶和倒水'</span>, <span class="string">'足球'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    你的职位是：前端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的技能有： 前端</span></span><br><span class="line"><span class="comment">    爱好： 10000</span></span><br><span class="line"><span class="comment">    你的职位是：端茶和倒水</span></span><br><span class="line"><span class="comment">    期望薪水：足球</span></span><br><span class="line"><span class="comment">    你的技能有： 端茶和倒水</span></span><br><span class="line"><span class="comment">    爱好： 足球</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面通过自定义事件实现了一个简单的发布订阅模式，不过从打印出来的结果来看，有点小尴尬。Why？</p>
<p>因为在正常的情况下，希望打印的是酱紫的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    你的职位是：前端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的技能有： 端茶和倒水</span></span><br><span class="line"><span class="comment">    爱好： 足球</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>之所以出现此种情况，那是在on方法的时候一股脑的都将fn函数全部放到了列表中。然而需要的只是一个简单的key值，就可以解决了。让我们改写一下上面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> corp = &#123;&#125;;</span><br><span class="line"><span class="comment">// 这次换成一个对象类型的缓存列表</span></span><br><span class="line">corp.list = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">corp.on = <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果对象中没有对应的key值</span></span><br><span class="line">    <span class="comment">// 也就是说明没有订阅过</span></span><br><span class="line">    <span class="comment">// 那就给key创建个缓存列表</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.list[key])&#123;</span><br><span class="line">        <span class="keyword">this</span>.list[key] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把函数添加到对应key的缓存列表里</span></span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">corp.emit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是对应的key值</span></span><br><span class="line">    <span class="comment">// 直接用数组的shift方法取出</span></span><br><span class="line">    <span class="keyword">let</span> key = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 获取该键值中存在的所有函数</span></span><br><span class="line">    fns = <span class="keyword">this</span>.list[key];</span><br><span class="line">    <span class="comment">// 如果不存在或者没有返回</span></span><br><span class="line">    <span class="keyword">if</span>(!fns || fns.length ==== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历key值对应的缓存列表</span></span><br><span class="line">    <span class="comment">// 依次执行函数的方法</span></span><br><span class="line">    fns.forEach( <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line">corp.on(<span class="string">'join'</span>, (position, salary) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的职位是：'</span> + position);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'期望薪水：'</span> + salary);</span><br><span class="line">&#125;);</span><br><span class="line">corp.on(<span class="string">'other'</span>, (skill, hobby) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你的技能有： '</span> + skill);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'爱好： '</span> + hobby);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">corp.emit(<span class="string">'join'</span>, <span class="string">'前端'</span>, <span class="number">10000</span>);</span><br><span class="line">corp.emit(<span class="string">'join'</span>, <span class="string">'后端'</span>, <span class="number">10000</span>);</span><br><span class="line">corp.emit(<span class="string">'other'</span>, <span class="string">'端茶和倒水'</span>, <span class="string">'足球'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    你的职位是：前端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的职位是：后端</span></span><br><span class="line"><span class="comment">    期望薪水：10000</span></span><br><span class="line"><span class="comment">    你的技能有： 端茶和倒水</span></span><br><span class="line"><span class="comment">    爱好： 足球</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="来个通用的"><a href="#来个通用的" class="headerlink" title="来个通用的"></a>来个通用的</h4><p>现在来搞个通用的发布订阅模式实现，和刚才的差不多，不过这次起名也要隆重些了，直接叫event吧，看代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">    list: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    on(key,fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.list[key])&#123;</span><br><span class="line">            <span class="keyword">this</span>.list[key] = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.list[key].push(fn);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    emit()&#123;</span><br><span class="line">        <span class="keyword">let</span> key = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">        fns = <span class="keyword">this</span>.list[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.length === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fns.forEach( <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            cb.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    remove(key,fn)&#123;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.list[key];</span><br><span class="line">        <span class="comment">// 如果不存在对应的key</span></span><br><span class="line">        <span class="keyword">if</span>(!fns) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果没有传入函数，就会将key值对应缓存列表中的函数都清空掉</span></span><br><span class="line">        <span class="keyword">if</span>(!fn) fns &amp;&amp; (fns.length = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果都存在</span></span><br><span class="line">        fns.forEach( <span class="function">(<span class="params">cb,i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cb === fn) &#123;</span><br><span class="line">                fns.splice(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'一起喵喵喵'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'一起旺旺旺'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.on(<span class="string">'pet'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接收数据'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">event.on(<span class="string">'pet'</span>, cat);</span><br><span class="line">event.on(<span class="string">'pet'</span>, dog);</span><br><span class="line"><span class="comment">// 取消dog方法的订阅</span></span><br><span class="line">event.remove(<span class="string">'pet'</span>, dog);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">event.emit(<span class="string">'pet'</span>, [<span class="string">'二哈'</span>, <span class="string">'波斯猫'</span>]);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    接收数据</span></span><br><span class="line"><span class="comment">    [ '二哈', '波斯猫' ]</span></span><br><span class="line"><span class="comment">    一起喵喵喵</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这样其实就实现了一个可以使用的发布订阅模式了，其实说起来也是比较简单的，来一起屡屡思路吧.</p>
<p><strong>思路</strong>：</p>
<ul>
<li>创建一个对象(缓存列表)</li>
<li>on方法用来把回调函数fn都加到缓存列表中</li>
<li>emit方法取到arguments里第一个当做key，根据key值去执行对应缓存列表中的函数</li>
<li>remove方法可以根据key值取消订阅</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>优点：</strong></p>
<ul>
<li>对象之间的解耦</li>
<li>异步编程中，可以更松耦合的代码编写</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>创建订阅者本身要消耗一定的时间和内存</li>
<li>多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护</li>
</ul>
<p>强如发布订阅模式，也是劲酒虽好，不要贪杯的道理哦。过度使用的话，都会出现上述缺点的问题。不过合理开发合理利用，这都不是什么大问题的。</p>
<p><a href="https://juejin.im/post/5b125ad3e51d450688133f22" target="_blank" rel="noopener">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看设计模式的知识，而且在工作当中，做一些打点需求的时候，正好直接利用了发布订阅模式去实现的，这让我对发布订阅这种设计模式更加的感兴趣了，于是借此机会也和大家说说这个好东东吧！&lt;/p&gt;
&lt;p&gt;其实在早期还是用jq开发的时代，有很多地方，我们都会出现发布订阅的影子，例如有trigger和on方法&lt;/p&gt;
&lt;p&gt;再到现在的vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来&lt;/p&gt;
&lt;p&gt;那么废话不多说了，先来看看发布订阅模式到底何方神圣吧&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="设计模式" scheme="https://callmejay.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://callmejay.github.io/2018/06/04/%E6%A0%91/"/>
    <id>https://callmejay.github.io/2018/06/04/树/</id>
    <published>2018-06-04T07:27:53.000Z</published>
    <updated>2018-06-11T06:27:17.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p>
<p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。<br><a id="more"></a></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&amp;h=267&amp;f=png&amp;s=11622" alt=""></p>
<h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p>
<p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&amp;h=485&amp;f=png&amp;s=36796" alt=""></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">this</span>.size++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p>
<p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p>
<p>以下都是递归实现，如果你想学习非递归实现，可以 <a href="../Algorithm/algorithm-ch.md#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">点击这里阅读</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._pre(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.left)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._mid(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._mid(node.left)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._back(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._back(node.left)</span><br><span class="line">    <span class="keyword">this</span>._back(node.right)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">breadthTraversal() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue()</span><br><span class="line">    <span class="built_in">console</span>.log(n.value)</span><br><span class="line">    <span class="keyword">if</span> (n.left) q.enQueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getMin() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMax(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">floor(v) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._floor(<span class="keyword">this</span>.root, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.value === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="keyword">this</span>._floor(node.right, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>排名</strong>，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 <code>size</code> 属性。该属性表示该节点下有多少子节点（包含自身）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">select(k) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p>
<ul>
<li>需要删除的节点没有子树</li>
<li>需要删除的节点只有一条子树</li>
<li>需要删除的节点有左右两条树</li>
</ul>
<p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delectMin() &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delectMin(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = <span class="keyword">this</span>._delectMin(node.left)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</p>
<p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p>
<p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">delect(v) &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delect(<span class="keyword">this</span>.root, v)</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    node.right = <span class="keyword">this</span>._delect(node.right, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="keyword">this</span>._delect(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node.right</span><br><span class="line">    <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="keyword">this</span>._delectMin(node.right)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left</span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;p&gt;树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。&lt;/p&gt;
&lt;p&gt;二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://callmejay.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://callmejay.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://callmejay.github.io/2018/03/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://callmejay.github.io/2018/03/17/排序算法/</id>
    <published>2018-03-17T09:19:10.000Z</published>
    <updated>2019-05-23T07:07:49.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><blockquote>
<p>大家开始学习冒泡排序的，一般都是从冒泡排序开始，这是最简单的排序，，但是从运算时间来说，冒泡排序是最差的一个。</p>
</blockquote>
<a id="more"></a>
<p>算法描述</p>
<blockquote>
<p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p>
</blockquote>
<p>先来实现一下冒泡排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意当算法执行外循环的第二轮时，最后两个数组已经是正确排序了，尽管如此，在后续的比较中，它们还一直在进行着比较，即便这是不必要的。因此，我们可以改进一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改进冒泡排序： 设置一标志性变量 pos,用于记录每趟排序中最后一次进行交换的位置。由于 pos 位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到 pos 位置即可。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">let</span> pos; <span class="comment">// 先声明标志变量</span></span><br><span class="line">  <span class="keyword">var</span> i = len - <span class="number">1</span>; <span class="comment">//初始时,最后位置保持不变</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pos = <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        pos = j; <span class="comment">//记录交换的位置</span></span><br><span class="line">        <span class="keyword">var</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    i = pos; <span class="comment">//为下一趟排序作准备</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序动图演示<br><img src="http://oonulpk6h.bkt.clouddn.com/bubblesort.gif" alt="冒泡排序"></p>
<h3 id="选择排序（Select-Sort）"><a href="#选择排序（Select-Sort）" class="headerlink" title="选择排序（Select Sort）"></a>选择排序（Select Sort）</h3><blockquote>
<p>选择排序是一种简单直观的排序算法，它的工作原理是：首先找到数据结构中的最小值,然后将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SelectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">var</span> indexMin, temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    indexMin = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[indexMin] &gt; arr[j]) indexMin = j; <span class="comment">// 找到最小的值，保存其索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i !== indexMin) &#123;</span><br><span class="line">      <span class="comment">// 交换位置sels</span></span><br><span class="line">      temp = arr[i];</span><br><span class="line">      arr[i] = arr[indexMin];</span><br><span class="line">      arr[indexMin] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择排序动图演示<br><img src="http://oonulpk6h.bkt.clouddn.com/selectSort.gif" alt="选择排序"></p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>算法介绍</p>
<blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<p>算法的描述和实现<br>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> temp, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp)&#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进插入排序：查找插入位置时使用二分查找的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryInsertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = arr[i],</span><br><span class="line">        left = <span class="number">0</span>,</span><br><span class="line">        right = i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[middle]) &#123;</span><br><span class="line">          right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[left] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"arr is not an Array"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序演示图示<br><img src="http://oonulpk6h.bkt.clouddn.com/insertSort.gif" alt="选择排序"></p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<p>算法介绍</p>
<blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。</p>
</blockquote>
<p>算法描述和实现<br>具体算法描述如下：</p>
<ol>
<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (arr &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">  left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">  right = arr.slice(middle);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift());</span><br><span class="line"></span><br><span class="line">  result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序动图演示<br><img src="http://oonulpk6h.bkt.clouddn.com/mergeSort.gif" alt="选择排序"></p>
<h3 id="快速排序（Quicksort）"><a href="#快速排序（Quicksort）" class="headerlink" title="快速排序（Quicksort）"></a>快速排序（Quicksort）</h3><blockquote>
<p>快速排序是处理大数据最快的排序算法之一，它也是一种分而治之的算法，通过递归方式将数据依次分解为包含较小元素和较大元素的不同子序列，会不断重复这个步骤，直到所有的序列全部为有序的，最后将这些子序列一次拼接起来，就可得到排序好的数据。</p>
</blockquote>
<p>算法描述和实现<br>具体算法描述如下：</p>
<p>该算法首先要从数列中选出一个元素作为基数（pivot）。接着所有的数据都将围绕这个基数进行，将小于改基数的元素放在它的左边，大于或等于它的数全部放在它的右边，对左右两个小数列重复上述步骤，直至各区间只有1个数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">var</span> pivot = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat( pivot, quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;&lt;a href=&quot;#冒泡排序（Bubble-Sort）&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序（Bubble Sort）&quot;&gt;&lt;/a&gt;冒泡排序（Bubble Sort）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;大家开始学习冒泡排序的，一般都是从冒泡排序开始，这是最简单的排序，，但是从运算时间来说，冒泡排序是最差的一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="https://callmejay.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入对象</title>
    <link href="https://callmejay.github.io/2018/03/07/JavaScript%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1/"/>
    <id>https://callmejay.github.io/2018/03/07/JavaScript深入对象/</id>
    <published>2018-03-07T15:03:40.000Z</published>
    <updated>2019-02-18T10:46:04.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="简单做法"><a href="#简单做法" class="headerlink" title="简单做法"></a>简单做法</h4><h5 id="使用-Object-构造函数创建"><a href="#使用-Object-构造函数创建" class="headerlink" title="使用 Object 构造函数创建"></a>使用 Object 构造函数创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象实例的创建</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.key = <span class="string">"value"</span>; <span class="comment">//使用构造函数创建一个空对象，并赋值s</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="使用对象字面量表示法创建"><a href="#使用对象字面量表示法创建" class="headerlink" title="使用对象字面量表示法创建"></a>使用对象字面量表示法创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="string">"value1"</span>,</span><br><span class="line">  key2: <span class="string">"value2"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字面量表示法与 Object 构造函数创建法唯一的区别是，在字面量表示法里你可以给对象添加多个 键/值 对，但是在构造形式中你必须逐个添加属性。</p>
<p>现在 ES6 可以使用更简洁的方式创建对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> sex = <span class="string">"sexy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"jay"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简洁表示法，等同于 age: age</span></span><br><span class="line">  age,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简洁表示法，等同于 sayName： function() &#123;&#125;</span></span><br><span class="line">  sayName() &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//属性名表达式，等同于 lover:'rose'</span></span><br><span class="line">  [<span class="string">"lo"</span> + <span class="string">"ver"</span>]: <span class="string">"rose"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性名表达式，等同于 sexy: 'male'</span></span><br><span class="line">  [sex]: <span class="string">"male"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 ‘[object Object]’，这一点要特别小心。</p>
</blockquote>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>即用函数来封装创建对象的细节。多次调用该函数来创建多个相似对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = createPerson(<span class="string">"a"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> b = createPerson(<span class="string">"b"</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式虽然解决多创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<h4 id="模仿‘类’的设计"><a href="#模仿‘类’的设计" class="headerlink" title="模仿‘类’的设计"></a>模仿‘类’的设计</h4><h5 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h5><p>构造函数包括像 Array,Object 这样的原生构造函数，他们在 js 运行时会自动出现在执行环境中。此外，我们可以创建自定义构造函数，从而定义自定义类型的属性和方法。现在构造函数重写上个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Person(<span class="string">"a"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>构造函数就是普通的函数，不存在特殊语法。构造函数与其他函数唯一的区别就在于调用他们的方式不同。任何函数只要通过<code>new</code>操作符来调用，那它就可以作为构造函数。<br>使用<code>new</code>操作符调用函数，或者说发生构造函数调用时，会自动执行下面操作：</p>
<ol>
<li>创建一个全新的对象。</li>
<li>这个新对象会被执行[[Prototype]] 链接。</li>
<li>这个新对象会绑定到函数调用时的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式的函数调用会自动返回这个新对象。</li>
</ol>
<p>由于构造函数调用时会自动执行 [[Prototype]] 链接，也就是把新对象的原型链指向构造函数的 prototype。所以使用<code>instanceof</code>或<code>isPrototypeOf</code>方法可以判断他们的类型。</p>
<p>上面这种构造函数解决了对象类型识别的问题，但是每个方法都要在每个实例上重新创建一遍，在上面的例子中，a 和 b 都有个名为<code>sayName()</code>的方法，这两个方法虽然名字、内容、功能相同，但却分别在 a 和 b 中都重新创建了一次，这是没有必要的。</p>
<p>更好的方法应该是将公用的方法放到他们的原型上，也就是接下来要说的原型模式。</p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>所有函数都有一个不可枚举的 prototype(原型)属性，这个属性时一个指针，指向一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>上一节【构造函数模式】里面有说，<code>new</code>操作符会新建一个对象，并把该对象的原型链指向构造函数的 <code>prototype</code> 所指向的对象。</p>
<p>这里出现了一个重点词<strong>原型链</strong>，我们先解释下什么叫做原型链。</p>
<blockquote>
<p>原型链也被称为 [[Prototype]]链，是对象的内置属性。原型链是 ECMAScript 中实现继承的主要办法，其基本思想就是让一个引用类型继承另一个引用类型的属性和和方法。</p>
</blockquote>
<p>例如我们新建个对象 a，然后给它指定它的原型链的指向：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b);</span><br><span class="line"></span><br><span class="line">a.x; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这个例子中我们通过<code>Object.setPrototypeOf()</code>方法把 a 的原型链指向 b，然后 a 就继承了 b 的属性，当查询 a 中没有的 x 属性时，会指向到 b.x 的值。</p>
<p>这里原理上说是委托比说是继承更符合真实情况。因为真实情况如上段所说是 a 把自身没有的属性查询委托给 b，如果 b 中也没 x 属性的话，系统会继续循着原型链往上查。所有普通的 [[Prototype]] 链最终都会指向内置的 <code>Object.prototype</code>。如果 <code>Object.prototype</code> 也没有的话就会提示 <code>undefined</code>。</p>
<p>这里提示一下，由于所有普通的对象都”源于“（或者说把 [[Prototype]] 链的顶端设置为）这个 <code>Object.prototype</code> 对象，所以它包含 Javascript 中许多通用的功能。</p>
<p>上面说过，new 操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 属性所指向的对象（即原型对象）。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">"h"</span>,</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">a.sayName(); <span class="comment">// h</span></span><br></pre></td></tr></table></figure>
<p>这种方法因为重写了 Person.prototype,所以默认的 Person.prototype.constructor 也会丢失，如果要修复 constructor,可以使用<code>Object.defineProperty()</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不过实例一般都是要有属于自己的全部属性的。所以日常开发中设计对象更常见的做法是构造函数模式跟原型模式组合使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>);</span><br><span class="line">a.sayName(); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p>这里很像一些面向“类”的语言的行为，a 和 b 是 Person 类的实例，a 和 b 继承了 Person 类的特性。但实际上 JavaScript 和面向类的语言不同，它并没有类作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。</p>
<h5 id="使用-ES6-Class"><a href="#使用-ES6-Class" class="headerlink" title="使用 ES6 Class"></a>使用 ES6 Class</h5><p>上面说的原型是通过构造函数，定义并生成新对象。但这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。</p>
<p>不过需要注意的是， ES6 的 class 语法是并不是向 JavaScript 中引入了一种新的“ 类” 机制。 <strong>class 基本上只是现有 [[Prototype]] 机制的一种语法糖。</strong></p>
<p>也就是说， class 并不会像传统面向类的语言一样在声明时静态复制所有行为。 如果你（ 有意或无意） 修改或者替换了父“ 类” 中的一个方法， 那子“ 类” 和所有实例都会受到影响， 因为它们在定义时并没有进行复制， 只是使用基于 [[Prototype]] 的实时委托。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> Foo; <span class="comment">// 'function'</span></span><br><span class="line">Foo === Foo.prototype.constructor; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Foo(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">a.sayName(); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p>构造函数的 prototype 属性，在 ES6 的‘类’上继续存在，事实上，类的所有方法都定义上类的 prototype 属性上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  toString() &#123;&#125;</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Foo.prototype, &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6 Class 与 普通构造函数的不同点主要有 4 个：</p>
<p>(1)constructor 方法</p>
<p><code>constructor</code>方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<p><code>constructor</code>方法默认返回实例对象（即 this），完全可以指定返回另外一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，constructor 函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。</p>
<p>类的构造函数，不使用 new 是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure>
<p>(2)类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与普通构造函数的行为不一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Foo.prototype)  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Foo.prototype)   <span class="comment">// ["constructor","sayName"]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Foo.prototype); <span class="comment">// ["sayName"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Foo.prototype); <span class="comment">// ["constructor", "sayName"]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，sayName 方法是 Foo 类内部定义的方法，它是不可枚举的。而定义在 Foo.prototype 中的话则是可枚举的。</p>
<p>(3) Class 不存在变量提升（hoist），这点与 ES5 完全不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<p>(4)子类的继承</p>
<p>Class 之间可以通过 <code>extends</code> 关键字实现继承，这比普通构造函数通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个 Bar 类，该类通过 extends 关键字，继承了 Foo 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Foo 类。下面，我们在 Bar 内部加上代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayProfile() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> years old`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, lover) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的 constructor(name,age), 约等于普通构造函数中的 Foo.call(this, name, age)</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="built_in">Number</span>(<span class="keyword">this</span>.age) + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">this</span>.lover = lover;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayIntro() &#123;</span><br><span class="line">    alert(</span><br><span class="line">      <span class="keyword">super</span>.sayProfile() +</span><br><span class="line">        <span class="string">`, my lover is <span class="subst">$&#123;<span class="keyword">this</span>.lover&#125;</span>, again, I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"Jack"</span>, <span class="string">"20"</span>, <span class="string">"Rose"</span>);</span><br><span class="line"></span><br><span class="line">a.sayIntro(); <span class="comment">// "hello, my name is Jack, 25 years old, my lover is Rose, again, I am</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，子类 Bar 的<code>constructor</code>方法和<code>sayIntro</code>方法之中，都出现了<code>super</code>关键字，<code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。在上面的代码中 子类 Bar 的构造函数中<code>super(name, age)</code>相当于<code>Foo.prototype.constructor.call(this, name, age)</code>。作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<p><strong>要注意的是，子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错</strong>。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到 this 对象。在子类的构造函数中，只有调用<code>super</code>之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p>
<p>普通构造函数的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面<code>（Foo.call(this)）</code>。<strong>ES6 Class 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改 this。</strong></p>
<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种情况，<strong><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong>上面代码代码中的 <code>super.sayProfile()</code>就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向 <code>Foo.prototype</code>，所以<code>super.sayProfile()</code>就相当于<code>Foo.prototype.sayProfile()</code>。</p>
<p>ES6 规定，通过<code>super</code>调用父类的方法时，<code>super</code>会绑定子类的 this。所以<code>sayProfile</code>输出的<code>this.age</code>是子类 Bar 的 age 25 岁。</p>
<p>刚刚说到在静态方法中<code>super</code>指向父类。</p>
<blockquote>
<p>静态方法</p>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sayHi() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.sayHi(); <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.sayHi(); <span class="comment">// TypeError: a.sayHi is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中<code>ayHi()</code>就是 Foo 的静态方法，它只能通过 Foo 调用，不能通过 Foo 的实例调用。</p>
<p>如果<code>super</code>作为对象用在静态方法中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sayHi() &#123;</span><br><span class="line">    <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="comment">// 原型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"oops"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sayBob() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sayHi() + <span class="string">"Bob"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.sayBob(); <span class="comment">// 'hello Bob'</span></span><br></pre></td></tr></table></figure>
<h4 id="面向委托的设计（对象关联风格）"><a href="#面向委托的设计（对象关联风格）" class="headerlink" title="面向委托的设计（对象关联风格）"></a>面向委托的设计（对象关联风格）</h4><p>有些开发者比较诟病这种模仿“类”的设计模式，因为继承意味着复制，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联（我们把这种关联成为原型链），这样对象就可以通过委托访问另一个对象的属性和函数。委托这个术语可以更加准确地描述 JavaScript 中的对象关联机制。</p>
<p>即便通过 ES6 class 让 js 看起来更像“类”，也只是一种模仿的假象。在传统的面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改，但是 Javascript 最强大的特性就是它的动态性，任何对象的定义都可以修改（除非你把它定义为不可变）。</p>
<p>一些开发者认为 ES6 的 class 想伪装成一种很好的语法问题的解决方案，但实际上却让问题更难解决且让 JavaScript 更难理解。因为它隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托机制。让本来简洁优雅的 [[Prototype]] 机制变的非常别扭。</p>
<p>我们比较下继承与委托设计的区别。</p>
<p>我们先想想类（继承）的设计方法：先定义一个通用的父类 F，在父类 F 中定义所有任务都有的行为，接着定义子类 a 和 b，他们都继承自父类并且会添加一些特殊行为来处理对应的任务。</p>
<p>再用委托的思想来考虑同样的问题：首先先定义一个对象 F，它包含所有任务都可以使用（委托）的具体行为。接着，对于每个任务你都会定义一个对象来储存对应的数据和行为，你会把特定的任务对象都关联到 F 功能对象上面，让他们在需要的时候可以进行委托。基本你可以想象成 a 和 F 之间是兄弟关系，a 完成不了的任务东西都委托给 F 完成。</p>
<blockquote>
<p>JavaScript 中原型链实际上是委托的关系而不是继承。委托行为意味着某些对象在找不到属性或方法引用时会把这个请求委托给另一个对象。</p>
</blockquote>
<p>我们先看一个使用类设计风格的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.intro = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"my name is "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.intro());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>);</span><br><span class="line">a.speak(); <span class="comment">// my name is a</span></span><br></pre></td></tr></table></figure>
<p>这个例子里子类 Bar 继承了父类 Foo，然后生成了 a 这个实例，a 通过 new 构造函数委托了 <code>Bar.prototype</code>，<code>Bar.prototype</code> 通过<code>Object.create()</code>方法委托了 <code>Foo.prototype()</code>。这种风格很常见，你应该已经熟悉了。</p>
<p>当然我们可以用 class 让这段代码看起来更简洁明了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  intro() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"my name is "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    alert(<span class="keyword">super</span>.intro());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">a.speak();</span><br></pre></td></tr></table></figure>
<p>现在再来看看同例的对象关联风格的设计：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Foo = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;,</span><br><span class="line">  intro: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"my name is "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar = <span class="built_in">Object</span>.create(Foo);</span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.intro());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">a.init(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">a.speak();</span><br></pre></td></tr></table></figure>
<p>这段代码中我们同样利用 [[Prototype]] 把 a 委托给 Bar 并把 Bar 委托给 Foo，和上段代码一样，我们仍然实现了三个对象的关联。</p>
<p>但非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。</p>
<h3 id="对象的内容"><a href="#对象的内容" class="headerlink" title="对象的内容"></a>对象的内容</h3><p>对象的内容是由一些储存在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p>
<h4 id="getter-与-setter"><a href="#getter-与-setter" class="headerlink" title="getter 与 setter"></a>getter 与 setter</h4><h5 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h5><p>get 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。该方法会覆盖单个属性默认的 [[Get]] 操作（获得属性值的操作）。</p>
<p>用法：</p>
<blockquote>
<p>{get prop() { … } } // prop 为要绑定到给定函数的属性名</p>
<p>{get <a href="">expression</a> { … } } //从 ECMAScript 2015 (ES6)开始，还可以使用一个计算的属性名的表达式绑定到给定的函数。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  get a() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以通过 defineProperty 创建</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="string">"b"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  enumable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObj.a; <span class="comment">// 2</span></span><br><span class="line">myObj.b; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">3</span>;</span><br><span class="line">myObj.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如上面例子，不管是对象文字语法中的<code>get a() { .. }</code>， 还是<code>defineProperty(...)</code>中的显式定义， 二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。</p>
<p>同时由于我们只定义了 a 的 getter， 所以对 a 的值进行设置时 set 操作会忽略赋值操作，且不会抛出错误。 为了让属性更合理， 我们还应当定义 setter。</p>
<h5 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h5><p>set 语法会覆盖单个属性默认的 [[Put]] 操作（赋值操作）。</p>
<p>通常来说 getter 和 setter 是成对出现的（ 只定义一个的话通常会产生意料之外的行为）。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  get a() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">  &#125;,</span><br><span class="line">  set a(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a_ = val * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.a = <span class="number">2</span>;</span><br><span class="line">myObj.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>注意，在本例中， 实际上我们把赋值（ [[Put]]） 操作中的值 2 存储到了另一个变量_a_中。 名称_a_只是一种惯例， 没有任何特殊的行为，和其他普通属性一样。</p>
<h4 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h4><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h5><p><code>for keys in object</code> 循环可以遍历对象的可枚举属性列表（包括 [[Prototype]] 原型链）。</p>
<p><code>for..in</code>循环是无法直接获取属性值的，你需要手动获取属性值。</p>
<p>需要注意的是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。</p>
<h5 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h5><p><code>for..of</code>循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 <code>next()</code> 方法来遍历所有返回值。</p>
<p>我们先看一下迭代器的定义：</p>
<blockquote>
<p><strong>可迭代协议</strong></p>
<p>可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可遍历对象并且有默认的迭代行为, 比如 Array、Map, 另一些类型则不是 (比如 Object) 。</p>
<p>为了变成可遍历对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链上的某个对象）必须有一个名字是 Symbol.iterator 的属性:</p>
</blockquote>
<p>数组有内置的 <code>@@iterator</code>， 因此<code>for..of</code>可以直接应用在数组上:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>我们再通过数组的<code>Symbol.iterator</code>属性看看<code>@@iterator</code>是怎么工作的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">it = myArr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">it.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>如你所见，调用迭代器的<code>next()</code>方法会返回形式为<code>{value: .., done: ..}</code>的值，<code>value</code>是当前的遍历值，<code>done</code>是一个布尔值，表示是否还有可以遍历的值。</p>
<p>上面示例中需要注意的一点，我们使用符号<code>Symbol.iterator</code>来获取对象的<code>@@iterator</code>内部属性。引用类似 <code>iterator</code> 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但<code>@@iterator</code>本身并不是迭代器对象，而是返回迭代器对象的函数——这点非常精妙并且重要。</p>
<p>可是普通对象没有内置的<code>@@iterator</code>，所以无法完成<code>for..of</code>遍历。制定者之所以这样做，有许多复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。</p>
<p>但我们可以给任何想遍历的对象自定义<code>@@iterator</code>，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObj, <span class="built_in">Symbol</span>.iterator, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: o[ks[idx++]],</span><br><span class="line">          done: idx &gt; ks.length</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 手动遍历 myObj</span></span><br><span class="line"><span class="keyword">var</span> it = myObj[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 for..of 遍历 myObj</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="对象的代理-Proxy"><a href="#对象的代理-Proxy" class="headerlink" title="对象的代理 Proxy"></a>对象的代理 Proxy</h4><p>ES6 中引入的 Proxy 是一个元编程的特性。元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。</p>
<p>Proxy 对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。也就说它可以 “代理” 对象的原生行为，替换为执行自定义行为。</p>
<p>Proxy 语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>其中，<code>new Proxy()</code>表示生成一个 Proxy 实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>举个栗子，我们知道当我们要获取对象的属性值的时候，对象内部会调用 get 方法去获取这个属性，如果该属性不存在在该对象中，则会继续向 [[Prototype]] 原型链向上寻找，一直找到 Object.prototype。</p>
<p>如果我们按上一节的方法给该属性设置了<code>get()</code>方法，则查询该属性值时会返回<code>get()</code> 方法的返回值。Proxy 可以给所有查询不到的属性设置统一的<code>get()</code>方法。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.x; <span class="comment">// 2</span></span><br><span class="line">obj.y; <span class="comment">// 3</span></span><br><span class="line">obj.z; <span class="comment">// 3</span></span><br><span class="line">a.y; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">obj.y = <span class="number">3</span>;</span><br><span class="line">a.y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>有一个技巧是把 Proxy 实例作为其他对象的原型对象，这样就可以让其他对象继承（或者说委托？）Proxy 实例的拦截方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"></span><br><span class="line">a.someprop; <span class="comment">// 233</span></span><br></pre></td></tr></table></figure>
<p>此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Proxy</span>.revocable(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = p.proxy;</span><br><span class="line">a.x; <span class="comment">// 1</span></span><br><span class="line">p.revoke();</span><br><span class="line">a.x; <span class="comment">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure>
<p><code>Proxy.revocable</code>方法返回一个对象，该对象的<code>proxy</code>属性是 Proxy 实例，<code>revoke</code>属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行<code>revoke</code>函数之后，再访问 Proxy 实例，就会抛出一个错误。</p>
<p><code>Proxy.revocable</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<p>包括 <code>get()</code>、<code>set()</code> 在内，Proxy 支持的拦截操作有十多种，包含了大部分对象的方法操作的拦截。具体请查阅 ECMAScript 6 入门 及 MDN 文档</p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><h4 id="原型相关-create-setPrototypeOf-getPrototypeOf"><a href="#原型相关-create-setPrototypeOf-getPrototypeOf" class="headerlink" title="原型相关 create,setPrototypeOf,getPrototypeOf"></a>原型相关 create,setPrototypeOf,getPrototypeOf</h4><h5 id="Object-create-proto-propertiesObject"><a href="#Object-create-proto-propertiesObject" class="headerlink" title="Object.create(proto, [ propertiesObject ])"></a>Object.create(proto, [ propertiesObject ])</h5><p>该方法使用指定的原型对象和其属性创建了一个新的对象。可理解为该方法会创建一个对象并把这个对象的 [[Prototype]]关联到指定对象。</p>
<p>需要注意的是，<code>Object.create(null)</code>会创建一个拥有空（或者 null）[[Prototype]] 链的对象，这个对象无法进行委托。由于这个对象没有原型链，所以<code>instanceof</code>操作符无法进行判断，因此总是返回 false。这些特殊的空 [[Prototype]] 对象通常被称作“字典”，他们完全不会受到原型链的干扰，因此非常适合用来储存数据。</p>
<h5 id="Object-setPrototypeOf-obj-prototype"><a href="#Object-setPrototypeOf-obj-prototype" class="headerlink" title="Object.setPrototypeOf(obj, prototype)"></a>Object.setPrototypeOf(obj, prototype)</h5><p>该方法是 ES6 的新方法，用于设置一个指定的对象的原型 ( 例如,内置的 [[Prototype]] 属性）到另一个对象或 null。可以代替 ES5 的<code>Object.create</code>。</p>
<p>例如有两个对象 a 和 b，我们需要把 b 设为 a 的原型，以便 a 可以继承 b 的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b);</span><br><span class="line"></span><br><span class="line">a.x; <span class="comment">//1</span></span><br><span class="line">a.y; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(a); <span class="comment">// ["x"]</span></span><br></pre></td></tr></table></figure>
<p>上例中把 b 设为 a 的原型，因此当向 a 查询 y 时，由于 a 本身没有 y 属性，所以会循着原型链查询到 b 的 y。</p>
<p>再例如有两个函数（函数也是对象哦！） Bar 和 Foo，我们需要把 Bar.prototype 关联到 Foo.prototype:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Foo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Bar</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关联 prototype</span></span><br><span class="line"><span class="comment">// ES6 之前需要抛弃默认的 Bar.prototype</span></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 开始可以直接修改现有的 Bar.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype, Foo.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>);</span><br><span class="line">a.sayName();</span><br></pre></td></tr></table></figure>
<p>如果不考虑<code>Object.create(..)</code>方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它其实比 ES6 及其之后的方法更短切可读性更高。</p>
<h5 id="Object-getPrototypeOf-obj"><a href="#Object-getPrototypeOf-obj" class="headerlink" title="Object.getPrototypeOf(obj)"></a>Object.getPrototypeOf(obj)</h5><p>该方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。如果没有继承属性，则返回 null 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(b) === a; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h3&gt;&lt;h4 id=&quot;简单做法&quot;&gt;&lt;a href=&quot;#简单做法&quot; class=&quot;headerlink&quot; title=&quot;简单做法&quot;&gt;&lt;/a&gt;简单做法&lt;/h4&gt;&lt;h5 id=&quot;使用-Object-构造函数创建&quot;&gt;&lt;a href=&quot;#使用-Object-构造函数创建&quot; class=&quot;headerlink&quot; title=&quot;使用 Object 构造函数创建&quot;&gt;&lt;/a&gt;使用 Object 构造函数创建&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对象实例的创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.key = &lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//使用构造函数创建一个空对象，并赋值s&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="对象" scheme="https://callmejay.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入数组</title>
    <link href="https://callmejay.github.io/2018/02/26/JavaScript%E6%B7%B1%E5%85%A5%E6%95%B0%E7%BB%84/"/>
    <id>https://callmejay.github.io/2018/02/26/JavaScript深入数组/</id>
    <published>2018-02-26T15:13:39.000Z</published>
    <updated>2019-02-18T10:46:16.959Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。</p>
<a id="more"></a>
<p><img src="http://oonulpk6h.bkt.clouddn.com/Array.png" alt="数组"></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><strong>length</strong><br>length 属性表示数组的长度，即其中元素的个数。<br>JavaScript 数组的 length 属性时可变的，当 length 属性被设置的更大时，整个数组的状态事实上不会发生变化，仅仅是 length 属性变大;当 length 属性被设置的比原来小时，则原先数组中索引大于或等于 length 的元素的值全部被丢失。</p>
<p><strong>prptotype</strong><br>返回对象类型原型的引用。prototype 属性是 object 共有的。<br>一般用来给数组实例添加方法。</p>
<p><strong>constructor</strong><br>表示创建对象的函数。<br>说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的创建</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// 创建一个length为5的数组 [undefined, undefined, undefined, undefined, undefined]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建数组并赋值 [1,2,3]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">5</span>); <span class="comment">// 创建一个length为3的数组，并里面赋值均为5 [5,5,5]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">7</span>); <span class="comment">// 创建数组并赋值[7]</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 创建数组并赋值 [1,2,4]</span></span><br></pre></td></tr></table></figure>
<h5 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个对象是不是一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">if</span> (arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">&#125; <span class="comment">// 方法1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">"[object Array]"</span>) &#123;</span><br><span class="line">&#125; <span class="comment">// 方法2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">&#125; <span class="comment">// 方法3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.constructor == <span class="built_in">Array</span>) &#123;</span><br><span class="line">&#125; <span class="comment">// 方法4</span></span><br></pre></td></tr></table></figure>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>Array.isArray(obj)</strong><br>检测对象是否 Array,是则范湖 true,否则为 false.<br><strong>Array.from(arrayLike,mapFn,thisArg)</strong><br>该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg 是可选参数，为执行 mapFn 函数时 this 的值。</p>
<p>所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，<strong>任何有 length 属性的对象，都可以通过 Array.from 方法转为数组。</strong></p>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arrayLike2 = &#123; <span class="attr">length</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArray = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a','b','c']</span></span><br><span class="line"><span class="keyword">let</span> newArray2 = <span class="built_in">Array</span>.from(arrayLike, i =&gt; &#123;</span><br><span class="line">  i + <span class="string">"1"</span>;</span><br><span class="line">&#125;); <span class="comment">// ['a1','b1','c1']</span></span><br><span class="line"><span class="keyword">let</span> newArray3 = <span class="built_in">Array</span>.from(arrayLike2); <span class="comment">// [undefined,undefined,undefined]</span></span><br><span class="line"><span class="keyword">let</span> newArray4 = <span class="built_in">Array</span>.from(str); <span class="comment">// ['a','b','c','d']</span></span><br></pre></td></tr></table></figure>
<p><strong>Array.of(item…)</strong><br>该方法用于创建数组实例。该方法用于替代 Array() 或 new Array()。Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>); <span class="comment">// [7]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>); <span class="comment">// [ , , , , , , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组实例方法"><a href="#数组实例方法" class="headerlink" title="数组实例方法"></a>数组实例方法</h4><h5 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h5><p><strong>arr.join(separator)</strong><br>把数组构构造成字符串，它先把数组中的每个元素转换成字符串，然后再用 separator 分隔符把它们链接在一起，separator 分隔符默认是逗号 “,”，要想做到无间隔链接，可以使用空字符串作为 separator：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.join(<span class="string">"|"</span>); <span class="comment">//"1|2|3|4|5"</span></span><br><span class="line">arr.join(<span class="string">""</span>); <span class="comment">//12345</span></span><br><span class="line"><span class="comment">//另所有对象有具有的 toLocaleString、toString、valueOf，可以看作是join的特殊用法，不常用</span></span><br></pre></td></tr></table></figure>
<h5 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h5><p><strong>arr.push(item…)</strong><br>将一个或多个新元素添加到数组结尾，并返回数组新长度。<br><strong>arr.pop()</strong><br>移除最后一个元素并返回该元素值。</p>
<h5 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h5><p><strong>arr.unshift(item…)</strong><br>将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度。<br><strong>arr.shift()</strong><br>移除第一个元素并返回该元素值，数组中元素自动前移.如果这个数组是空的，它会返回 undefined。shift 通常比 pop 慢的多。</p>
<h5 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h5><p><strong>arr.reverse()</strong><br>反转数组的顺序。<br><strong>arr.sort(compareFn)</strong><br>给数组排序，默认升序。</p>
<p>注意： sort 默认会将数组内容视为字符串来排序，所以对数字排序时默认的排序规则会错的离谱。一般我们给 sort 带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数，如果两个参数相等则返回 0，如果第一个参数应该排在前面则返回一个负数，如果第二个参数应该排在前面则返回一个正数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组排序</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h5 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h5><p><strong>arr.concat(item…)</strong><br>该方法产生一份 arr 的浅复制，并将多个数组（也可以是字符串，或者是数组和字符串的混合）附加在其后连接为一个数组，返回连接好的新的数组。</p>
<p><strong>arr.slice(start, end)</strong><br>该方法对数组中的一段做浅复制，首先复制数组 arr[start] 至 arr[end] 的部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素（或者理解成 end 的默认值为 arr.length）。字符串也有个同名方法 string.slice。</p>
<p><strong>arr.splice(start, deleteCount, item…)</strong><br>该方法从 arr 中移除一个或多个元素，并将新的 item 插入至移除元素的开始位置， 参数 start 是移除元素的开始位置，deleteCount 是要移除的元素的个数，item 是要被插入的元素。它返回一个包含被移除元素的数组。</p>
<p><strong>arr.copyWithin(target, start, end)</strong><br>该方法复制数组的一部分到同一数组中的另一个位置（会覆盖原成员），并返回修改后的数组。使用这个方法，会修改当前数组。参数 target 为开始替换数据的位置，若 target 大于等于 arr.length，将会不发生拷贝。start 是可选参数，为开始读取数据的位置，默认为 0。end 是可选参数，为停止读取数据的位置，默认为 arr.length。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<p><strong>arr.fill(value, start, end)</strong><br>该方法使用给定值填充一个数组，参数 value 是用来填充数组的值。start 是可选参数，为填充开始位置，默认为 0。end 是可选参数，为填充的结束位置，默认为 arr.length。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .fill(<span class="number">4</span>) <span class="comment">// [4, 4, 4]</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].fill(<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [1, 4, 3]</span></span><br></pre></td></tr></table></figure>
<p>fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。</p>
<h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><p><strong>arr.indexOf(searchElement,start)</strong><br>该方法返回要查找的项在数组中的位置，如果没找到返回 -1。接受两个参数，searchElement 是要查找的项，start 是查找起始位置的索引，默认是 0。</p>
<p><strong>arr.lastIndexOf(searchElement, start)</strong><br>从 start 位置开始向前查找，start 默认值为 arr.length – 1。</p>
<p>注意该方法在比较查找项与数组中每一项时，会使用全等操作符，也就是要求查找的项必须严格相等。</p>
<p><strong>arr.includes(searchElement, fromIndex)</strong><br>该方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。参数 searchElement 为需要查找的元素值。参数 fromIndex 是可选参数，从该索引处开始查找 searchElement，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索，默认为 0。 如果 fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索。<br>该方法属于 ES7，但 Babel 转码器已经支持。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对 NaN 的误判。includes 使用的是不一样的判断算法，就没有这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>]</span><br><span class="line">  .indexOf(<span class="literal">NaN</span>)</span><br><span class="line">  <span class="comment">// -1</span></span><br><span class="line">  [<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>includes() 方法有意设计为通用方法。它不要求 this 值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([].includes.call(<span class="built_in">arguments</span>, <span class="number">2</span>)); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log([].includes.call(<span class="built_in">arguments</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p><strong>arr.every(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。callback 被调用时传入三个参数：元素值，元素的索引，原数组。thisArg 为可选参数，指定执行 callback 时使用的 this 值。</p>
<p><strong>arr.some(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，如果该函数对任意一项返回 true,则返回 true。</p>
<p><strong>arr.filter(callback,thisArg)</strong><br>对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p>
<p><strong>arr.forEach(callback)</strong><br>对数组中的每一项运行给定函数，这个函数没有返回值。本质上和使用 for 一样。</p>
<p><strong>arr.map(callback)</strong><br>对数组中的每一项运行给定的函数，返回每次函数调用后结果组成的数组。</p>
<p><strong>arr.find(callback,thisArg)</strong><br>该方法对数组所有成员依次执行 callback 函数，直到找出第一个返回值为 true 的成员并返回。如果没有，则返回 undefined.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">-5</span>, <span class="number">19</span>].find(<span class="function">(<span class="params">v, i, arr</span>) =&gt;</span> v &lt; <span class="number">0</span>); <span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p><strong>arr.findIndex(callback, thisArg)</strong><br>该方法与 arr.find() 类似，对数组中的成员依次执行 callback 函数，直至找到第一个返回值为 true 的成员，然后返回该成员的索引。如果没有符合条件的成员，则返回 -1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function">(<span class="params">v, i, arr</span>) =&gt;</span> v &gt; <span class="number">9</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>arr.entries()</strong><br><strong>arr.keys()</strong><br><strong>arr.values()</strong><br>这三个方法都返回一个新的 Array iterator 对象，可以用<code>for...of</code>循环进行遍历，区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123; <span class="built_in">console</span>.log(index); &#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123; <span class="built_in">console</span>.log(elem) ;&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123; <span class="built_in">console</span>.log(index, elem);&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);  <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);  <span class="comment">// [1, "b"]</span></span><br></pre></td></tr></table></figure>
<h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><p><strong>arr.reduce(callback,initialValue)</strong><br><strong>arr.reduceRight(callback,initialValue)</strong><br>这个两个方法都会迭代数组所有的项，然后返回一个最终值。reduce()方法从数组的第一项开始，逐个遍历到最后，而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。它们接受两个参数，callback 每一项上调用的函数，callback 被调用时传入四个参数：上一次调用回调返回的值、正在处理的元素、正在处理的元素的索引值（如果提供了 initialValue ，从 0 开始；否则从 1 开始）、原数组。initialValue 是可选项，作为归并基础的初始值，其值用于第一次调用 callback 的第一个参数。</p>
<h3 id="数组常见问题练习"><a href="#数组常见问题练习" class="headerlink" title="数组常见问题练习"></a>数组常见问题练习</h3><h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><h5 id="多个一维数组合并"><a href="#多个一维数组合并" class="headerlink" title="多个一维数组合并"></a>多个一维数组合并</h5><p>如有两个一维数组，要将他们合并成一个数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>Array.prototype.concat()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = arr1.concat(arr2); <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>for 循环和 Array.prototype.push()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flation</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">    arr1.push(arr2[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce()或 reduceRight()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  arr2.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, curr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev.push(curr);</span><br><span class="line">  &#125;, arr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多维（复合）数组合并成一维数组"><a href="#多维（复合）数组合并成一维数组" class="headerlink" title="多维（复合）数组合并成一维数组"></a>多维（复合）数组合并成一维数组</h5><p>例如有这么一组多维数组，要把它拍平成 1 维数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]],</span><br><span class="line">  <span class="number">10</span>,</span><br><span class="line">  <span class="number">11</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></span><br></pre></td></tr></table></figure>
<p>Array.prototype.push()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unction flatten(arr, result) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].constructor == <span class="built_in">Array</span>) &#123;</span><br><span class="line">            flatten(arr[i], r)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>,[<span class="number">12</span>,<span class="number">13</span>,[<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></span><br></pre></td></tr></table></figure>
<p>Array.prototype.concat()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略对二维以上数组的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result = result.concat(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]); <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], <span class="number">10</span>, <span class="number">11</span>]); <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br></pre></td></tr></table></figure>
<p>可以通过 Function.prototype.apply()方法，让其变得更简单:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略对二维以上数组的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 中，还可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略对二维以上数组的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要处理三维或更多维数组，则需要加一些判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr = [].concat.apply([], arr);</span><br><span class="line">  <span class="keyword">return</span> arr.some(<span class="built_in">Array</span>.isArray) ? flatten(arr) : arr;</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11]</span></span><br></pre></td></tr></table></figure>
<p>使用 join()和 split()<br>利用数组实例的 join()方法和字符串实例的 split()方法，也可以将多维数组拍平：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">","</span>).split(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line">flatten([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]], <span class="number">10</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="comment">//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"]</span></span><br></pre></td></tr></table></figure>
<p>这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。</p>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><h5 id="双重循环去重"><a href="#双重循环去重" class="headerlink" title="双重循环去重"></a>双重循环去重</h5><p>思路：</p>
<ul>
<li>构建一个空数组来存放去重后的数组</li>
<li>对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比</li>
<li>如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">  result[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> repeat = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; result.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == result[j]) &#123;</span><br><span class="line">        repeat = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, "a", "b"]</span></span><br></pre></td></tr></table></figure>
<p>这种方法也可以采用 forEach()方法和 indexOf()方法模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">  result[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.includes(item)) result.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="排序遍历去重"><a href="#排序遍历去重" class="headerlink" title="排序遍历去重"></a>排序遍历去重</h5><p>思路：</p>
<ul>
<li>构建一个空数组来存放去重后的数组</li>
<li>用<code>sort()</code>方法对原数组做一个排序，排完序后对数组做遍历，检测数组中第 i 个元素与结果数组中的最后一个元素是否相同，如果不同，则放到结果数组中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  arr.sort();</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item !== result[result.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>]);</span><br></pre></td></tr></table></figure>
<p>这种方法有两个特色：</p>
<ul>
<li>去重后的数组会做排序，主要是因为原数在去重前做了排序</li>
<li>去重后的数组，与数字相同的数字字符无法区分，比如‘1’和 1</li>
</ul>
<h5 id="对象键值对法"><a href="#对象键值对法" class="headerlink" title="对象键值对法"></a>对象键值对法</h5><p>思路：</p>
<ul>
<li>创建一个 js 对象及新数组</li>
<li>遍历原数组，每次取出一个元素与 js 对象的键做对比</li>
<li>如果不包含，将存入对象的元素的值推入到结果数组中，并将 object 对象中该属性名的值设为 1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> object = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!object[<span class="keyword">typeof</span> arr[i] + arr[i]]) &#123;</span><br><span class="line">      <span class="comment">//键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1`</span></span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">      object[<span class="keyword">typeof</span> arr[i] + arr[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">"1"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, "a", "b"]</span></span><br></pre></td></tr></table></figure>
<p>这种方法比较耗内存，但运行下来耗时最少，是较为优秀的方案。</p>
<h5 id="使用-ES6-的-Set-和-Map-方法"><a href="#使用-ES6-的-Set-和-Map-方法" class="headerlink" title="使用 ES6 的 Set 和 Map 方法"></a>使用 ES6 的 Set 和 Map 方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助Map数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> !seen.has(item) &amp;&amp; seen.set(item, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助 Set 数据结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)); <span class="comment">//或 return [...new Set(arr)]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">"1"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>]);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, "1", "a", "b"]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h4><h5 id="递归的方法"><a href="#递归的方法" class="headerlink" title="递归的方法"></a>递归的方法</h5><p>思路:<br>不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr, newArr = []</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果原数组只有一个值</span></span><br><span class="line">  <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">    newArr.push(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> newArr; <span class="comment">// 递归结束</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> random = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * arr.length - <span class="number">1</span>);</span><br><span class="line">  newArr.push(arr[random]);</span><br><span class="line">  arr.splice(random, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> randomSort(arr, newArr);</span><br><span class="line">&#125;</span><br><span class="line">randomSort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">//[2, 3, 1, 5, 6, 7, 4]</span></span><br><span class="line">randomSort([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">//[3, 4, 2, 5, 1, 6, 7]</span></span><br></pre></td></tr></table></figure>
<h5 id="随机交换数组内的元素-原理-from-underscore-js）"><a href="#随机交换数组内的元素-原理-from-underscore-js）" class="headerlink" title="随机交换数组内的元素 (原理 from underscore.js）"></a>随机交换数组内的元素 (原理 from underscore.js）</h5><p>思路：<br>遍历数组，每次从 i 位置后元素随机挑一个放到 i 位置，将原 i 位置元素放至被挑元素位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">        arr = <span class="keyword">this</span>.slice(<span class="number">0</span>),</span><br><span class="line">        temp, index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        index = i + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - i))</span><br><span class="line">        [arr[i],arr[index]] = [arr[index],arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="随机从原数组抽取一个元素-加入到新数组"><a href="#随机从原数组抽取一个元素-加入到新数组" class="headerlink" title="随机从原数组抽取一个元素,加入到新数组"></a>随机从原数组抽取一个元素,加入到新数组</h5><p>思路：<br>遍历数组，每次从数组中随机挑一个元素（随机数最大值为原数组剩余长度），将该元素拿出来放入新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</span><br><span class="line">    arr = <span class="keyword">this</span>.slice(<span class="number">0</span>),</span><br><span class="line">    result = [],</span><br><span class="line">    index;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (len - i));</span><br><span class="line">    result.push(arr.splice(index, <span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">  <span class="number">1</span>;</span><br><span class="line">&#125;[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)].shuffle();</span><br><span class="line"><span class="comment">//[5, 3, 2, 1, 7, 4, 6]</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组基础&quot;&gt;&lt;a href=&quot;#数组基础&quot; class=&quot;headerlink&quot; title=&quot;数组基础&quot;&gt;&lt;/a&gt;数组基础&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="Array" scheme="https://callmejay.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深入之继承的多种方式</title>
    <link href="https://callmejay.github.io/2018/02/26/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://callmejay.github.io/2018/02/26/JavaScript深入之继承的多种方式/</id>
    <published>2018-02-26T12:55:14.000Z</published>
    <updated>2019-02-18T10:45:55.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Jay"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// Jay</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>存在的问题：<br>1，引用类型的属性被所有的实例共享，eg:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">"Jhon"</span>, <span class="string">"Michel"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">"Lili"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></span><br></pre></td></tr></table></figure>
<p>2，在创建 Child 的实例时，不能向 Parent 传参</p>
<h3 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">"Jhon"</span>, <span class="string">"Michel"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">child1.names.push(<span class="string">"Lili"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.names); <span class="comment">// ["Jhon","Michel","Lili"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.names); <span class="comment">// ["Jhon","Michel"]</span></span><br></pre></td></tr></table></figure>
<p>优点：<br>1，避免了引用类型的属性被所有实例共享。<br>2，可以在 Child 中间向 Parent 传参. eg:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"kaer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// kaer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">"james"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// james</span></span><br></pre></td></tr></table></figure>
<p>缺点：<br>方法都在构造函数里定义，每次创建实例都会创建一遍方法。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>原型链继承和经典继承的组合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"cyan"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"xiaoming"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name, child1.age, child1.colors); <span class="comment">// xiaoming 20 ["red", "cyan", "black"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">"david"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name, child2.age, child2.colors); <span class="comment">// david 23 ["red", "cyan"]</span></span><br></pre></td></tr></table></figure>
<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。<br>缺点：<br>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"kevin"</span>,</span><br><span class="line">  friends: [<span class="string">"daisy"</span>, <span class="string">"kelly"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">"person1"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">"taylor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure>
<p>注意：修改 person1.name 的值，person2.name 的值并未发生改变，并不是因为 person1 和 person2 有独立的 name 值，而是因为 person1.name = ‘person1’，给 person1 添加了 name 值，并非修改了原型上的 name 值.</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object.create(o);</span><br><span class="line">  clone.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点: 跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承最大的缺点就是虎调用两次父构造函数。<br>一次是设置子类型实例的原型的时候：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>
<p>一次是在创建子类型实例的时候：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">"david"</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure>
<p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.call(<span class="keyword">this</span>, name);</span><br></pre></td></tr></table></figure>
<p>在这里，我们又会调用了一次 Parent 构造函数。<br>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为 colors，属性值为[‘red’, ‘blue’, ‘green’]。</p>
<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>
<p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>
<p>看看如何实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"cyan"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键的三步</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child1 = <span class="keyword">new</span> Child(<span class="string">"david"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>
<p>最后封装一下这个函数方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    functin F () &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span> (<span class="params">child,parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们使用的时候</span></span><br><span class="line">prototype(Child,Parent);</span><br></pre></td></tr></table></figure>
<p>引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<blockquote>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Parent&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = &lt;span class=&quot;string&quot;&gt;&quot;Jay&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Parent.prototype.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Child&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Child.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Parent();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; child1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Child();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(child1.getName()); &lt;span class=&quot;comment&quot;&gt;// Jay&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="继承" scheme="https://callmejay.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础3</title>
    <link href="https://callmejay.github.io/2018/02/21/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%803/"/>
    <id>https://callmejay.github.io/2018/02/21/快速掌握JavaScript面试基础3/</id>
    <published>2018-02-21T08:49:21.000Z</published>
    <updated>2019-02-18T10:50:28.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><p>如果使用 new 关键字来调用函数式很特别的形式。我们把那些用 new 调用的函数叫做构造函数(constructor function)。</p>
<p>使用了 new 的函数到底做了什么事情呢？</p>
<ul>
<li>创建一个新的对象</li>
<li>将对象的 prototype 设置为构造函数的 prototype</li>
<li>执行构造函数，this 执行新构造的对象</li>
<li>返回该对象。如果构造函数返回对象，那么返回该构造对象。<a id="more"></a>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了更好地理解底层，我们来定义new关键字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">constructor, ...arguments</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">constructor</span>.prototype);</span><br><span class="line">  return <span class="keyword">constructor</span>.apply(obj, arguments) || obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 new 和不使用的区别在哪里呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wings = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 普通的函数调用 */</span></span><br><span class="line"><span class="keyword">let</span> fakeBird = Bird();</span><br><span class="line"><span class="built_in">console</span>.log(fakeBird); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">/* 使用new调用 */</span></span><br><span class="line"><span class="keyword">let</span> realBird = <span class="keyword">new</span> Bird();</span><br><span class="line"><span class="built_in">console</span>.log(realBird); <span class="comment">// &#123; wings: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>为了便于对比理解，译者额外增加了测试了一种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MBird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wings = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> realMBrid = <span class="keyword">new</span> MBird();</span><br><span class="line"><span class="built_in">console</span>.log(realMBird); <span class="comment">// &#123; wings: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>你会发现，这一句 return “hello”并没有生效！</p>
<h3 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h3><p>原型(Prototype)是 JavaScript 中最容易搞混的概念，其中一个原因是 prototype 可以用在两个不同的情形下。</p>
<ul>
<li><p>原型关系<br>每一个对象都有一个 prototype 对象，里面包含了所有它的原型的属性。<br>.__proto__是一个不正规的机制(ES6 中提供)，用来获取一个对象的 prototype。你可以理解为它指向对象的 parent。<br>所有普通的对象都继承.constructor 属性，它指向该对象的构造函数。当一个对象通过构造函数实现的时候，__proto__属性指向构造函数的构造函数的.prototype。Object.getPrototypeOf()是 ES5 的标准函数，用来获取一个对象的原型。</p>
</li>
<li><p>原型属性<br>每一个函数都有一个.prototype 属性，它包含了所有可以被继承的属性。该对象默认包含了指向原构造函数的.constructor 属性。每一个使用构造函数创建的对象都有一个构造函数属性。</p>
</li>
</ul>
<p>接下来通过例子来帮助理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">breed, name</span>) </span>&#123;</span><br><span class="line">  (<span class="keyword">this</span>.breed = breed), (<span class="keyword">this</span>.name = name);</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.describe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is a <span class="subst">$&#123;<span class="keyword">this</span>.breed&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rusty = <span class="keyword">new</span> Dog(<span class="string">"Beagle"</span>, <span class="string">"Rusty"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* .prototype 属性包含了构造函数以及构造函数中在prototype上定义的属性。*/</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype); <span class="comment">// &#123; describe: ƒ , constructor: ƒ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用Dog构造函数构造的对象 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty); <span class="comment">//  &#123; breed: "Beagle", name: "Rusty" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从构造函数的原型中继承下来的属性或函数 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty.describe()); <span class="comment">// "Rusty is a Beagle"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* .__proto__ 属性指向构造函数的.prototype属性 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty.__proto__); <span class="comment">// &#123; describe: ƒ , constructor: ƒ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* .constructor 属性指向构造函数 */</span></span><br><span class="line"><span class="built_in">console</span>.log(rusty.constructor); <span class="comment">// ƒ Dog(breed, name) &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是指对象之间通过 prototype 链接起来，形成一个有向的链条。当访问一个对象的某个属性的时候，JavaScript 引擎会首先查看该对象是否包含该属性。如果没有，就去查找对象的 prototype 中是否包含。以此类推，直到找到该属性或则找到最后一个对象。最后一个对象的 prototype 默认为 null。</p>
<h3 id="拥有-vs-继承"><a href="#拥有-vs-继承" class="headerlink" title="拥有 vs 继承"></a>拥有 vs 继承</h3><p>一个对象有两种属性，分别是它自身定义的和继承的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Car.prototype.wheels = <span class="number">4</span>;</span><br><span class="line">Car.prototype.airbags = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line">myCar.color = <span class="string">"black"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  原型链中的属性也可以通过in来查看:  */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"airbags"</span> <span class="keyword">in</span> myCar); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.wheels); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.year); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  通过hasOwnProperty来查看是否拥有该属性:  */</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.hasOwnProperty(<span class="string">"airbags"</span>)); <span class="comment">// false — Inherited</span></span><br><span class="line"><span class="built_in">console</span>.log(myCar.hasOwnProperty(<span class="string">"color"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Object.create(obj) 创建一个新的对象，prototype 指向 obj。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123; <span class="attr">legs</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> myDog = <span class="built_in">Object</span>.create(dog);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myDog.hasOwnProperty(<span class="string">"legs"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.legs); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(myDog.__proto__ === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="继承是引用传值"><a href="#继承是引用传值" class="headerlink" title="继承是引用传值"></a>继承是引用传值</h3><p>继承属性都是通过引用的形式。看例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objProt = &#123; <span class="attr">text</span>: <span class="string">"original"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> objAttachedToProt = <span class="built_in">Object</span>.create(objProt);</span><br><span class="line"><span class="built_in">console</span>.log(objAttachedToProt.text); <span class="comment">// original</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们更改objProt的text属性，objAttachedToProt的text属性同样更改了</span></span><br><span class="line">objProt.text = <span class="string">"prototype property changed"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objAttachedToProt.text); <span class="comment">// prototype property changed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果我们讲一个新的对象赋值给objProt，那么objAttachedToProt的text属性不受影响</span></span><br><span class="line">objProt = &#123; <span class="attr">text</span>: <span class="string">"replacing property"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objAttachedToProt.text); <span class="comment">// prototype property changed</span></span><br></pre></td></tr></table></figure>
<h3 id="异步-JavaScript"><a href="#异步-JavaScript" class="headerlink" title="异步 JavaScript"></a>异步 JavaScript</h3><p>JavaScript 是一个单线程程序语言，也就是说 JavaScript 引擎一次只能执行某一段代码。它导致的问题就是：如果有一段代码需要耗费很长的时间执行，其它的操作就被卡住了。JavaScript 使用 Call Stack 来记录函数的调用。一个 Call Stack 可以看成是一摞书。最后一本书放在最上面，也最先被移走。最先放的书在最底层，最后被移走。</p>
<p>为了避免复杂代码占用 CPU 太长时间，一个解法就是定义异步回调函数。我们自己来定义一个异步函数看看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetingAsync</span>(<span class="params">name, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> greeting = <span class="string">"hello, "</span> + name;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> callback(greeting), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetingAsync(<span class="string">"fundebug"</span>, <span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"start greeting"</span>);</span><br></pre></td></tr></table></figure>
<p>我们在 greetingAsync 中构造了 greeting 语句，然后通过 setTimeout 定义了异步，callback 函数，是为了让用户自己去定义 greeting 的具体方式。为方便起见，我们时候直接使用 console.log。</p>
<p>上面代码执行首先会打印 start greeting，然后才是 hello, fundebug。也就是说，greetingAsync 的回调函数后执行。在网站开发中，和服务器交互的时候需要不断地发送各种请求，而一个页面可能有几十个请求。如果我们一个一个按照顺序来请求并等待结果，串行的执行会使得网页加载很慢。通过异步的方式，我们可以先发请求，然后在回调中处理请求结果，高效低并发处理。</p>
<p>下面通过一个例子来描述整个执行过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"First message"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> second = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Second message"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> third = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Third message"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">first();</span><br><span class="line">setTimeout(second, <span class="number">0</span>);</span><br><span class="line">third();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// First message</span></span><br><span class="line"><span class="comment">// Third message</span></span><br><span class="line"><span class="comment">// Second message</span></span><br></pre></td></tr></table></figure>
<ol>
<li>初始状态下，浏览器控制台没有输出，并且事件管理器(Event Manager)是空的；</li>
<li>first()被添加到调用栈</li>
<li>将 console.log(“First message”)加到调用栈</li>
<li>console.log(“First message”)执行并输出“First message”到控制台</li>
<li>console.log(“First message”)从调用栈中移除</li>
<li>first()从调用栈中移除</li>
<li>setTimeout(second, 0)加到调用栈</li>
<li>setTimeout(second, 0)执行，0ms 之后，second()被加到回调队列</li>
<li>setTimeout(second, 0)从调用栈中移除</li>
<li>third()加到调用栈</li>
<li>console.log(“Third message”)加到调用栈</li>
<li>console.log(“Third message”)执行并输出“Third message”到控制台</li>
<li>console.log(“Third message”)从调用栈中移除</li>
<li>third()从调用栈中移除</li>
<li>Event Loop 将 second()从回调队列移到调用栈</li>
<li>console.log(“Second message”)加到调用栈</li>
<li>console.log(“Second message”)Second message”到控制台</li>
<li>console.log(“Second message”)从调用栈中移除</li>
<li>Second()从调用栈中移除</li>
</ol>
<p>特别注意的是：second()函数在 0ms 之后并没有立即执行，你传入到 setTimeout()函数的时间和 second()延迟执行的时间并不一定直接相关。事件管理器等到 setTimeout()设置的时间到期才会将其加入回调队列，而回调队列中它执行的时间和它在队列中的位置以及它前面的函数的执行时间有关。</p>
<p><a href="https://blog.fundebug.com/2018/01/29/the-definitive-javascript-handbook-for-a-developer-interview-3/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;new-关键字&quot;&gt;&lt;a href=&quot;#new-关键字&quot; class=&quot;headerlink&quot; title=&quot;new 关键字&quot;&gt;&lt;/a&gt;new 关键字&lt;/h3&gt;&lt;p&gt;如果使用 new 关键字来调用函数式很特别的形式。我们把那些用 new 调用的函数叫做构造函数(constructor function)。&lt;/p&gt;
&lt;p&gt;使用了 new 的函数到底做了什么事情呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新的对象&lt;/li&gt;
&lt;li&gt;将对象的 prototype 设置为构造函数的 prototype&lt;/li&gt;
&lt;li&gt;执行构造函数，this 执行新构造的对象&lt;/li&gt;
&lt;li&gt;返回该对象。如果构造函数返回对象，那么返回该构造对象。
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础2</title>
    <link href="https://callmejay.github.io/2018/02/21/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802/"/>
    <id>https://callmejay.github.io/2018/02/21/快速掌握JavaScript面试基础2/</id>
    <published>2018-02-21T04:47:09.000Z</published>
    <updated>2019-02-18T10:50:23.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包由一个函数以及该函数定义式所在的环境组成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">`Hi <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> greeting();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayHiToJon = sayHi(<span class="string">"Jon"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sayHiToJon); <span class="comment">// ƒ() &#123; console.log(message) &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHiToJon()); <span class="comment">// 'Hi Jon!'</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>请理解<code>var sayHiToJon=sayHi(&#39;Jon&#39;)</code>;这段代码的执行过程，sayHi 函数执行，首先将 message 的值计算出来，然后定义了 greeting 函数，函数中引用了 message 变量，最后，返回 greeting 函数。<br>如果按照 C/Java 语言的思路，sayHiToJon 就等价于 greeting 函数，那么就会报错：message 为定义。但是在 JavaScript 中不一样，这里的 sayHiToJon 函数等于 greeting 函数以及一个环境，该环境中包含了 message。因此，当我们调用 sayHiToJon 函数，可以成功将 message 打印出来。因此，这里的闭包就是 greeting 函数和一个包含 message 变量的环境。</p>
<p>闭包的一个优势在于<strong>数据隔离</strong>，下面用一个例子说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpringfieldSchool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> staff = [<span class="string">"Seymour Skinner"</span>, <span class="string">"Edna Krabappel"</span>];</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getStaff: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(staff);</span><br><span class="line">    &#125;,</span><br><span class="line">    addStaff: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      staff.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> elementary = SpringfieldSchool();</span><br><span class="line"><span class="built_in">console</span>.log(elementary); <span class="comment">// &#123; getStaff: ƒ, addStaff: ƒ &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(staff); <span class="comment">// ReferenceError: staff is not defined</span></span><br><span class="line"><span class="comment">/* Closure allows access to the staff variable */</span></span><br><span class="line">elementary.getStaff(); <span class="comment">// ["Seymour Skinner", "Edna Krabappel"]</span></span><br><span class="line">elementary.addStaff(<span class="string">"Otto Mann"</span>);</span><br><span class="line">elementary.getStaff(); <span class="comment">// ["Seymour Skinner", "Edna Krabappel", "Otto Mann"]</span></span><br></pre></td></tr></table></figure>
<p>在 elementary 被创建的时候，SpringfieldSchool 已经返回。也就是说 staff 无法被外部访问。唯一可以访问的方式就是里面的闭包函数 getStaff 和 addStaff。</p>
<p>我们来看一个面试题：下面的代码有什么问题，如何修复？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The value <span class="subst">$&#123;arr[i]&#125;</span> is at index: <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">  &#125;, (i + <span class="number">1</span>) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码输出的结果全部都一样：”The value undefined is at index: 4”。因为所有在 setTimeout 中定义的匿名函数都引用了同一个外部变量 i。当匿名函数执行的时候，i 的值为 4。</p>
<p>这个问题可以改用 IIFE(后面会介绍)方法来解决，通过对每一个匿名函数构建独立的外部作用域来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`The value <span class="subst">$&#123;arr[j]&#125;</span> is at index: <span class="subst">$&#123;j&#125;</span>`</span>);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，还有一个方法，使用 let 来声明 i。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;"</span>);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="立即调用的函数表达式-Immediate-Invoked-Function-Expression-IIFE"><a href="#立即调用的函数表达式-Immediate-Invoked-Function-Expression-IIFE" class="headerlink" title="立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)"></a>立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)</h3><p>一个 IIFE 是一个函数表达式在定义之后立即被调用。常用在你想对一个新声明的变量创建一个隔离的作用域。<br>它的格式为:<code>(function(){....})()</code>。前面的大括号用于告诉编译器这里不仅仅是函数定义，后面的大括号用于执行该函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]()); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">// 5</span></span><br><span class="line">result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = i; <span class="comment">// copy current value of i</span></span><br><span class="line">    result.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> j;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>使用 IIFE 可以：</p>
<ul>
<li>为函数绑定私有数据</li>
<li>创建一个新的环境</li>
<li>避免污染全局命名空间</li>
</ul>
<h3 id="环境（Context）"><a href="#环境（Context）" class="headerlink" title="环境（Context）"></a>环境（Context）</h3><p>我们往往容易将环境（Context）和作用域（Scope）搞混，解释一下：</p>
<ul>
<li><strong>环境（Context）</strong>：由函数如何被调用而决定，往往指 this.</li>
<li><strong>作用域（Scope）</strong>：可访问的变量。</li>
</ul>
<h3 id="函数调用：call-apply-bind"><a href="#函数调用：call-apply-bind" class="headerlink" title="函数调用：call, apply, bind"></a>函数调用：call, apply, bind</h3><p>这三个方法都是为了将 this 绑定到函数，区别在于调用的方式。</p>
<ul>
<li>.call(a,b,c,d…)会理解执行函数，需要把参数按照顺序传入；</li>
<li>.apply([a,b,c,d…])会理解执行函数，需要把参数组合成数组传入了；</li>
</ul>
<p>.call()和.apply()几乎相同。哪个传入参数方便，你就选择哪个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snow = &#123; <span class="attr">surename</span>: <span class="string">"Snow"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> char = &#123;</span><br><span class="line">  surename: <span class="string">"Stark"</span>,</span><br><span class="line">  knows: <span class="function"><span class="keyword">function</span>(<span class="params">arg, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You know <span class="subst">$&#123;arg&#125;</span>, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surename&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">char.knows(<span class="string">"something"</span>, <span class="string">"Bran"</span>); <span class="comment">// You know something, Bran Stark</span></span><br><span class="line">char.knows.call(Snow, <span class="string">"nothing"</span>, <span class="string">"Jon"</span>); <span class="comment">// You know nothing, Jon Snow</span></span><br><span class="line">char.knows.apply(Snow, [<span class="string">"nothing"</span>, <span class="string">"Jon"</span>]); <span class="comment">// You know nothing, Jon Snow</span></span><br></pre></td></tr></table></figure>
<p>注意：如果你将数组传入 call 函数，它会认为只有一个参数。</p>
<p>ES6 允许使用新的操作符将数组变换为一个序列。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char.knows.call(Snow, ...[<span class="string">"nothing"</span>, <span class="string">"Jon"</span>]); <span class="comment">// You know nothing, Jon Snow</span></span><br></pre></td></tr></table></figure>
<p>.bind()返回一个新的函数，以及相应的环境和参数。如果你想该函数稍后调用，那么推荐使用 bind。<br>.bind()函数的优点在于它可以记录一个执行环境，对于异步调用和事件驱动的编程很有用。</p>
<p>.bind()传参数的方式和 call 相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snow = &#123; <span class="attr">surename</span>: <span class="string">"Snow"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> char = &#123;</span><br><span class="line">  surename: <span class="string">"Stark"</span>,</span><br><span class="line">  knows: <span class="function"><span class="keyword">function</span>(<span class="params">arg, name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You know <span class="subst">$&#123;arg&#125;</span>, <span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.surename&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> whoKnowsNothing = char.knows.bind(Snow, <span class="string">"nothing"</span>);</span><br><span class="line">whoKnowsNothing(<span class="string">"Jon"</span>); <span class="comment">// You know nothing, Jon Snow</span></span><br></pre></td></tr></table></figure>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>要理解 JavaScript 中 this 关键字，特别是它指向谁，有时候相当地复杂。this 的值通常由函数的执行环境决定。简单的说，执行环境指函数如何被调用的。this 像是一个占位符(placeholder)，它指向当方法被调用时，调用对应的方法的对象。</p>
<p>下面有序地列出了判断 this 指向的规则。如果第一条匹配，那么就不用去检查第二条了。</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>当使用 new 关键字调用函数的时候，this 指向新构建的对象(实例)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> = Rachel = <span class="keyword">new</span> Person(<span class="string">'Rachel'</span>,<span class="number">30</span>); <span class="comment">// &#123;name: 'Rachel',age: 30&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="显示绑定-Explicit-binding"><a href="#显示绑定-Explicit-binding" class="headerlink" title="显示绑定(Explicit binding)"></a>显示绑定(Explicit binding)</h4><p>当使用 call 或则 apply 的时候，我们显示的传入一个对象参数，该参数会绑定到 this。 注意：.bind()函数不一样。用 bind 定义一个新的函数，但是依然绑定到原来的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> agent = &#123; <span class="attr">id</span>: <span class="string">"007"</span> &#125;;</span><br><span class="line">fn.call(agent); <span class="comment">// &#123; id: '007' &#125;</span></span><br><span class="line">fn.apply(agent); <span class="comment">// &#123; id: '007' &#125;</span></span><br><span class="line"><span class="keyword">var</span> boundFn = fn.bind(agent);</span><br><span class="line">boundFn(); <span class="comment">// &#123; id: '007' &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>当一个函数在某个环境下调用(在某个对象里)，this 指向该对象。也就是说该函数是对象的一个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> building = &#123;</span><br><span class="line">  floors: <span class="number">5</span>,</span><br><span class="line">  printThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">building.printThis(); <span class="comment">// &#123; floors: 5, printThis: function() &#123;…&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>如果上面所有的规则都不满足，那么 this 指向全局对象(在浏览器中，就是 window 对象)。当函数没有绑定到某个对象，而单独定义的时候，该函数默认绑定到全局对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">printWindow(); <span class="comment">// window object</span></span><br></pre></td></tr></table></figure>
<p>注意：下面的情况中，inner 函数中的 this 指向全局。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dinosaur</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  inner();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>); <span class="comment">// window object — the function has overwritten the 'this' context</span></span><br><span class="line">    <span class="built_in">console</span>.log(self); <span class="comment">// &#123;name: 'Dino'&#125; — referencing the stored value from the outer context</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myDinosaur = <span class="keyword">new</span> Dinosaur(<span class="string">"Dino"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="词法-Lexical-this"><a href="#词法-Lexical-this" class="headerlink" title="词法(Lexical) this"></a>词法(Lexical) this</h4><p>当是使用<code>=&gt;</code>来定义函数时，this 指向定义该函数时候外层的 this。<br>备注：大概是和定义的词法(=&gt;)有关，把它称作 Lexical this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123; name: 'Garfield' &#125;</span></span><br><span class="line">  (<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>))(); <span class="comment">// &#123; name: 'Garfield' &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Cat(<span class="string">"Garfield"</span>);</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.fundebug.com/2018/01/22/the-definitive-javascript-handbook-for-a-developer-interview-2/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h3&gt;&lt;p&gt;闭包由一个函数以及该函数定义式所在的环境组成。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message = &lt;span class=&quot;string&quot;&gt;`Hi &lt;span class=&quot;subst&quot;&gt;$&amp;#123;name&amp;#125;&lt;/span&gt;`&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;greeting&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; greeting();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sayHiToJon = sayHi(&lt;span class=&quot;string&quot;&gt;&quot;Jon&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sayHiToJon); &lt;span class=&quot;comment&quot;&gt;// ƒ() &amp;#123; console.log(message) &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sayHiToJon()); &lt;span class=&quot;comment&quot;&gt;// &#39;Hi Jon!&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>快速掌握JavaScript面试基础1</title>
    <link href="https://callmejay.github.io/2018/02/20/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%801/"/>
    <id>https://callmejay.github.io/2018/02/20/快速掌握JavaScript面试基础1/</id>
    <published>2018-02-20T10:15:33.000Z</published>
    <updated>2019-02-18T10:50:17.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类型和类型转换"><a href="#类型和类型转换" class="headerlink" title="类型和类型转换"></a>类型和类型转换</h3><p>在 JavaScript 中有 7 个内置类型：null,undefined,boolean,number,string,object 和 symbol（ES6)。</p>
<p>除了 object 以外，其他都叫做基本类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">0</span>; <span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"abc"</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">"Hi"</span>); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>Null vs. Undefined</li>
</ul>
<p><strong>Undefined</strong>表示未定义。对于没有初始化的变量，函数调用时未提供的函数参数，不存在的对象属性，它们的默认值就是 undefined。如果一个函数没有返回语句，那么默认的返回值也是 undefined。</p>
<p><strong>Null</strong>表示值为空。一个变量我们可以将其赋值为 null,表示当前没有值。</p>
<ul>
<li>隐式转换</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Joey"</span>;</span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">" doesn't share food!"</span>); <span class="comment">// Joey doesn’t share food!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 if 语句的条件判断中，name 从字符串转换为布尔型。在 if 的代码块中，在控制台将 name 原原本本打印出来。你知道在什么情况下字符串会转换为真，什么时候为假么？</p>
<p><code>&quot;&quot;，0， null，undefined, NaN, false 会自动转换为false</code>。其它的都会转换为真：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">"hello"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">"0"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">" "</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>空数组、对象、函数定义都会自动转换为真。</p>
<ul>
<li>String &amp; Number 之间的转换<br>-</li>
</ul>
<p>第一个你要非常小心的是<code>+</code>操作符。因为它同时用于数字相加和字符串拼接。</p>
<p><code>*,/,-</code>只用于数字运算，当这些操作符和字符串一起使用，那么字符串会被强制转换为数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">"2"</span> = <span class="string">"12"</span></span><br><span class="line"><span class="string">""</span> + <span class="number">1</span> + <span class="number">0</span> = <span class="string">"10"</span></span><br><span class="line"><span class="string">""</span> - <span class="number">1</span> + <span class="number">0</span> = <span class="number">-1</span></span><br><span class="line"><span class="string">"-9\n"</span> + <span class="number">5</span> = <span class="string">"-9\n5"</span></span><br><span class="line"><span class="string">"-9\n"</span> - <span class="number">5</span> = <span class="number">-14</span></span><br><span class="line"><span class="string">"2"</span> * <span class="string">"3"</span> = <span class="number">6</span></span><br><span class="line"><span class="number">4</span> + <span class="number">5</span> + <span class="string">"px"</span> = <span class="string">"9px"</span></span><br><span class="line"><span class="string">"$"</span> + <span class="number">4</span> + <span class="number">5</span> = <span class="string">"$45"</span></span><br><span class="line"><span class="string">"4"</span> - <span class="number">2</span> = <span class="number">2</span></span><br><span class="line"><span class="string">"4px"</span> - <span class="number">2</span> = <span class="literal">NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>== vs. ===</li>
</ul>
<p>一个广泛被接受的认知就是：==判断值是否相等，===同时判断值是否相等和类型是否相同。但是，这里有些误解。</p>
<p>实际上，==在验证相等性的时候，会对类型不同的值做一个类型转换。===对要判断的值不做类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> == <span class="string">"2"</span>; <span class="comment">// True</span></span><br><span class="line"><span class="number">2</span> === <span class="string">"2"</span>; <span class="comment">// False</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// True</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>; <span class="comment">// False</span></span><br></pre></td></tr></table></figure>
<p>类型转换有很多取巧的地方，要注意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"0"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(a)); <span class="comment">// True</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(b)); <span class="comment">// False</span></span><br></pre></td></tr></table></figure>
<p>你认为下面的相等判断会输出什么值呢?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a == b);</span><br></pre></td></tr></table></figure>
<p>实际上会返回 true。知道为什么吗？</p>
<p><strong>如果你将一个布尔类型的和非布尔类型的判断，JavaScript 会将布尔类型的转换为数字然后再比对。</strong><br>执行过程如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>(<span class="number">1</span>);</span><br><span class="line"><span class="string">"0"</span> == <span class="number">0</span>(<span class="number">2</span>);</span><br><span class="line"><span class="number">0</span> == <span class="number">0</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>所以，最终变成了 0==0，当然返回 true 啦。</p>
<p>一些比较容易掉坑的比较，我在这里列出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="string">""</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == []; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == &#123;&#125;; <span class="comment">// false</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == []; <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == &#123;&#125;; <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == []; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == &#123;&#125;; <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="值-vs-引用"><a href="#值-vs-引用" class="headerlink" title="值 vs. 引用"></a>值 vs. 引用</h3><p>对于基本类型的值，赋值是通过值拷贝的形式；比如：null，undefined，boolean，number，string 和 ES6 的 symbol。对于复杂类型的值，通过引用拷贝的形式赋值。比如：对象、对象包括数组和函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// 'a' hold a copy of the value 2.</span></span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 'b' is always a copy of the value in 'a'</span></span><br><span class="line">b++;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c; <span class="comment">// 'd' is a reference to the shared value</span></span><br><span class="line">d.push(<span class="number">4</span>); <span class="comment">// Mutates the referenced value (object)</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="comment">/* Compound values are equal by reference */</span></span><br><span class="line"><span class="keyword">var</span> e = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(c === d); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(c === e); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果想对复杂类型的值进行值拷贝，你需要自己去对所有子元素进行拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copy = c.slice(); <span class="comment">// 'copy' 即使copy和c相同，但是copy指向新的值</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(c === copy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h3><p>作用域是程序的执行环境，它包含了在当前位置可访问的变量和函数。</p>
<p>全局作用域是最外层的作用域，在函数外面定义的变量属于全局作用域，可以被任何其他子作用域访问。在浏览器中，window 对象就是全局作用域。</p>
<p>局部作用域是在函数内部的作用域。在局部作用域定义的变量只能在该作用域以及其子作用域被访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innermost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    innermost();</span><br><span class="line">    <span class="built_in">console</span>.log(a, b); <span class="comment">// 1 2 — 'c' is not defined</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1 — 'b' and 'c' are not defined</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>你可以将作用域想象成一系列不断变小的门。如果一个个子不高的人可以穿过最小的门(局部最小作用域)，那么必然可以穿过任何比它大的门(外部作用域)。</p>
<h3 id="提升-Hoisting"><a href="#提升-Hoisting" class="headerlink" title="提升(Hoisting)"></a>提升(Hoisting)</h3><p>在编译过程中，将 var 和 function 的定义移动到他们作用域最前面的行为叫做提升。</p>
<p>整个函数定义会被提升。所以，你可以在函数还未定义之前调用它，而不用担心找不到该函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(toSquare(<span class="number">3</span>)); <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toSquare</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量只会被部分提升。而且只有变量的声明会被提升，赋值不会动。</p>
<p>let 和 const 不会被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Original code */</span></span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Compilation phase */</span></span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// undefined</span></span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6 let &amp; const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line">  <span class="keyword">const</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h3><ul>
<li>函数表达式</li>
</ul>
<p>一个函数表达式是在函数执行到函数表达式定义的位置才开始创建，并被使用。它不会被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数声明</li>
</ul>
<p>函数声明的函数可以在文件中任意位置调用，因为它会被提升。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量：var，let-和-const"><a href="#变量：var，let-和-const" class="headerlink" title="变量：var，let 和 const"></a>变量：var，let 和 const</h3><p>在 ES6 之前，只能使用 var 来声明变量。在一个函数体中声明的变量和函数，周围的作用域内无法访问。在块作用域 if 和 for 中声明的变量，可以在 if 和 for 的外部被访问。</p>
<p>注意：如果没有使用 var,let 或则 const 关键字声明的变量将会绑定到全局作用域上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="string">"Hi"</span>;</span><br><span class="line">    undeclaredVar = <span class="string">"I am automatically created in global scope"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// 'Hi'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Error — ReferenceError: s is not defined</span></span><br><span class="line">greeting();</span><br><span class="line"><span class="built_in">console</span>.log(undeclaredVar); <span class="comment">// 'I am automatically created in global scope'</span></span><br></pre></td></tr></table></figure>
<p>ES6 的 let 和 const 都是新引入的关键字。它们不会被提升，而且是块作用域。也就是说被大括号包围起来的区域声明的变量外部将不可访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g1 = <span class="string">"global 1"</span>;</span><br><span class="line"><span class="keyword">let</span> g2 = <span class="string">"global 2"</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Creating a new block scope */</span></span><br><span class="line">  g1 = <span class="string">"new global 1"</span>;</span><br><span class="line">  <span class="keyword">let</span> g2 = <span class="string">"local global 2"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(g1); <span class="comment">// 'new global 1'</span></span><br><span class="line">  <span class="built_in">console</span>.log(g2); <span class="comment">// 'local global 2'</span></span><br><span class="line">  <span class="built_in">console</span>.log(g3); <span class="comment">// ReferenceError: g3 is not defined</span></span><br><span class="line">  <span class="keyword">let</span> g3 = <span class="string">"I am not hoisted"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(g1); <span class="comment">// 'new global 1'</span></span><br><span class="line"><span class="built_in">console</span>.log(g2); <span class="comment">// 'global 2'</span></span><br></pre></td></tr></table></figure>
<p>一个常见的误解是：使用 const 声明的变量，其值不可更改。准确地说它不可以被重新赋值，但是可以更改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tryMe = <span class="string">"initial assignment"</span>;</span><br><span class="line">tryMe = <span class="string">"this has been reassigned"</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You cannot reassign but you can change it…</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">"Ted"</span>, <span class="string">"is"</span>, <span class="string">"awesome!"</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="string">"Barney"</span>;</span><br><span class="line">array[<span class="number">3</span>] = <span class="string">"Suit up!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [“Barney”, “is”, “awesome!”, “Suit up!”]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> airplane = &#123;&#125;;</span><br><span class="line">airplane.wings = <span class="number">2</span>;</span><br><span class="line">airplane.passengers = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(airplane); <span class="comment">// &#123;passengers: 200, wings: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://blog.fundebug.com/2018/01/15/the-definitive-javascript-handbook-for-a-developer-interview/" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;类型和类型转换&quot;&gt;&lt;a href=&quot;#类型和类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型和类型转换&quot;&gt;&lt;/a&gt;类型和类型转换&lt;/h3&gt;&lt;p&gt;在 JavaScript 中有 7 个内置类型：null,undefined,boolean,number,string,object 和 symbol（ES6)。&lt;/p&gt;
&lt;p&gt;除了 object 以外，其他都叫做基本类型。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// boolean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hi&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// symbol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="基础知识" scheme="https://callmejay.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
