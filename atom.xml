<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay&#39;s Blog</title>
  <subtitle>对不起，我要赢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://callmejay.github.io/"/>
  <updated>2018-02-10T09:29:37.031Z</updated>
  <id>https://callmejay.github.io/</id>
  
  <author>
    <name>Jay Bein</name>
    <email>291977464@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript之原型和原型链</title>
    <link href="https://callmejay.github.io/2018/02/08/JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://callmejay.github.io/2018/02/08/JavaScript之原型和原型链/</id>
    <published>2018-02-08T14:02:47.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p>我们先使用构造函数创建一个对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.name = <span class="string">'lili'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// lili</span></div></pre></td></tr></table></figure></p>
<p>在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。<br><a id="more"></a></p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每一个<strong>函数都有一个prototype属性</strong>，就是我们经常在各种例子中看到那个prototype,比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">*虽然写在注释了，但是要注意：prototype是函数才会有的属性</div><div class="line">*/</div><div class="line">Person.prototype.name = <span class="string">'Jay'</span>;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// jay</span></div><div class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// jay</span></div></pre></td></tr></table></figure></p>
<p>那这个函数的prototype属性到底指向的是什么呢？</p>
<p>其实，函数的prototype属性指向了一个对象，这个对象正是<strong>调用该构造函数而创建的实例</strong>的原型，也就是这个例子中的person1和person2的原型。</p>
<p>那什么是原型呢？可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。</p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype1.png" alt=""><br>在这张图中我们用的<code>Object.prototype</code>表示实例原型。</p>
<p>那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢？</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><p>这是每一个JavaScript对象（null除外）都具有的一个属性，叫__proto__，这个属性会指向该对象的原型，证明如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype2.png" alt=""><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就是第三个属性: constructor，每个原型都有一个constructor属性指向关联的构造函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(Person === <span class="built_in">Object</span>.prototype.constructor);</div></pre></td></tr></table></figure></p>
<p>再更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype3.png" alt=""><br>综上所述:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor = Person); <span class="comment">// true</span></div><div class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系。</p>
<h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br>举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Person.prototype.name = <span class="string">'jay'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person.name = <span class="string">'John'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// John</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person.name;</div><div class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// jay</span></div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们给实例对象person添加了name属性，当我们打印person.name的时候，结果自然为John。</p>
<p>但是当我们删除了person的name属性时，读取person.name,从person对象中找不到name属性就会从person的原型也就是person.__proto__,也就是Person.prototype中查找，幸运的是我们找打name属性，结果为jay。</p>
<p>但是万一没找到呢，原型的原型又是什么呢？</p>
<h3 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h3><p>在前面，我们已经讲了原型也是一个对象，既然是对象，那我们就可以用最原始的方式创建它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj.name = <span class="string">'Kevin'</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Kevin</span></div></pre></td></tr></table></figure></p>
<p>其实原型对象就是通过Object构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的prototype,所以载更新关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype4.png" alt=""></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>那Object.prototype的原型呢？<br>null, 我们可以打印：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>然而null究竟代表了什么呢？</p>
<blockquote>
<p>null代表’没有对象’，即该处不该有值。</p>
</blockquote>
<p><img src="http://oonulpk6h.bkt.clouddn.com/null&amp;undefined.png" alt=""><br>所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p>最后一张关系图：<br><img src="http://oonulpk6h.bkt.clouddn.com/prototype5.png" alt=""></p>
<p>顺便还要说一下，图中由相互关联的原型组成的链状结构就是<strong>原型链</strong>，也就是蓝色的这条线。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h4><p>首先是constructor属性，例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.constructor == Person); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有这个属性，所以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person.constructor = Person.prototype.constructor</div></pre></td></tr></table></figure></p>
<h4 id="proto-1"><a href="#proto-1" class="headerlink" title="__proto__"></a>__proto__</h4><p>其次是__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h4 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h4><p>最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性的说法， 引用《你不知道的JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建了一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和方法，所以与其叫继承，委托的说法反而更准确些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;构造函数创建对象&quot;&gt;&lt;a href=&quot;#构造函数创建对象&quot; class=&quot;headerlink&quot; title=&quot;构造函数创建对象&quot;&gt;&lt;/a&gt;构造函数创建对象&lt;/h3&gt;&lt;p&gt;我们先使用构造函数创建一个对象：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&#39;lili&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person.name); &lt;span class=&quot;comment&quot;&gt;// lili&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="原型" scheme="https://callmejay.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="https://callmejay.github.io/2018/02/07/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>https://callmejay.github.io/2018/02/07/前端跨域整理/</id>
    <published>2018-02-07T15:41:20.000Z</published>
    <updated>2018-02-10T09:29:37.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><blockquote>
<p>跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。</p>
</blockquote>
<a id="more"></a>
<p>下面是具体的跨域情况详解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">URL                      说明       是否允许通信</div><div class="line">http://www.a.com/a.js</div><div class="line">http://www.a.com/b.js     同一域名下   允许</div><div class="line"></div><div class="line">http://www.a.com/lab/a.js</div><div class="line">http://www.a.com/script/b.js 同一域名下不同文件夹 允许</div><div class="line"></div><div class="line">http://www.a.com:8000/a.js</div><div class="line">http://www.a.com/b.js     同一域名，不同端口  不允许</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">https://www.a.com/b.js 同一域名，不同协议 不允许</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">http://70.32.92.74/b.js 域名和域名对应ip 不允许</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">http://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）</div><div class="line"></div><div class="line">http://www.a.com/a.js</div><div class="line">http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）</div><div class="line"></div><div class="line">http://www.cnblogs.com/a.js</div><div class="line">http://www.a.com/b.js 不同域名 不允许</div></pre></td></tr></table></figure></p>
<p><strong>这里我们需要注意两点:</strong></p>
<ul>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的；</li>
<li>在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</li>
</ul>
<h3 id="通过document-domain跨域"><a href="#通过document-domain跨域" class="headerlink" title="通过document.domain跨域"></a>通过document.domain跨域</h3><blockquote>
<p>前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<code>www.damonare.cn/a.html</code> ， 在这个页面里面有一个iframe，它的src是<code>damonare.cn/b.html</code>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function test()&#123;</div><div class="line">        var iframe = document.getElementById('ifame');</div><div class="line">        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</div><div class="line">        var doc = win.document;//这里获取不到iframe里的document对象</div><div class="line">        var name = win.name;//这里同样获取不到window对象的name属性</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个时候，<code>document.domain</code>就可以派上用场了，我们只要把<code>www.damonare.cn/a.html</code>和<code>damonare.cn/b.html</code>这两个页面的<code>document.domain</code>都设成相同的域名就可以了。但要注意的是，<code>document.domain</code>的设置是有限制的，我们只能把<code>document.domain</code>设置成自身或更高一级的父域，且主域必须相同。</p>
</blockquote>
<p>在页面<code>www.damonare.cn/a.html</code>中设置<code>document.domain</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id = <span class="string">"iframe"</span> src=<span class="string">"http://damonare.cn/b.html"</span> onload = <span class="string">"test()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//设置成主域</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>).contentWindow);<span class="comment">//contentWindow 可取得子窗口的 window 对象</span></div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>在页面<code>damonare.cn/b.html</code>中也设置<code>document.domain</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">document</span>.domain = <span class="string">'damonare.cn'</span>;<span class="comment">//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>修改<code>document.domain</code>的方法只适用于不同子域的框架间的交互。</strong></p>
<h3 id="通过location-hash跨域"><a href="#通过location-hash跨域" class="headerlink" title="通过location.hash跨域"></a>通过location.hash跨域</h3><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。</p>
</blockquote>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。<br>1, a.html传送数据到b.html</p>
<ul>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
</ul>
<p>2, b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</p>
<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”www.baidu.com/proxy.html#…”</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
<p>b.html页面的关键代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;  </div><div class="line">    parent.location.hash = <span class="string">'data'</span>;  </div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </div><div class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，  </span></div><div class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </div><div class="line">    ifrproxy.style.display = <span class="string">'none'</span>;  </div><div class="line">    ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html#data"</span>;  </div><div class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>proxy.html页面的关键代码如下 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span></div><div class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<h3 id="通过HTML5的postMessage方法跨域"><a href="#通过HTML5的postMessage方法跨域" class="headerlink" title="通过HTML5的postMessage方法跨域"></a>通过HTML5的postMessage方法跨域</h3><blockquote>
<p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。</p>
</blockquote>
<p>比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。</p>
<p>A页面通过postMessage方法发送消息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);</div><div class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">'http://www.google.com'</span>;</div><div class="line">    ifr.contentWindow.postMessage(<span class="string">'hello'</span>,targetOrigin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>postMessage的使用方法：</strong></p>
<ul>
<li>otherWindow.postMessage(message, targetOrigin);</li>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames属性的成员或者由window.open方法创建的窗口</li>
<li>message:是要发送的消息，类型为String、Object(IE8、9 不支持)<br>targetOrigin:是限定消息接收范围，不限制请使用 ‘*’</li>
</ul>
<p>B页面通过message事件监听并接受消息:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> data = ev.data; <span class="comment">// 消息</span></div><div class="line">    <span class="keyword">var</span> origin = ev.origin; <span class="comment">// 消息来源地址</span></div><div class="line">    <span class="keyword">var</span> source = ev.source; <span class="comment">// 源window对象 </span></div><div class="line">    <span class="keyword">if</span>(origin == <span class="string">'http://www.baidu.com'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(data); <span class="comment">// hello</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener != <span class="string">'undefined'</span>) &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,onmessage,<span class="literal">false</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent != <span class="string">'undefined'</span>) &#123; <span class="comment">// ie</span></div><div class="line">    <span class="built_in">window</span>.attachEvent(<span class="string">'message'</span>,onmessage);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<h3 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h3><blockquote>
<p>刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
</blockquote>
<p>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是damonare.cn/data.php, 那么a.html中的代码就可以这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function dosomething(jsondata)&#123;</div><div class="line">        //处理获得的json数据</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</p>
<p>因为是当做一个js文件来引入的，所以<code>damonare.cn/data.php</code>返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$callback = $_GET[<span class="string">'callback'</span>];<span class="comment">//得到回调函数名</span></div><div class="line">$data = array(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></div><div class="line">echo $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>
<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    $.getJSON(<span class="string">'http://example.com/data.php?callback=?,function(jsondata)'</span>)&#123;</div><div class="line">        <span class="comment">//处理获得的json数据</span></div><div class="line">    &#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<p>JSONP的优缺点：</p>
<ul>
<li>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</li>
<li>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h3 id="通过CORS跨域"><a href="#通过CORS跨域" class="headerlink" title="通过CORS跨域"></a>通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。<strong>CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</strong>目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<p>平时的ajax请求可能是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">'/getSomething'</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>以上getSomething部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">'text/javascript'</span>&gt;</div><div class="line">    <span class="keyword">var</span> xhr = XMLHttpRequest();</div><div class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">'http://jaybein.site/getSomething'</span>,<span class="literal">true</span>);</div><div class="line">    xhr.send();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>
<p>服务器端对于CORS的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享CORS详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是跨域？&quot;&gt;&lt;a href=&quot;#什么是跨域？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？&quot;&gt;&lt;/a&gt;什么是跨域？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="https://callmejay.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>对缓存的一点理解</title>
    <link href="https://callmejay.github.io/2018/02/07/%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>https://callmejay.github.io/2018/02/07/对缓存的一点理解/</id>
    <published>2018-02-07T13:44:29.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</p>
</blockquote>
<h3 id="缓存的种类"><a href="#缓存的种类" class="headerlink" title="缓存的种类"></a>缓存的种类</h3><p>很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。<br><a id="more"></a><br>实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。</p>
<p>缓存好处有很多：</p>
<ul>
<li>缓解服务器压力(不用每次去请求资源)；</li>
<li>提升性能(打开本地资源速度当然比请求回来再打开要快得多)；</li>
<li>减少带宽消耗(我相信你可以理解)；</li>
</ul>
<h3 id="浏览器的缓存策略"><a href="#浏览器的缓存策略" class="headerlink" title="浏览器的缓存策略"></a>浏览器的缓存策略</h3><p><strong>缓存的目标:</strong></p>
<ul>
<li>一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；</li>
<li>不变的重定向: 响应状态码：301；</li>
<li>可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；</li>
<li>错误响应: 响应状态码：404 的一个页面；</li>
<li>不完全的响应: 响应状态码 206，只返回局部的信息；</li>
<li>除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；</li>
</ul>
<p><strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。</strong><br>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Age:23146</div><div class="line">Cache-Control:max-age=2592000</div><div class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</div><div class="line">ETag:W/&quot;5a1cf09a-63c6&quot;</div><div class="line">Expires:Thu, 28 Dec 2017 05:27:45 GMT</div><div class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</div><div class="line">Vary:Accept-Encoding</div></pre></td></tr></table></figure></p>
<h4 id="强缓存阶段"><a href="#强缓存阶段" class="headerlink" title="强缓存阶段"></a>强缓存阶段</h4><p>以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，<code>Expires</code>是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。<code>Cache-Control:max-age=2592000</code>是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，<code>max-age &gt; Expires</code>。</p>
<p>这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️</p>
<p>Firefox浏览器表现为一个灰色的200状态码。</p>
<p>Chrome浏览器状态码表现为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">200 (from disk cache)或是200 OK (from memory cache)</div></pre></td></tr></table></figure></p>
<p><strong>多说一点：</strong>关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是<code>from memory cache</code>有时是<code>from disk cache</code>的问题了。</p>
<h4 id="协商缓存阶段"><a href="#协商缓存阶段" class="headerlink" title="协商缓存阶段"></a>协商缓存阶段</h4><p>那么当这个CSS文件过期了怎么办?<code>ETag</code>和<code>Last-Modified</code>就该闪亮登场了。</p>
<p>先说<code>Last-Modified</code>，这个字段是文件最后一次修改的时间；</p>
<p><code>ETag</code>呢？<code>ETag</code>是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。</p>
<p>利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带<code>If-Moified-Since</code>和<code>If-None-Match</code>这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑</p>
<p>具体两个字段携带的内容如下(分别和上面的<code>Last-Modified</code>、<code>ETag</code>携带的值对应)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT</div><div class="line">If-None-Match: W/&quot;5a1cf09a-63c6&quot;</div></pre></td></tr></table></figure></p>
<p>到这协商缓存结束。</p>
<h4 id="启发式缓存阶段"><a href="#启发式缓存阶段" class="headerlink" title="启发式缓存阶段"></a>启发式缓存阶段</h4><p>我们把上面的响应头改下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Age:23146</div><div class="line">Cache-Control: public</div><div class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</div><div class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</div><div class="line">Vary:Accept-Encoding</div></pre></td></tr></table></figure></p>
<p>发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带<code>If-Moified-Since</code>呗，不是的，浏览器还有个启发式缓存阶段。</p>
<p><strong>根据响应头中2个时间字段<code>Date</code>和<code>Last-Modified</code>之间的时间差值，取其值的10%作为缓存时间周期</strong>。</p>
<p>这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种<code>默认缓存</code>的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。<br>下面用一张图，来解释浏览器整个缓存策略的过程：<br><img src="http://oonulpk6h.bkt.clouddn.com/broswer_cache" alt="浏览器缓存过程"><br>对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。</p>
<blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7?utm_source=gold_browser_extension" target="_blank" rel="external">传送门</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;缓存的种类&quot;&gt;&lt;a href=&quot;#缓存的种类&quot; class=&quot;headerlink&quot; title=&quot;缓存的种类&quot;&gt;&lt;/a&gt;缓存的种类&lt;/h3&gt;&lt;p&gt;很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。&lt;br&gt;
    
    </summary>
    
      <category term="浏览器" scheme="https://callmejay.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="cache" scheme="https://callmejay.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript:彻底理解同步、异步和事件循环（Event Loop）</title>
    <link href="https://callmejay.github.io/2018/02/06/JavaScript-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/"/>
    <id>https://callmejay.github.io/2018/02/06/JavaScript-彻底理解同步、异步和事件循环（Event-Loop）/</id>
    <published>2018-02-06T13:05:10.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。</p>
</blockquote>
<a id="more"></a>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>
<p>如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在函数返回时，获得了预期值，即2的平方根</span></div><div class="line"><span class="built_in">Math</span>.sqrt(<span class="number">2</span>);</div><div class="line"><span class="comment">//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div></pre></td></tr></table></figure></p>
<p>上面两个函数就是同步的。<br><strong>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</strong></p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>
<p>如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取文件</span></div><div class="line">fs.readFile(<span class="string">'hello.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//网络请求</span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></div><div class="line">xhr.open(<span class="string">'GET'</span>, url);</div><div class="line">xhr.send(); <span class="comment">// 发起函数</span></div></pre></td></tr></table></figure></p>
<p>上述示例中读取文件函数 <code>readFile</code>和网络请求的发起函数  <code>send</code>都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在<code>JavaScript</code>中通过回调函数<code>function(err, data) { console.log(data); }</code>和 <code>onreadystatechange</code>，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行<code>JavaScript</code>代码的线程执行回调。</p>
<p><strong>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</strong></p>
<h3 id="单线程与多线程"><a href="#单线程与多线程" class="headerlink" title="单线程与多线程"></a>单线程与多线程</h3><p>在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？</p>
<p>JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。</p>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。<br>一个浏览器通常由以下几个常驻的线程：</p>
<ul>
<li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li>
<li>JS引擎线程：负责JS的解析和执行</li>
<li>定时触发器线程：处理定时事件，比如setTimeout, setInterval</li>
<li>事件触发线程：处理DOM事件</li>
<li>异步http请求线程：处理http请求</li>
</ul>
<p>需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。</p>
<h4 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h4><p>通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。</p>
<p>JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤：</p>
<ul>
<li>词法分析：将源代码分解为有意义的分词</li>
<li>语法分析：用语法分析器将分词解析成语法树</li>
<li>代码生成：生成机器能运行的代码</li>
<li>代码执行</li>
</ul>
<p>不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。</p>
<p>之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。</p>
<p><strong>所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</strong></p>
<h3 id="消息队列与事件循环"><a href="#消息队列与事件循环" class="headerlink" title="消息队列与事件循环"></a>消息队列与事件循环</h3><p>通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？</p>
<p>这一切的解释就需要继续了解消息队列和事件循环。</p>
<p><img src="http://oonulpk6h.bkt.clouddn.com/message&amp;queue" alt="消息队列"></p>
<p>如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p>
<p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。</p>
<p>JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p>
<p>JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫<strong>事件循环</strong>。</p>
<p><img src="http://oonulpk6h.bkt.clouddn.com/ajax%E7%BA%BF%E7%A8%8B" alt="AJAX过程"></p>
<p>上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。</p>
<p>从上文中我们也可以得到这样一个明显的结论，就是：</p>
<blockquote>
<p>异步过程的回调函数，一定不在当前这一轮事件循环中执行。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。</p>
<blockquote>
<p>执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'timer a'</span>);</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</div><div class="line">    <span class="built_in">console</span>.log(j);</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'timer b'</span>);</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitFiveSeconds</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">    <span class="keyword">while</span>(((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - now) &lt; <span class="number">5000</span>)&#123;&#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'finished waiting'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'click begin'</span>);</div><div class="line">waitFiveSeconds();</div></pre></td></tr></table></figure>
<p>要想了解上述代码的输出结果，首先介绍下定时器。</p>
<p><code>setTimeout</code>的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，<strong>所以间隔的时间一般会大于等于指定的时间</strong>。</p>
<p><code>setTimeout(fn, 0)</code>的意思是，将回调函数<code>fn</code>立刻插入消息队列，等待执行，而不是立即执行。看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>)</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b a</div></pre></td></tr></table></figure>
<p>打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。</p>
<p>理解了定时器的作用，那么对于输出结果就容易得出了。</p>
<p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达5s。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line">click begin</div><div class="line">finished waiting</div></pre></td></tr></table></figure></p>
<p>然后，在JS引擎线程执行的时候，<code>&#39;timer a&#39;</code>对应的定时器产生的回调、 <code>&#39;timer b&#39;</code>对应的定时器产生的回调和两次<code>click</code>对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">click</div><div class="line">click</div><div class="line">timer a</div><div class="line">timer b</div></pre></td></tr></table></figure></p>
<p>最后，5s 后的两次<code>click</code>事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">click</div><div class="line">click</div></pre></td></tr></table></figure></p>
<h3 id="异步与事件"><a href="#异步与事件" class="headerlink" title="异步与事件"></a>异步与事件</h3><p>上文中说的“事件循环”，为什么里面有个事件呢？那是因为：</p>
<blockquote>
<p>消息队列中的每条消息实际上都对应着一个事件。</p>
</blockquote>
<p>上文中一直没有提到一类很重要的异步过程：<code>DOM事件</code>。<br>举例说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElement(<span class="string">'#btn'</span>);</div><div class="line">button.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'lalla'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。</p>
<p>从异步过程的角度看，<code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。</p>
<p>这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些.</p>
<p><strong>参考文章</strong>：<br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop</a></p>
<blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5a6ad46ef265da3e513352c8?utm_source=gold_browser_extension" target="_blank" rel="external">传送门</a></p>
</blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="Event Loop" scheme="https://callmejay.github.io/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之字符串的扩展</title>
    <link href="https://callmejay.github.io/2017/09/01/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://callmejay.github.io/2017/09/01/ES6入门之字符串的扩展/</id>
    <published>2017-09-01T13:38:26.000Z</published>
    <updated>2018-02-10T09:29:37.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p><code>ES6</code>为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(codePoint)</div><div class="line">&#125;</div><div class="line"><span class="comment">// "f"</span></div><div class="line"><span class="comment">// "o"</span></div><div class="line"><span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(),startsWith(),endsWith()"></a>includes(),startsWith(),endsWith()</h3><p>传统上，<code>JavaScript</code>只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。<code>ES6</code>又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></div><div class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数如果是小数，会被取整。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></div></pre></td></tr></table></figure></p>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)</div><div class="line"><span class="comment">// RangeError</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)</div><div class="line"><span class="comment">// RangeError</span></div></pre></td></tr></table></figure></p>
<p>但是，如果参数是<code>0</code>到<code>-1</code>之间的小数，则等同于<code>0</code>，这是因为会先进行取整运算。<code>0</code>到<code>-1</code>之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为<code>0</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数<code>NaN</code>等同于0。<br>如果<code>repeat</code>的参数是字符串，则会先转换成数字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></div></pre></td></tr></table></figure></p>
<h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p><code>ES2017</code>引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<br><code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></div><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></div><div class="line"></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></div></pre></td></tr></table></figure></p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div><div class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div></pre></td></tr></table></figure></p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</div><div class="line"><span class="comment">// '0123456abc'</span></div></pre></td></tr></table></figure></p>
<p>如果省略第二个参数，默认使用空格补全长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></div></pre></td></tr></table></figure></p>
<p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成<code>10</code>位的数值字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></div><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></div><div class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></div></pre></td></tr></table></figure></p>
<p>另一个用途是提示字符串格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></div><div class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统的<code>JavaScript</code>语言，输出模板通常是这样写的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(</div><div class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</div><div class="line">  <span class="string">'items in your basket, '</span> +</div><div class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</div><div class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面这种写法相当繁琐不方便，<code>ES6</code>引入了模板字符串解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></div><div class="line">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>模板字符串(template string)是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></div><div class="line">string text line 2`);</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure></p>
<p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</div></pre></td></tr></table></figure></p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">      <span class="comment">// 传统写法为</span></div><div class="line">      <span class="comment">// 'User '</span></div><div class="line">      <span class="comment">// + user.name</span></div><div class="line">      <span class="comment">// + ' is not authorized to do '</span></div><div class="line">      <span class="comment">// + action</span></div><div class="line">      <span class="comment">// + '.'</span></div><div class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大括号内部可以放入任意的<code>JavaScript</code>表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 4 = 5"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></div><div class="line"><span class="comment">// "3"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串之中还能调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></div><div class="line"><span class="comment">// foo Hello World bar</span></div></pre></td></tr></table></figure></p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量place没有声明</span></div><div class="line"><span class="keyword">let</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</div><div class="line"><span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>由于模板字符串的大括号内部，就是执行<code>JavaScript</code>代码，因此如果大括号内部是一个字符串，将会原样输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "Hello World"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串甚至还能嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></div><div class="line">  &lt;table&gt;</div><div class="line">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">  `).join(<span class="string">''</span>)&#125;</div><div class="line">  &lt;/table&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = [</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(tmpl(data));</div><div class="line"><span class="comment">// &lt;table&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// &lt;/table&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串的遍历器接口&quot;&gt;&lt;a href=&quot;#字符串的遍历器接口&quot; class=&quot;headerlink&quot; title=&quot;字符串的遍历器接口&quot;&gt;&lt;/a&gt;字符串的遍历器接口&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被&lt;code&gt;for...of&lt;/code&gt;循环遍历。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; codePoint &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(codePoint)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;f&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;o&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// &quot;o&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之变量的结构赋值</title>
    <link href="https://callmejay.github.io/2017/08/28/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://callmejay.github.io/2017/08/28/ES6入门之变量的结构赋值/</id>
    <published>2017-08-28T13:35:22.000Z</published>
    <updated>2018-02-10T09:29:37.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。<br>以前，为变量赋值，只能直接指定值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p>ES6允许写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。<br>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备<code>Iterator</code>接口（前五个表达式），要么本身就不具备<code>Iterator</code>接口（最后一个表达式）。<br>对于<code>Set</code>结构，也可以使用数组的解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</div><div class="line">x <span class="comment">// "a"</span></div></pre></td></tr></table></figure></p>
<p>事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> a;</div><div class="line">    [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure></p>
<p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。<br>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x;</div><div class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</div><div class="line">  x = f();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></div><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<p>上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div></pre></td></tr></table></figure></p>
<p><strong>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。<br>如果变量名与属性名不一致，必须写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f <span class="comment">// 'hello'</span></div><div class="line">l <span class="comment">// 'world'</span></div></pre></td></tr></table></figure></p>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</strong><br>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">p</span>: [</div><div class="line">    <span class="string">'Hello'</span>,</div><div class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class="line">x <span class="comment">// "Hello"</span></div><div class="line">y <span class="comment">// "World"</span></div></pre></td></tr></table></figure></p>
<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">p</span>: [</div><div class="line">    <span class="string">'Hello'</span>,</div><div class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class="line">x <span class="comment">// "Hello"</span></div><div class="line">y <span class="comment">// "World"</span></div><div class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></div></pre></td></tr></table></figure></p>
<p>对象的解构也可以指定默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">x <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</div><div class="line">msg <span class="comment">// "Something went wrong"</span></div></pre></td></tr></table></figure></p>
<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。<br>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误的写法</span></div><div class="line"><span class="keyword">let</span> x;</div><div class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="comment">// SyntaxError: syntax error</span></div></pre></td></tr></table></figure></p>
<p>上面代码的写法会报错，因为<code>JavaScript</code>引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免<code>JavaScript</code>将其解释为代码块，才能解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正确的写法</span></div><div class="line"><span class="keyword">let</span> x;</div><div class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</div><div class="line">(&#123;&#125; = <span class="string">'abc'</span>);</div><div class="line">(&#123;&#125; = []);</div></pre></td></tr></table></figure></p>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。<br>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</div><div class="line">first <span class="comment">// 1</span></div><div class="line">last <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// "h"</span></div><div class="line">b <span class="comment">// "e"</span></div><div class="line">c <span class="comment">// "l"</span></div><div class="line">d <span class="comment">// "l"</span></div><div class="line">e <span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>变量的解构赋值用途很多。</p>
<h4 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<h4 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h4><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个数组</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a, b, c] = example();</div><div class="line"></div><div class="line"><span class="comment">// 返回一个对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">bar</span>: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure></p>
<h4 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h4><p>解构赋值可以方便地将一组参数与变量名对应起来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h4><p>解构赋值对提取<code>JSON</code>对象中的数据，尤其有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">42</span>,</div><div class="line">  <span class="attr">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 42, "OK", [867, 5309]</span></div></pre></td></tr></table></figure></p>
<h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line">  async = true,</div><div class="line">  beforeSend = function () &#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  <span class="comment">// ... more config</span></div><div class="line">&#125;) &#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;</code>;这样的语句。</p>
<h4 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h4><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code>结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure></p>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取键名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取键值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h4><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h3&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;p&gt;ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;br&gt;以前，为变量赋值，只能直接指定值。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;ES6允许写成下面这样。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a, b, c] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之let和const</title>
    <link href="https://callmejay.github.io/2017/08/25/ES6%E5%85%A5%E9%97%A8%E4%B9%8Blet%E5%92%8Cconst/"/>
    <id>https://callmejay.github.io/2017/08/25/ES6入门之let和const/</id>
    <published>2017-08-25T13:55:50.000Z</published>
    <updated>2018-02-10T09:29:37.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a <span class="comment">// ReferenceError: a is not defined.</span></div><div class="line">b <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。<br><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line"><span class="comment">// ReferenceError: i is not defined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。<br>下面的代码如果使用<code>var</code>，最后输出的是10。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。<br>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为<code>JavaScript</code>引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// abc</span></div><div class="line"><span class="comment">// abc</span></div><div class="line"><span class="comment">// abc</span></div></pre></td></tr></table></figure></p>
<p>上面代码正确运行，输出了3次abc。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><code>var</code>命令会发生”变量提升“现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。<br>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var 的情况</span></div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></div><div class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// let 的情况</span></div><div class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></div><div class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="comment">// TDZ开始</span></div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></div><div class="line"></div><div class="line">  tmp = <span class="number">123</span>;</div><div class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。<br>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，不能在函数内部重新声明参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h4><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(tmp);</div><div class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数f执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。<br>第二种场景，用来计数的循环变量泄露为全局变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(s[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p><code>let</code>实际上为<code>JavaScript</code>新增了块级作用域。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是10。<br>ES6 允许块级作用域的任意嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;&#123;&#123;</div><div class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</div><div class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></div><div class="line">&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure></p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<blockquote>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE 写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="comment">// 块级作用域写法</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</div><div class="line">PI <span class="comment">// 3.1415</span></div><div class="line"></div><div class="line">PI = <span class="number">3</span>;</div><div class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></div></pre></td></tr></table></figure></p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。<br><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></div><div class="line">foo.prop = <span class="number">123</span>;</div><div class="line">foo.prop <span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></div><div class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></div><div class="line"><span class="comment">// 严格模式时，该行会报错</span></div><div class="line">foo.prop = <span class="number">123</span>;</div></pre></td></tr></table></figure></p>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在<code>Node</code>指的是<code>global</code>对象。<code>ES5</code>之中，顶层对象的属性与全局变量是等价的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</div><div class="line">a <span class="comment">// 1</span></div><div class="line"></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是<code>JavaScript</code>语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p><code>ES6</code>为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从<code>ES6</code>开始，全局变量将逐步与顶层对象的属性脱钩。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></div><div class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></div><div class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h3&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h4&gt;&lt;p&gt;ES6 新增了&lt;code&gt;let&lt;/code&gt;命令，用来声明变量。它的用法类似于&lt;code&gt;var&lt;/code&gt;，但是所声明的变量，只在&lt;code&gt;let&lt;/code&gt;命令所在的代码块内有效。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a &lt;span class=&quot;comment&quot;&gt;// ReferenceError: a is not defined.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中常见的几种轮播</title>
    <link href="https://callmejay.github.io/2017/08/15/JavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BD%AE%E6%92%AD/"/>
    <id>https://callmejay.github.io/2017/08/15/JavaScript中常见的几种轮播/</id>
    <published>2017-08-15T13:38:59.000Z</published>
    <updated>2018-02-10T09:29:37.031Z</updated>
    
    <content type="html"><![CDATA[<p>项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。<br><a id="more"></a><br><strong>首先奉上轮播图</strong><br><img src="http://oonulpk6h.bkt.clouddn.com/imgScroll.png" alt="轮播图"></p>
<h3 id="无缝不停轮播"><a href="#无缝不停轮播" class="headerlink" title="无缝不停轮播"></a>无缝不停轮播</h3><p>body布局:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span>   <span class="comment">&lt;!--将ul和li包住,起显示图片的作用--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>                                 </div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img1.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img2.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img3.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img4.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img1.png)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>css样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;    <span class="comment">/*给要动的元素也就是ul 它的父级加上相对定位*/</span></div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;           </div><div class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;       <span class="comment">/*给要动的元素也就是ul 它的父级加上溢出隐藏*/</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">ul</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;     <span class="comment">/*给要动的元素也就是ul 加上绝对定位,才能保证用left和top;*/</span></div><div class="line">    <span class="attribute">width</span>: <span class="number">3000px</span>;          <span class="comment">/*ul 的宽度为 li 的个数 * li 的宽度*/</span></div><div class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">ul</span> &gt;<span class="selector-tag">li</span>&#123;</div><div class="line">    <span class="attribute">float</span>: left;    </div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">ul</span> &gt;<span class="selector-tag">li</span> <span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JS代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);  <span class="comment">//获取ul</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;                 <span class="comment">//设置定时器 </span></div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft&lt;=<span class="number">-2400</span>)&#123;        <span class="comment">//判断:若ul走到倒数第二张图的时候,让left从0开始运行</span></div><div class="line">        ul.style.left=<span class="number">0</span>+<span class="string">'px'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">var</span> left = ul.offsetLeft <span class="number">-3</span>;        <span class="comment">//给ul设置速度</span></div><div class="line">        ul.style.left=left+<span class="string">'px'</span>;            </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> time = <span class="number">10</span>;         <span class="comment">//设定一个时间,以控制其轮播的速度</span></div><div class="line">    setTimeout(step,time);            <span class="comment">//定时器内部调用定时器</span></div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h3 id="无缝停顿轮播"><a href="#无缝停顿轮播" class="headerlink" title="无缝停顿轮播"></a>无缝停顿轮播</h3><blockquote>
<p>停顿轮播在不停轮播的基础上加以改进,判断当ul走到li宽度的倍数时,让定时器的时间加大,就可以起到停顿的效果</p>
</blockquote>
<p>​body布局以及css样式不变</p>
<p>js代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);   <span class="comment">//获取ul</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;                  <span class="comment">//设置定时器 </span></div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft&lt;=<span class="number">-2400</span>)&#123;               <span class="comment">//判断:若ul走到倒数第二张图的时候,让left从0开始运行</span></div><div class="line">        ul.style.left = <span class="number">0</span> +<span class="string">'px'</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        speed = <span class="number">-3</span>;     <span class="comment">//给ul设置速度           </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> time;               </div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft%<span class="number">600</span>==<span class="number">0</span>)&#123;               <span class="comment">//做判断:当ul走到li宽度的倍数时</span></div><div class="line">        time = <span class="number">3000</span>;                          <span class="comment">//设定一个很大的时间,也就是很小的速度</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;                                  </div><div class="line">        time = <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    ul.style.left=ul.offsetLeft+speed+<span class="string">'px'</span>;</div><div class="line">    setTimeout(step,time);                  <span class="comment">//定时器内部调用定时器</span></div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h3 id="无缝停顿反向轮播"><a href="#无缝停顿反向轮播" class="headerlink" title="无缝停顿反向轮播"></a>无缝停顿反向轮播</h3><blockquote>
<p>反向轮播在停顿轮播的基础上加以改进,判断当ul最左边和ul走到最右边,将速度反向;<br>将最后一张重复的li去掉并修改ul的宽度</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);</div><div class="line"><span class="keyword">var</span> speed = <span class="number">3</span>;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft&lt;=<span class="number">-1800</span>||ul.offsetLeft&gt;=<span class="number">0</span>)&#123;      <span class="comment">//判断当ul最左边和ul走到最右边,将速度反向;</span></div><div class="line">        speed*=<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> time = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(ul.offsetLeft%<span class="number">600</span>==<span class="number">0</span>)&#123;                    <span class="comment">//做判断:当ul走到li宽度的倍数时</span></div><div class="line">        time = <span class="number">3000</span>;                             <span class="comment">//设定一个很大的时间,也就是很小的速度</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        time=<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    ul.style.left=ul.offsetLeft+speed+<span class="string">'px'</span>;  </div><div class="line">    setTimeout(step,time);                       <span class="comment">//定时器内部调用定时器</span></div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h3 id="透明度普通轮播"><a href="#透明度普通轮播" class="headerlink" title="透明度普通轮播"></a>透明度普通轮播</h3><p>​1.body布局上一样;<br>​2.css样式:将所有li 绝对定位,重叠在一起<br>​3.JS:先获取到ul 和 li 并对 li的数组进行遍历 赋值每个的opacity<br>​<strong>注:要在js中遍历li 再给它赋值opacity,而不是在css中直接设置属性是为了在js中好获取到opacity并给它进行修改设置</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">".container &gt; ul"</span>);  <span class="comment">//获取ul</span></div><div class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container &gt; ul &gt;li'</span>);</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lis.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;                   <span class="comment">//默认显示第一张图,让其透明度为1;</span></div><div class="line">        lis[i].style.opacity=<span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//其他图片透明度为0;</span></div><div class="line">        lis[i].style.opacity=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> i=<span class="number">0</span>;                        <span class="comment">//重新赋值i </span></div><div class="line"><span class="keyword">var</span> time = <span class="number">50</span>;                  <span class="comment">//设置时间,控制图片转换的速度,时间越大,速度越慢</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;                 <span class="comment">//设置定时器</span></div><div class="line">    lis[i%<span class="number">4</span>].style.opacity-=<span class="number">0.05</span>;   </div><div class="line">    lis[(i+<span class="number">1</span>)%<span class="number">4</span>].style.opacity=<span class="built_in">parseFloat</span>(lis[(i+<span class="number">1</span>)%<span class="number">4</span>].style.opacity)+<span class="number">0.05</span>;</div><div class="line">    <span class="keyword">if</span>(lis[i%<span class="number">4</span>].style.opacity==<span class="number">0</span>)&#123;</div><div class="line">        i++;</div><div class="line">        time = <span class="number">1000</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        time =<span class="number">50</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setTimeout(step,time);</div><div class="line">&#125;,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<h3 id="透明度指示器轮播"><a href="#透明度指示器轮播" class="headerlink" title="透明度指示器轮播"></a>透明度指示器轮播</h3><p>body布局:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span>                     </div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"picture"</span>&gt;</span>                           <span class="comment">&lt;!--轮播图片区--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img1.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img2.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img3.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img4.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img5.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>![](img/img6.jpg)<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"arrow"</span>&gt;</span>                          <span class="comment">&lt;!--左右切换--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"arrowLeft"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"arrowRight"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span>                      <span class="comment">&lt;!--指示器--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">"margin:0"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>css样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;                        <span class="comment">/*整体样式*/</span></div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> auto;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.picture</span> &#123;             <span class="comment">/*轮播图片区样式*/</span></div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.picture</span> &gt; <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.picture</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">img</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span>&#123;                    <span class="comment">/*左右切换区样式*/</span></div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">height</span>: <span class="number">70px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">40%</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">70px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_left1.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_right1.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_left2.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.arrow</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2)</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"img/arrow_right2.png"</span>);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> <span class="selector-class">.bottom</span> &#123;                            <span class="comment">/*指示器样式*/</span></div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">width</span>: <span class="number">215px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">350px</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">background-color</span>: grey;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.bottom</span> &gt; <span class="selector-tag">ul</span>&#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">205px</span>;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &gt; <span class="selector-class">.bottom</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span>&#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">background-color</span>: white;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>js代码：<br>​<em>代码分析:</em></p>
<ol>
<li>先进行准备工作, 利用for循环将初始化的图片透明度已经指示器的背景色设定好</li>
<li>给整个container添加事件,当鼠标上来的时候,让自动播放停止</li>
<li>给左,右”按钮” 点击事件,用以切换上一张下一张图片;</li>
<li>给指示器onmouseenter事件,使得图片与你的指示器同步,达到随意切换图片的效果;</li>
<li>定义 图片切换的函数 ,使得以上事件都可以调用它</li>
<li>定义自动播放的函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>);</div><div class="line"><span class="keyword">var</span> pictureLis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container &gt; .picture &gt; li'</span>);</div><div class="line"><span class="keyword">var</span> optionLis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.container &gt; .bottom &gt;ul &gt; li'</span>);</div><div class="line"><span class="keyword">var</span> arrowLeft = <span class="built_in">document</span>.querySelector(<span class="string">'.container .arrow  &gt; .arrowLeft'</span>);</div><div class="line"><span class="keyword">var</span> arrowRight = <span class="built_in">document</span>.querySelector(<span class="string">'.container .arrow &gt; .arrowRight'</span>);</div><div class="line"><span class="keyword">var</span> showIndex = <span class="number">0</span>;  <span class="comment">//当前正在显示的图片的下标</span></div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; pictureLis.length; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</div><div class="line">            optionLis[j].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">            pictureLis[j].style.opacity = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            pictureLis[j].style.opacity = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//给整个container添加事件,当鼠标上来的时候,让自动播放停止</span></div><div class="line">    container.onmouseenter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        clearTimeout(autoPlayId);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">    container.onmouseleave = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        auto();</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//给左按钮和右按钮添加点击事件</span></div><div class="line">    arrowLeft.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        optionLis[showIndex % optionLis.length].style.backgroundColor=<span class="string">'white'</span>;</div><div class="line">        <span class="keyword">var</span> preIndex = showIndex<span class="number">-1</span>+pictureLis.length;</div><div class="line">        move(showIndex,preIndex);</div><div class="line">        showIndex=preIndex;</div><div class="line">        optionLis[showIndex%optionLis.length].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">    &#125;;</div><div class="line">    arrowRight.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        optionLis[showIndex % optionLis.length].style.backgroundColor=<span class="string">'white'</span>;</div><div class="line">        move(showIndex,showIndex+<span class="number">1</span>);</div><div class="line">        showIndex++;</div><div class="line">        optionLis[showIndex%optionLis.length].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//给指示器添加onmouseenter事件,使得图片与指示器同步</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;optionLis.length;i++)&#123;</div><div class="line">        optionLis[i].onmouseenter=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">            move(showIndex,i);</div><div class="line">            optionLis[showIndex%optionLis.length].style.backgroundColor=<span class="string">'white'</span>;</div><div class="line">            optionLis[i%optionLis.length].style.backgroundColor=<span class="string">'red'</span>;</div><div class="line">            showIndex=i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">init(); <span class="comment">//调用初始化</span></div><div class="line"></div><div class="line"><span class="comment">//图片移动</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">showIndex,nextIndex</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        pictureLis[showIndex % pictureLis.length].style.opacity -= <span class="number">0.05</span>;</div><div class="line">        pictureLis[nextIndex % pictureLis.length].style.opacity =</div><div class="line">            +pictureLis[nextIndex % pictureLis.length].style.opacity + <span class="number">0.05</span>;</div><div class="line">        <span class="keyword">if</span> (pictureLis[showIndex % pictureLis.length].style.opacity &lt;= <span class="number">0</span>||pictureLis[nextIndex%pictureLis.length].style.opacity&gt;=<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">        setTimeout(step, <span class="number">5</span>)</div><div class="line">    &#125;, <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//自动播放</span></div><div class="line"><span class="keyword">var</span> autoPlayId;     <span class="comment">//自动播放定时器id</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">auto</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    autoPlayId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">autoStep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        optionLis[showIndex].style.backgroundColor = <span class="string">"white"</span>;</div><div class="line">        move(showIndex,showIndex+<span class="number">1</span>);    <span class="comment">//切换下一张图片</span></div><div class="line">        showIndex++;</div><div class="line">        <span class="keyword">if</span> (showIndex == pictureLis.length) showIndex = <span class="number">0</span>;</div><div class="line">        optionLis[showIndex%optionLis.length].style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">        autoPlayId = setTimeout(autoStep,<span class="number">2000</span>);</div><div class="line">    &#125;, <span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line">auto();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="轮播" scheme="https://callmejay.github.io/tags/%E8%BD%AE%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>实现圣杯布局和双飞翼布局</title>
    <link href="https://callmejay.github.io/2017/07/20/%E5%AE%9E%E7%8E%B0%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
    <id>https://callmejay.github.io/2017/07/20/实现圣杯布局和双飞翼布局/</id>
    <published>2017-07-20T14:54:48.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>利用浮动特性可以实现一些布局，比较经典的有个圣杯布局，后来经过改进又出现了双飞翼布局，下面就来介绍一下这两种布局。<br><a id="more"></a><br>先看一下效果图：<br><a href="http://oarri6xxm.bkt.clouddn.com/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html" target="_blank" rel="external">三栏式圣杯布局demo</a><br><img src="http://oonulpk6h.bkt.clouddn.com/shengbei.png" alt="圣杯布局"><br><a href="http://oarri6xxm.bkt.clouddn.com/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80.html" target="_blank" rel="external">三栏式双飞翼布局demo</a><br><img src="http://oonulpk6h.bkt.clouddn.com/shuangfeiyi.png" alt="双飞翼"><br>两种布局基本原理是相似的，而且双飞翼布局是圣杯布局的基础上改进而来，所以先介绍圣杯布局。</p>
<h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>1.总体上看上、中、下三个部分，一般写三组<code>&lt;div&gt;&lt;/div&gt;</code>标签，当然也可以采用<code>html5</code>的标签。<br>2.所谓布局都是在中间部分做文章，有几个要求：第一最中间部分宽度是不定的；第二：俩侧边栏宽度是定的<br>3.为达目的，我们肯定要采用浮动，但是有个诀窍：此处<code>html</code>结构中中间部分要先写，所以<code>html</code>结构是下面这样的<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>三栏式圣杯布局<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span>定宽左侧边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>定宽右侧栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4.此时的问题是用<code>css</code>控制各块到各自位置上。简单的办法是使用负<code>margin</code>，这个负<code>margin</code>的原理是盒子模型的算法，想一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">内容+padding+border+margin</div></pre></td></tr></table></figure></p>
<p>这个公式里如果有一个负值，总和会怎么变，占据宽度空间会怎么变。当我们给一个<code>div</code>加上左负<code>margin</code>自然这个区块就向左位移了。思考一下就知道如果我们给俩边栏设置的都是<code>float:left</code>属性，则需要左侧边栏向左位移一整个父容器的宽度，右侧边栏则向左位移一个自身宽度。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.aside</span> &#123;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.extra</span> &#123;</div><div class="line">    <span class="attribute">float</span>:right;</div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;            </div><div class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">background-color</span>: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仔细看一下代码，会发现右边栏的处理和之前说的不一样，原因就不解释 了，其实只要合理设置<code>css</code>可以有不同方法达到目的。<br>5.现在就剩下最后一步，俩侧边栏虽已经和中间主题内容处于同一行，但是肯定不能遮挡要平移到对应位置上。直接给父元素加个<code>padding</code>，俩侧边栏使用一个相对定位移到<code>padding</code>区域就搞定了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#main</span> &#123;</div><div class="line">        <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</div><div class="line">    &#125;</div><div class="line"><span class="selector-class">.aside</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.extra</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">right</span>: -<span class="number">200px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，圣杯布局就完成了。</p>
<h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>双飞翼布局和圣杯布局的区别只是换一种思路解决中间元素被遮挡问题，主要想法就是在外侧加一个<code>div</code>占据位置，俩侧边栏占据<code>margin</code>位置。所以直接看代码。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">            <span class="selector-class">.mid</span> &#123;</div><div class="line">                <span class="attribute">float</span>: left;</div><div class="line">                <span class="attribute">width</span>: <span class="number">100%</span>;    </div><div class="line">            &#125;</div><div class="line">            <span class="selector-class">.mid</span> <span class="selector-class">.mid-content</span> &#123;</div><div class="line">                <span class="attribute">min-height</span>: <span class="number">80px</span>;</div><div class="line">                <span class="attribute">min-width</span>: <span class="number">20px</span>;</div><div class="line">                <span class="attribute">background-color</span>: green;</div><div class="line">                <span class="attribute">margin-left</span>:<span class="number">200px</span>;</div><div class="line">                <span class="attribute">margin-right</span>:<span class="number">200px</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="selector-class">.aside</span> &#123;</div><div class="line">                <span class="attribute">float</span>: left;</div><div class="line">                <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">                <span class="attribute">min-height</span>: <span class="number">60px</span>;</div><div class="line">                <span class="attribute">background-color</span>: yellow;</div><div class="line">                <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</div><div class="line">            &#125;    </div><div class="line">            <span class="selector-class">.extra</span> &#123;</div><div class="line">                <span class="attribute">float</span>: left;</div><div class="line">                <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">                <span class="attribute">min-height</span>: <span class="number">60px</span>;</div><div class="line">                <span class="attribute">background-color</span>: blue;</div><div class="line">                <span class="attribute">margin-left</span>:-<span class="number">200px</span>; </div><div class="line">            &#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid-content"</span>&gt;</span>三栏式双飞翼布局中间自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span>侧边栏定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>右侧定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>以上就是圣杯布局和双飞翼布局。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;利用浮动特性可以实现一些布局，比较经典的有个圣杯布局，后来经过改进又出现了双飞翼布局，下面就来介绍一下这两种布局。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://callmejay.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>基于vue配置移动端rem布局</title>
    <link href="https://callmejay.github.io/2017/07/19/%E5%9F%BA%E4%BA%8Evue%E9%85%8D%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80/"/>
    <id>https://callmejay.github.io/2017/07/19/基于vue配置移动端rem布局/</id>
    <published>2017-07-19T14:18:29.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>今天来聊一聊基于<code>vue-cli</code>配置的移动端屏幕适配问题。</p>
</blockquote>
<p>配方还是一样：手淘的<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">lib-flexible</a> + <code>rem</code></p>
<h3 id="配置-flexible"><a href="#配置-flexible" class="headerlink" title="配置 flexible"></a>配置 flexible</h3><h4 id="安装-lib-flexible"><a href="#安装-lib-flexible" class="headerlink" title="安装 lib-flexible"></a>安装 lib-flexible</h4><p>在命令行中运行如下安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i lib-flexible --save</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="引入-lib-flexible"><a href="#引入-lib-flexible" class="headerlink" title="引入 lib-flexible"></a>引入 lib-flexible</h4><p>在项目入口文件 <code>main.js</code> 里 引入 <code>lib-flexible</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> <span class="string">'lib-flexible'</span></div></pre></td></tr></table></figure></p>
<h4 id="添加-meta-标签"><a href="#添加-meta-标签" class="headerlink" title="添加 meta 标签"></a>添加 meta 标签</h4><p>在项目根目录的 <code>index.html</code> 中添加如下 <code>meta</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="px-转-rem"><a href="#px-转-rem" class="headerlink" title="px 转 rem"></a>px 转 rem</h3><p>实际开发中，我们通过设计稿得到的值单位是 <code>px</code>，所以要将 <code>px</code> 转换成 <code>rem</code> 再写进样式中。<br>将 <code>px</code> 转换成 <code>rem</code> 我们将使用 <code>px2rem</code> 这个工具，它有 <code>webpack</code> 的 <code>loader</code>：<a href="https://github.com/Jinjiang/px2rem-loader" target="_blank" rel="external">px2rem-loader</a></p>
<h4 id="安装-px2rem-loader"><a href="#安装-px2rem-loader" class="headerlink" title="安装 px2rem-loader"></a>安装 px2rem-loader</h4><p>在命令行中运行如下安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i px2rem-loade --save-dev</div></pre></td></tr></table></figure></p>
<h4 id="配置-px2rem-loade"><a href="#配置-px2rem-loade" class="headerlink" title="配置 px2rem-loade"></a>配置 px2rem-loade</h4><p>在 <code>vue-cli</code> 生成的 <code>webpack</code> 配置中，<code>vue-loader</code> 的 <code>options</code> 和其他样式文件 <code>loader</code> 最终是都是由 <code>build/utils.js</code> 里的一个方法生成的。</p>
<p>我们只需在 <code>cssLoader</code> 后再加上一个 <code>px2remLoader</code> 即可，<code>px2rem-loader</code> 的 <code>remUnit</code> 选项意思是 <code>1rem</code>=多少像素，结合 <code>lib-flexible</code> 的方案，我们将 <code>px2remLoader</code> 的 <code>options.remUnit</code> 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 <code>750px</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils.js</span></div><div class="line"><span class="keyword">var</span> cssLoader = &#123;</div><div class="line">  <span class="attr">loader</span>: <span class="string">'css-loader'</span>,</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">minimize</span>: process.env.NODE_ENV === <span class="string">'production'</span>,</div><div class="line">    <span class="attr">sourceMap</span>: options.sourceMap</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> px2remLoader = &#123;</div><div class="line">  <span class="attr">loader</span>: <span class="string">'px2rem-loader'</span>,</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">remUnit</span>: <span class="number">75</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure></p>
<p>并放进 loaders 数组中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLoaders</span>(<span class="params">loader, loaderOptions</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> loaders = [cssLoader, px2remLoader]</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure></p>
<p>修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天来聊一聊基于&lt;code&gt;vue-cli&lt;/code&gt;配置的移动端屏幕适配问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;配方还是一样：手淘的&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lib-flexible&lt;/a&gt; + &lt;code&gt;rem&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-flexible&quot;&gt;&lt;a href=&quot;#配置-flexible&quot; class=&quot;headerlink&quot; title=&quot;配置 flexible&quot;&gt;&lt;/a&gt;配置 flexible&lt;/h3&gt;&lt;h4 id=&quot;安装-lib-flexible&quot;&gt;&lt;a href=&quot;#安装-lib-flexible&quot; class=&quot;headerlink&quot; title=&quot;安装 lib-flexible&quot;&gt;&lt;/a&gt;安装 lib-flexible&lt;/h4&gt;&lt;p&gt;在命令行中运行如下安装：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm i lib-flexible --save&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="vue" scheme="https://callmejay.github.io/tags/vue/"/>
    
      <category term="rem" scheme="https://callmejay.github.io/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的10个重点及难点</title>
    <link href="https://callmejay.github.io/2017/07/15/JavaScript%E7%9A%8410%E4%B8%AA%E9%87%8D%E7%82%B9%E5%8F%8A%E9%9A%BE%E7%82%B9/"/>
    <id>https://callmejay.github.io/2017/07/15/JavaScript的10个重点及难点/</id>
    <published>2017-07-15T13:22:43.000Z</published>
    <updated>2018-02-10T09:29:37.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p><strong>立即执行函数</strong>，即<code>Immediately Invoked Function Expression (IIFE)</code>，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">// 代码</span></div><div class="line">     <span class="comment">// ...</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p><code>function(){…}</code>是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。<strong>立即执行函数</strong>也可以理解为立即调用一个匿名函数。<strong>立即执行函数</strong>最常见的应用场景就是：将<code>var</code>变量的作用域限制于你们函数内，这样可以避免命名冲突。<br><a id="more"></a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> N = <span class="number">0</span>; <span class="comment">// N是f1函数的局部变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123; <span class="comment">// f2是f1函数的内部函数，是闭包</span></div><div class="line">        N += <span class="number">1</span>; <span class="comment">// 内部函数f2中使用了外部函数f1中的变量N</span></div><div class="line">        <span class="built_in">console</span>.log(N);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> f2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = f1();</div><div class="line"></div><div class="line">result(); <span class="comment">// 输出1</span></div><div class="line">result(); <span class="comment">// 输出2</span></div><div class="line">result(); <span class="comment">// 输出3</span></div></pre></td></tr></table></figure></p>
<p>代码中，外部函数<code>f1</code>只执行了一次，变量<code>N</code>设为0，并将内部函数<code>f2</code>赋值给了变量<code>result</code>。由于外部函数<code>f1</code>已经执行完毕，其内部变量<code>N</code>应该在内存中被清除，然而事实并不是这样：我们每次调用<code>result</code>的时候，发现变量<code>N</code>一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>
<h3 id="使用闭包定义私有变量"><a href="#使用闭包定义私有变量" class="headerlink" title="使用闭包定义私有变量"></a>使用闭包定义私有变量</h3><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> name;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Product();</div><div class="line">p.setName(<span class="string">"Fundebug"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// 输出undefined</span></div><div class="line"><span class="built_in">console</span>.log(p.getName()); <span class="comment">// 输出Fundebug</span></div></pre></td></tr></table></figure></p>
<p>代码中，对象<code>p</code>的的<code>name</code>属性为私有属性，使用<code>p.name</code>不能直接访问。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个<code>JavaScript</code>构造函数都有一个<code>prototype</code>属性，用于设置所有实例对象需要共享的属性和方法。<code>prototype</code>属性不能列举。<code>JavaScript</code>仅支持通过<code>prototype</code>属性进行继承属性和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>._length = x;</div><div class="line">    <span class="keyword">this</span>._breadth = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getDimensions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">length</span>: <span class="keyword">this</span>._length,</div><div class="line">        <span class="attr">breadth</span>: <span class="keyword">this</span>._breadth</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(x.getDimensions()); <span class="comment">// &#123; length: 3, breadth: 4 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(y.getDimensions()); <span class="comment">// &#123; length: 4, breadth: 3 &#125;</span></div></pre></td></tr></table></figure></p>
<p>代码中，<code>x</code>和<code>y</code>都是构造函数<code>Rectangle</code>创建的对象实例，它们通过<code>prototype</code>继承了<code>getDimensions</code>方法。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p><code>JavaScript</code>并非模块化编程语言，至少<code>ES6</code>落地之前都不是。然而对于一个复杂的<code>Web</code>应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多<code>JS</code>库比如<code>jQuery</code>以及<code>Fundebug</code>都是这样实现的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> N = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"The result is: "</span> + x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> x = a + N;</div><div class="line">        print(x);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">description</span>: <span class="string">"This is description"</span>,</div><div class="line">        <span class="attr">add</span>: add</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.description); <span class="comment">// 输出"this is description" </span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.add(<span class="number">5</span>); <span class="comment">// 输出“The result is: 10”</span></div></pre></td></tr></table></figure></p>
<p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，<code>module</code>为一个独立的模块，<code>N</code>为其私有属性，<code>print</code>为其私有方法，<code>decription</code>为其公有属性，<code>add</code>为其共有方法。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p><code>JavaScript</code>会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(<code>Hoisting</code>)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>
<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// 输出undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> y = <span class="number">2</span>; <span class="comment">// 初始化y</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等价于下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> y;  <span class="comment">// 声明y</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// 输出undefined</span></div><div class="line"></div><div class="line">y = <span class="number">2</span>; <span class="comment">// 初始化y</span></div></pre></td></tr></table></figure></p>
<p>为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化，即<code>Currying</code>，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 输出2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> add1 = add(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>)); <span class="comment">// 输出2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> add10 = add(<span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(add10(<span class="number">1</span>)); <span class="comment">// 输出11</span></div></pre></td></tr></table></figure></p>
<p>代码中，我们可以一次性传入2个1作为参数<code>add(1)(1)</code>，也可以传入1个参数之后获取<code>add1</code>与<code>add10</code>函数，这样使用起来非常灵活。</p>
<h3 id="apply-call与bind方法"><a href="#apply-call与bind方法" class="headerlink" title="apply, call与bind方法"></a>apply, call与bind方法</h3><p><code>JavaScript</code>开发者有必要理解<code>apply</code>、<code>call</code>与<code>bind</code>方法的不同点。它们的共同点是第一个参数都是<code>this</code>，即函数运行时依赖的上下文。</p>
<p>三者之中，<code>call</code>方法是最简单的，它等价于指定<code>this</code>值调用函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Rahul Mhatre"</span>,</div><div class="line">    <span class="attr">whatIsYourName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.whatIsYourName(); <span class="comment">// 输出"Rahul Mhatre",</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> user2 = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Neha Sampat"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.whatIsYourName.call(user2); <span class="comment">// 输出"Neha Sampat"</span></div></pre></td></tr></table></figure></p>
<p><code>apply</code>方法与<code>call</code>方法类似。两者唯一的不同点在于，<code>apply</code>方法使用数组指定参数，而<code>call</code>方法每个参数单独需要指定：</p>
<ul>
<li>apply(thisArg, [argsArray])</li>
<li>call(thisArg, arg1, arg2, …)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">greet</span>: <span class="string">"Hello!"</span>,</div><div class="line">    <span class="attr">greetUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userName</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.greet + <span class="string">" "</span> + userName);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> greet1 = &#123;</div><div class="line">    <span class="attr">greet</span>: <span class="string">"Hola"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.greetUser.call(greet1, <span class="string">"Rahul"</span>); <span class="comment">// 输出"Hola Rahul"</span></div><div class="line">user.greetUser.apply(greet1, [<span class="string">"Rahul"</span>]); <span class="comment">// 输出"Hola Rahul"</span></div></pre></td></tr></table></figure>
<p>使用<code>bind</code>方法，可以为函数绑定<code>this</code>值，然后作为一个新的函数返回：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">     <span class="attr">greet</span>: <span class="string">"Hello!"</span>,</div><div class="line">     <span class="attr">greetUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userName</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.greet + <span class="string">" "</span> + userName);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> greetHola = user.greetUser.bind(&#123;<span class="attr">greet</span>: <span class="string">"Hola"</span>&#125;);</div><div class="line"><span class="keyword">var</span> greetBonjour = user.greetUser.bind(&#123;<span class="attr">greet</span>: <span class="string">"Bonjour"</span>&#125;);</div><div class="line"></div><div class="line">greetHola(<span class="string">"Rahul"</span>) <span class="comment">// 输出"Hola Rahul"</span></div><div class="line">greetBonjour(<span class="string">"Rahul"</span>) <span class="comment">// 输出"Bonjour Rahul"</span></div></pre></td></tr></table></figure></p>
<h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><p><code>Memoization</code>用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoizeFunction</span>(<span class="params">func</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> key = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span> (cache[key])&#123;</div><div class="line">            <span class="keyword">return</span> cache[key];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">var</span> val = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">            cache[key] = val;</div><div class="line">            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fibonacci = memoizeFunction(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) ? n : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000</span></div><div class="line"><span class="built_in">console</span>.log(fibonacci(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000</span></div></pre></td></tr></table></figure></p>
<p>代码中，第2次计算<code>fibonacci(100)</code>则只需要在内存中直接读取结果。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>所谓函数重载(<code>method overloading</code>)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过<code>if...else</code>或者<code>switch</code>实现，这就不去管它了。<code>jQuery</code>之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>
<p>从效果上来说，<code>people</code>对象的<code>find</code>方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据<code>firstName</code>查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>
<p>难点在于，<code>people.find</code>只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数<code>find0,find1</code>与<code>find2</code>啊！这里的关键在于<code>old</code>属性。</p>
<p>由<code>addMethod</code>函数的调用顺序可知，<code>people.find</code>最终绑定的是<code>find2</code>函数。然而，在绑定<code>find2</code>时，<code>old</code>为<code>find1</code>；同理，绑定<code>find1</code>时，<code>old</code>为<code>find0</code>。3个函数<code>find0</code>,<code>find1</code>与<code>find2</code>就这样通过闭包链接起来了。</p>
<p>根据<code>addMethod</code>的逻辑，当<code>f.length</code>与<code>arguments.length</code>不匹配时，就会去调用<code>old</code>，直到匹配为止。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params">object, name, f</span>)</span>&#123;　　</div><div class="line">    <span class="keyword">var</span> old = object[name];　　</div><div class="line">    object[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// f.length为函数定义时的参数个数</span></div><div class="line">        <span class="comment">// arguments.length为函数调用时的参数个数　　　　</span></div><div class="line">        <span class="keyword">if</span> (f.length === <span class="built_in">arguments</span>.length)&#123;　　</div><div class="line">            <span class="keyword">return</span> f.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);　　　　</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">"function"</span>)&#123;</div><div class="line">            <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不传参数时，返回所有name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find0</span>(<span class="params"></span>)</span>&#123;　　</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.names;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传一个参数时，返回firstName匹配的name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find1</span>(<span class="params">firstName</span>)</span>&#123;　　</div><div class="line">    <span class="keyword">var</span> result = [];　　</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.names.length; i++)&#123;　　　　</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.names[i].indexOf(firstName) === <span class="number">0</span>)&#123;　　　　　　</div><div class="line">            result.push(<span class="keyword">this</span>.names[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传两个参数时，返回firstName和lastName都匹配的name</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">find2</span>(<span class="params">firstName, lastName</span>)</span>&#123;　</div><div class="line">    <span class="keyword">var</span> result = [];　　</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.names.length; i++)&#123;　　　　</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.names[i] === (firstName + <span class="string">" "</span> + lastName))&#123;　　　　　　</div><div class="line">            result.push(<span class="keyword">this</span>.names[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> people = &#123;　　</div><div class="line">    <span class="attr">names</span>: [<span class="string">"Dean Edwards"</span>, <span class="string">"Alex Russell"</span>, <span class="string">"Dean Tom"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">addMethod(people, <span class="string">"find"</span>, find0);</div><div class="line">addMethod(people, <span class="string">"find"</span>, find1);</div><div class="line">addMethod(people, <span class="string">"find"</span>, find2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(people.find()); <span class="comment">// 输出["Dean Edwards", "Alex Russell", "Dean Tom"]</span></div><div class="line"><span class="built_in">console</span>.log(people.find(<span class="string">"Dean"</span>)); <span class="comment">// 输出["Dean Edwards", "Dean Tom"]</span></div><div class="line"><span class="built_in">console</span>.log(people.find(<span class="string">"Dean"</span>, <span class="string">"Edwards"</span>)); <span class="comment">// 输出["Dean Edwards"]</span></div></pre></td></tr></table></figure></p>
<p><a href="http://www.jianshu.com/p/dc3f4b0bed52" target="_blank" rel="external">传送门~</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;立即执行函数&quot;&gt;&lt;a href=&quot;#立即执行函数&quot; class=&quot;headerlink&quot; title=&quot;立即执行函数&quot;&gt;&lt;/a&gt;立即执行函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;立即执行函数&lt;/strong&gt;，即&lt;code&gt;Immediately Invoked Function Expression (IIFE)&lt;/code&gt;，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;function(){…}&lt;/code&gt;是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。&lt;strong&gt;立即执行函数&lt;/strong&gt;也可以理解为立即调用一个匿名函数。&lt;strong&gt;立即执行函数&lt;/strong&gt;最常见的应用场景就是：将&lt;code&gt;var&lt;/code&gt;变量的作用域限制于你们函数内，这样可以避免命名冲突。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://callmejay.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>经典前端面试题(JavaScript)</title>
    <link href="https://callmejay.github.io/2017/07/12/%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript/"/>
    <id>https://callmejay.github.io/2017/07/12/经典前端面试题-JavaScript/</id>
    <published>2017-07-12T13:01:02.000Z</published>
    <updated>2018-02-10T09:29:37.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉"><a href="#写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉" class="headerlink" title="写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉"></a>写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg = <span class="regexp">/(&lt;\w+&gt;)|(&lt;\/\w+&gt;)/gi</span>;</div><div class="line"><span class="keyword">var</span> str = <span class="string">'&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;'</span>;</div><div class="line">alert(str.replace(reg,<span class="string">""</span>));</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="编写一个函数-用于统计一个字符串中出现次数最多的字符和其出现的次数？"><a href="#编写一个函数-用于统计一个字符串中出现次数最多的字符和其出现的次数？" class="headerlink" title="编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？"></a>编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'asdfssaaasasasasaa'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxAppearChar</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> maxKey = <span class="string">''</span>; </div><div class="line">    <span class="keyword">var</span> maxIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</div><div class="line">        <span class="keyword">if</span>( obj[ arr[i] ] )&#123;</div><div class="line">            obj[ arr[i] ] += <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            obj[ arr[i] ] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( key <span class="keyword">in</span> obj ) &#123;</div><div class="line">        <span class="keyword">if</span>(obj[key] &gt; maxIndex) &#123;</div><div class="line">            maxKey = key;</div><div class="line">            maxIndex = obj[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (<span class="string">'出现最多字符是'</span> + maxKey + <span class="string">',一共出现了'</span> + maxIndex + <span class="string">"次"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="闭包是什么-有什么特性-对页面有什么影响"><a href="#闭包是什么-有什么特性-对页面有什么影响" class="headerlink" title="闭包是什么? 有什么特性? 对页面有什么影响?"></a>闭包是什么? 有什么特性? 对页面有什么影响?</h4><p>(1)闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.<br>(2)闭包有什么特性:<br>通过闭包,可以提供私有作用域.<br>函数执行完后,内部不会释放<br>通过闭包,可以实现带有存储函数运行时变量的函数.<br>(3)对页面有什么影响:大量使用闭包会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<h4 id="写一个reverseStr函数来实现字符串反转，如将-‘12345678’-变成-‘87654321’"><a href="#写一个reverseStr函数来实现字符串反转，如将-‘12345678’-变成-‘87654321’" class="headerlink" title="写一个reverseStr函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’"></a>写一个reverseStr函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'12345678'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseStr</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="将数字-12345678-转化成-RMB形式-如：-12-345-678"><a href="#将数字-12345678-转化成-RMB形式-如：-12-345-678" class="headerlink" title="将数字 12345678 转化成 RMB形式 如： 12,345,678"></a>将数字 12345678 转化成 RMB形式 如： 12,345,678</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatNumberToRMB</span> (<span class="params"> number </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> str = number + <span class="string">''</span>;</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">''</span>).reverse(); <span class="comment">//[8,7,6,5,4,3,2,1]</span></div><div class="line">    <span class="keyword">var</span> resultArr = [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</div><div class="line">        resultArr.push( arr[i] );</div><div class="line">        <span class="keyword">if</span>( (i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) != arr.length )&#123;</div><div class="line">            resultArr.push(<span class="string">','</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resultArr.reverse().join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="请写一个阻止冒泡的兼容函数"><a href="#请写一个阻止冒泡的兼容函数" class="headerlink" title="请写一个阻止冒泡的兼容函数"></a>请写一个阻止冒泡的兼容函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span> (<span class="params"> e </span>) </span>&#123;</div><div class="line">    e = <span class="built_in">window</span>.event ? <span class="built_in">window</span>.event : e;</div><div class="line">    <span class="keyword">if</span>( e.stopPropagation ) &#123;</div><div class="line">        e.stopPropagation();</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        e.cancelBubble = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用js实现随机选取10–100之间的10个数字，存入一个数组，并排序"><a href="#用js实现随机选取10–100之间的10个数字，存入一个数组，并排序" class="headerlink" title="用js实现随机选取10–100之间的10个数字，存入一个数组，并排序"></a>用js实现随机选取10–100之间的10个数字，存入一个数组，并排序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSortedRandomNumber</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</div><div class="line">        arr.push( <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">90</span> ) + <span class="number">10</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"> a, b </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> a - b;</div><div class="line">    &#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-“a”-”1”-”b”-”2”-”c”-””-”d”-”xxx”-”e”-”undefined”"><a href="#有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-“a”-”1”-”b”-”2”-”c”-””-”d”-”xxx”-”e”-”undefined”" class="headerlink" title="有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}"></a>有这样一个URL：<code>http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</code>，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryJson</span> (<span class="params"> URLstr </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> queryIndex = URLstr.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> queryStr = URLstr.slice( queryIndex ); <span class="comment">//a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</span></div><div class="line">    <span class="keyword">var</span> arr = queryStr.split( <span class="string">'&amp;'</span> ); <span class="comment">//[ a=1, b=2, c=, d=xxx, e ]</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> resultArr =  [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ ) &#123;</div><div class="line">        <span class="keyword">var</span> tempArr = arr[ i ].split( <span class="string">'='</span> );</div><div class="line">        obj[ tempArr[<span class="number">0</span>] ] = tempArr[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</div><div class="line">        resultArr.push( <span class="string">'"'</span> + key + <span class="string">'"'</span> + <span class="string">':'</span>  + <span class="string">'"'</span> + obj[ key ] + <span class="string">'"'</span>   ); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'&#123;'</span> + resultArr.join(<span class="string">','</span>) + <span class="string">'&#125;'</span>; <span class="comment">//&#123;"a":"1","b":"2","c":"","d":"xxx","e":"undefined"&#125;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="写一个function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#写一个function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="写一个function，清除字符串前后的空格。（兼容所有浏览器）"></a>写一个function，清除字符串前后的空格。（兼容所有浏览器）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.trim !== <span class="string">'function'</span> ) &#123;</div><div class="line">    <span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.replace ( <span class="regexp">/^\s*|\s*$/g</span>, <span class="string">''</span> );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取页面所有的checkbox"><a href="#获取页面所有的checkbox" class="headerlink" title="获取页面所有的checkbox"></a>获取页面所有的checkbox</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resultArr= [];</div><div class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.querySelectorAll(<span class="string">'input'</span>);</div><div class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; input.length; i++ ) &#123;</div><div class="line">    <span class="keyword">if</span>( input[i].type == <span class="string">'checkbox'</span> ) &#123;</div><div class="line">        resultArr.push( input[i] );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//resultArr即中获取到了页面中的所有checkbox</span></div></pre></td></tr></table></figure>
<h4 id="已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”"><a href="#已知有字符串foo-”get-element-by-id”-写一个function将其转化成驼峰表示法”getElementById”" class="headerlink" title="已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”"></a>已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCamelCase</span> (<span class="params"> str </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = str.split(<span class="string">"-"</span>);</div><div class="line">    <span class="keyword">var</span> resultArr = [];</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++ )&#123;</div><div class="line">        <span class="keyword">if</span>( i === <span class="number">0</span> ) &#123;</div><div class="line">            resultArr.push( arr[i] ); </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            resultArr.push( arr[i].charAt( <span class="number">0</span> ).toUpperCase() + arr[i].slice( <span class="number">1</span> ) );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resultArr.join(<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&quot;&gt;&lt;a href=&quot;#写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&quot; class=&quot;headerlink&quot; title=&quot;写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&quot;&gt;&lt;/a&gt;写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; reg = &lt;span class=&quot;regexp&quot;&gt;/(&amp;lt;\w+&amp;gt;)|(&amp;lt;\/\w+&amp;gt;)/gi&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;div&amp;gt;这里是div&amp;lt;p&amp;gt;里面的段落&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(str.replace(reg,&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="面试题" scheme="https://callmejay.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>带你走进Gulp</title>
    <link href="https://callmejay.github.io/2017/07/11/%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9BGulp/"/>
    <id>https://callmejay.github.io/2017/07/11/带你走进Gulp/</id>
    <published>2017-07-11T15:05:47.000Z</published>
    <updated>2018-02-10T09:29:37.037Z</updated>
    
    <content type="html"><![CDATA[<p><code>Gulp</code>是一款前端自动化构建工具。通俗的来说，就是你本来需要很多条指令才可以完成的事情，通过<code>Gulp</code>你可能只需要一条指令。<br><a id="more"></a></p>
<h3 id="Gulp是什么鬼"><a href="#Gulp是什么鬼" class="headerlink" title="Gulp是什么鬼"></a>Gulp是什么鬼</h3><p>首先，我很确定它不是鬼。对于之前接触过<code>Webpack</code>的人来说，很大的一个疑惑可能就是：这两者有什么区别？因为<code>Webpack</code>几乎能做全部我们需要做的事情，<code>Gulp</code>存在的意义是什么？我只能说：存在即合理。<br><code>Gulp</code>貌似是一款取代<code>Grunt</code>的工具，我没有去了解过<code>Grunt</code>，可能是因为没时间，而且好像也不是很有必要。<code>Gulp</code>的核心功能是<strong>自动化任务流程，简化操作</strong>。比如你需要做打包、编译、压缩、合并等一些乱七八糟的事情，不用<code>Gulp</code>，你可能需要一步一步的“自己”来，而有了<code>Gulp</code>，你预先将这些乱七八糟的事情定义好交给<code>Gulp</code>，然后在特定时刻，<code>Gulp</code>自动将这些事情全都做了。<br>而<code>Webpack</code>的核心功能应该是集中在模块管理上，不过它同样可以通过各种插件，做很多事情。过于纠结这两者的区别也没什么必要。<code>Gulp</code>简单，学起来也就一两天的事。<code>Webpack</code>相对要复杂很多，而且对于新手也有很多坑，但不可忽略它确实很强大。这里的建议是，都学一下，毕竟这是现在最火的两款开发工具。</p>
<h3 id="很重要的几个概念"><a href="#很重要的几个概念" class="headerlink" title="很重要的几个概念"></a>很重要的几个概念</h3><p><code>Gulp</code>不算复杂，去<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">官网</a>也就那么一丁点儿的介绍，所以学习之前有必要先知道一些概念。</p>
<h4 id="配置文件（gulpfile-js）"><a href="#配置文件（gulpfile-js）" class="headerlink" title="配置文件（gulpfile.js）"></a>配置文件（gulpfile.js）</h4><p><code>Gulp</code>既然是一款工具，就得做一些事情，具体要做些什么，还得由我们来指定。在哪里指定，就是在它的配置文件<code>gulpfile.js</code>中，该文件位于项目的根目录下。以后所有<code>Gulp</code>相关的配置语句都是写在<code>gulpfile.js</code>文件中。</p>
<h4 id="任务（Task）"><a href="#任务（Task）" class="headerlink" title="任务（Task）"></a>任务（Task）</h4><p><code>Gulp</code>把需要做的一些事情定义成一个个的任务，每一个任务都有一个名字，然后通过命令调用这个任务的名字，就可以执行该任务对应的代码。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// gulpfile.js 文件中</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line"><span class="comment">// style 任务</span></div><div class="line">gulp.task(<span class="string">'style'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 一些要做的事情</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// build 任务</span></div><div class="line">gulp.task(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">// 要做的事情 </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>前面定义的都是一些空任务，啥也不会做。因为<code>Gulp</code>本身不会做任何“事情”，它只负责把那些要做的事情准备（分类、串联）好。具体谁来做，那就是插件。</p>
<p><code>Gulp</code>有很多插件，几乎能满足你的各种需求。我想对于初学者来说有个疑问：我怎么知道我需要的插件叫什么？那么，我在这里先列出一些插件。我也不知道这些是不是常用的插件，不过看起来好像比较常用。<br>*gulp-connect：可以跑一个本地服务器，貌似现在应该不会有人直接将index.html拖到浏览器来调试吧；</p>
<ul>
<li><code>gulp-concat</code>：看清了，这是concat，用来合并文件的；</li>
<li><code>gulp-clean</code>：删除文件用的；</li>
<li><code>gulp-rename</code>：重命名文件；</li>
<li><code>gulp-minify-html</code>：压缩html用的；</li>
<li><code>gulp-inject</code>：可以将css样式和js脚本文件插入到html文件中；</li>
<li><code>gulp-minify-css</code>：压缩css；</li>
<li><code>gulp-uglify</code>：压缩js；</li>
<li><code>gulp-imagemin</code>：压缩图片；</li>
<li><code>gulp-postcss</code>：自动添加css中的前缀，很实用的家伙。</li>
</ul>
<p>就这些吧，看清楚长啥样就好了。正如你看到的那样，<code>Gulp</code>所有的插件都是以<code>gulp-</code>开头。对于那些有点经验的人来说，要什么插件可能一般都是直接去<code>npm</code>或<code>github</code>上搜索。对于不知道怎么搜的（一般都是不知道关键词），就老老实实百度吧。<br>一个很好的习惯就是<strong>平时多记录</strong>和<strong>总结</strong>，因为很多插件在不同的工具和平台中，叫法基本上都是一样的。另外，这里还给一个官方收录的<a href="https://gulpjs.com/plugins/" target="_blank" rel="external">插件列表</a>。</p>
<h4 id="具体使用方法"><a href="#具体使用方法" class="headerlink" title="具体使用方法"></a>具体使用方法</h4><p><code>Gulp</code>的安装就不说了，需要的直接看看<a href="http://www.gulpjs.com.cn/docs/getting-started/" target="_blank" rel="external">这里</a>。<br>先举一个栗子（玩玩）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入gulp，无需解释</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="comment">// 引入插件</span></div><div class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>)，</div><div class="line">    sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)，</div><div class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 定义任务</span></div><div class="line">gulp.task(<span class="string">'server'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用 connect 插件创建一个服务器</span></div><div class="line">    connect.server(&#123;</div><div class="line">        <span class="comment">// 这里是传入的一些配置项</span></div><div class="line">        root: <span class="string">'dist'</span>,</div><div class="line">        <span class="attr">livereload</span>: <span class="literal">true</span></div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'style'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 匹配资源文件</span></div><div class="line">    gulp.src(<span class="string">'./src/**/*.scss'</span>)</div><div class="line">    <span class="comment">// 对匹配到的 文件 传到一个插件中</span></div><div class="line">    .pipe(sass(&#123;    <span class="comment">// 用sass插件处理 匹配到的文件</span></div><div class="line">        <span class="comment">// 插件的配置项</span></div><div class="line">        outputStyle: <span class="string">'compressed'</span></div><div class="line">        <span class="comment">// 插件的功能 打印错误信息</span></div><div class="line">    &#125;).on(<span class="string">'error'</span>, sass.logError))</div><div class="line">    <span class="comment">// 串联 将sass处理后的文件 传送到下一个插件中</span></div><div class="line">    <span class="comment">// 将文件 输出到指定目录下</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>))</div><div class="line">    <span class="comment">// 重新加载 服务器</span></div><div class="line">    .pipe(connect.reload());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'script'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(<span class="string">'./src/**/*.js'</span>)</div><div class="line">    .pipe(uglify())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>))</div><div class="line">    .pipe(connect.reload());</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 默认任务 要等到数组中的任务执行完之后 才执行</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'style'</span>, <span class="string">'script'</span>, <span class="string">'server'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 监听 匹配到的文件是否改变</span></div><div class="line">    <span class="comment">// 一旦变化就执行 数组 中的任务</span></div><div class="line">    gulp.watch(<span class="string">'./src/js/*.js'</span>, [<span class="string">'script'</span>]);</div><div class="line">    gulp.watch(<span class="string">'./src/css/*.scss'</span>, [<span class="string">'style'</span>]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>Gulp</code>的基本使用大概就这些，<code>gulpfile.js</code>文件大概就是这个样子的。对于该配置文件，命令行只需执行一条语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp</div></pre></td></tr></table></figure></p>
<p>没错，就这样！该指令会自动执行<strong>默认的任务</strong>。如果要指定具体的任务，后面直接跟上任务名即可，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp server</div></pre></td></tr></table></figure></p>
<h4 id="如何使用插件"><a href="#如何使用插件" class="headerlink" title="如何使用插件"></a>如何使用插件</h4><p>一般典型的用法就是直接将插件传入<code>.pipe</code>函数中，插件的配置项通过一个对象传入插件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.pipe(uglify())</div></pre></td></tr></table></figure></p>
<p>一般若没有特殊要求，可以省略配置项。<code>gulp.src()</code>和<code>.pipe()</code>都会返回一个叫<code>Vinyl files</code>的<code>stream</code>（我也不知道是个什么鬼），所以这些方法是可以串联起来的。</p>
<h4 id="谈几个API"><a href="#谈几个API" class="headerlink" title="谈几个API"></a>谈几个API</h4><p>这里列出一些比较常用的API接口，详细用法请参阅<a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="external">官方文档</a></p>
<ul>
<li><code>gulp.src</code>：匹配文件用的；</li>
<li><code>gulp.dest</code>：输出文件到指定目录；</li>
<li><code>gulp.task</code>：定义一个任务；</li>
<li><code>gulp.watch</code>：监听文件，改动触发。</li>
</ul>
<p>好像就这四个？我也是刚发现，还说列几个常用的。所以学起来还是很容易的，不过要全部学通，可能也要花一点时间。反正我是没有认真把官网的文档看完，尽管它一点也不长。我的想法是，掌握基本的使用方法和思想，有实际需求的时候再去参考官方文档。（关键是我现在没这反面的需求啊）</p>
<h4 id="文件匹配原则"><a href="#文件匹配原则" class="headerlink" title="文件匹配原则"></a>文件匹配原则</h4><p>好像这家伙不是按照常规的正则去匹配的，官方给出了一个<a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">参考</a>，有兴趣的自己看看，反正我没看。<br>直接举几个栗子吧：</p>
<ul>
<li><code>*</code>：能匹配<code>abc.js</code>，<code>a.css</code>，不能匹配<code>a/bc.js</code>；</li>
<li><code>**</code>：能匹配<code>a.js</code>，<code>a/b/cd/d.css</code>；</li>
<li><code>*.*</code>：能匹配<code>aaa.js</code>，<code>b.css</code>；</li>
<li><code>a/**/*.js</code>：能匹配<code>a/b/c/d/ef.js</code>，<code>a/b/c.js</code>。</li>
</ul>
<p>还要说明一点，语句<code>gulp.dest(&#39;dist&#39;)</code>中的<code>dist</code>表示在项目<strong>根目录</strong>下生成<code>dist</code>目录。输出的文件路径是<code>*</code>号匹配到的文件名（未被修改的情况下），上面例子中输出的目录结构是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 假设原文件路径</div><div class="line">- src</div><div class="line">    - css</div><div class="line">        - a.scss</div><div class="line">    - js</div><div class="line">        - b.js</div><div class="line"></div><div class="line">// 输出的文件路径</div><div class="line">- dist</div><div class="line">    - css</div><div class="line">        - a.css</div><div class="line">    - js</div><div class="line">        - b.js</div></pre></td></tr></table></figure></p>
<p>默认情况下，<code>dist</code>只会替换<code>*</code>号之前的路径，当然也可以自己修改，具体自行参阅<a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="external">官方文档</a></p>
<blockquote>
<p><a href="http://www.jianshu.com/p/081a3de6be93" target="_blank" rel="external">传送门</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Gulp&lt;/code&gt;是一款前端自动化构建工具。通俗的来说，就是你本来需要很多条指令才可以完成的事情，通过&lt;code&gt;Gulp&lt;/code&gt;你可能只需要一条指令。&lt;br&gt;
    
    </summary>
    
      <category term="gulp" scheme="https://callmejay.github.io/categories/gulp/"/>
    
    
      <category term="gulp" scheme="https://callmejay.github.io/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>打印样式CSS的技巧和要点</title>
    <link href="https://callmejay.github.io/2017/07/09/%E6%89%93%E5%8D%B0%E6%A0%B7%E5%BC%8FCSS%E7%9A%84%E6%8A%80%E5%B7%A7%E5%92%8C%E8%A6%81%E7%82%B9/"/>
    <id>https://callmejay.github.io/2017/07/09/打印样式CSS的技巧和要点/</id>
    <published>2017-07-09T14:07:50.000Z</published>
    <updated>2018-02-10T09:29:37.038Z</updated>
    
    <content type="html"><![CDATA[<p>不经过任何处理而直接打印网站上的页面会得到一个不理想的效果。</p>
<p>我们WEB开发人员可以简单采用几个要点来使之达到较为合适的效果：</p>
<ul>
<li>使用响应式布局设置打印的效果</li>
<li>在合适的时候打印背景图片和颜色</li>
<li>添加显示的网址或页面链接，以供参考</li>
<li>使用css filter 提高打印的图形效果<a id="more"></a>
<h3 id="针对打印的样式，而不是屏幕显示样式"><a href="#针对打印的样式，而不是屏幕显示样式" class="headerlink" title="针对打印的样式，而不是屏幕显示样式"></a>针对打印的样式，而不是屏幕显示样式</h3>首先，我们需要使用媒体查询（media query）针对打印样式设置。<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@media print &#123;</div><div class="line"> // write some styles</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>重新针对打印写CSS样式是没有必要的，我们只需要针对差异设置打印的样式覆盖掉之前的默认样式。</p>
<p>大多数的浏览器会自动根据打印更改颜色，以节省打印原料，但是我们还是尽可能的手工设置一下。</p>
<p>为了达到最佳效果，使颜色清晰明了，我们至少需要包含一下基本的打印样式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> print &#123; <span class="selector-tag">body</span> &#123; <span class="attribute">color</span>: <span class="number">#000</span>; <span class="attribute">background</span>: <span class="number">#fff</span>; &#125; &#125;</div></pre></td></tr></table></figure></p>
<p>对于打印，大多数情况下我们不需要打印整个页面，只需要打印一个简洁的能够突出需要信息的页面，那么我们将不相关的部分隐藏掉（如：导航条、背景图片）。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Default styles */</span></div><div class="line"></div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(banner.jpg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> print &#123;</div><div class="line">   <span class="selector-tag">h1</span> &#123;</div><div class="line">      <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">      <span class="attribute">background</span>: none;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="selector-tag">nav</span>, <span class="selector-tag">aside</span> &#123;</div><div class="line">      <span class="attribute">display</span>: none;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编写打印样式表的时候，你要注意要使用厘米(cm),英寸(inch)或者磅(pt)作为单位而不是屏幕像素单位，实际的单位对打印非常有用。</p>
<p>为了保证打印样式有用，写CSS样式使打印的内容距离纸张边缘，看起来更好，需要使用 @page 这个语法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> print &#123;</div><div class="line">   <span class="selector-tag">h1</span> &#123;</div><div class="line">      <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">      <span class="attribute">background</span>: none;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="selector-tag">nav</span>, <span class="selector-tag">aside</span> &#123;</div><div class="line">      <span class="attribute">display</span>: none;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="selector-tag">body</span>, <span class="selector-tag">article</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">      <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">      <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @<span class="keyword">page</span> &#123;</div><div class="line">      <span class="attribute">margin</span>: <span class="number">2cm</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了保证不被跨页打印，如一个标题和内容在页面底部被分开：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123; <span class="attribute">page-break-after</span>: avoid; &#125;</div></pre></td></tr></table></figure></p>
<p>另一种情况是要防止图片过宽而超出纸张边缘：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">max-width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三个要点是确保 articles 文章标签的内容，在新的一页开始：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">article</span> &#123;</div><div class="line">   <span class="attribute">page-break-before</span>: always;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，还要注意列表和图片不被分开在不同的页：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">page-break-inside</span>: avoid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="背景图片和颜色"><a href="#背景图片和颜色" class="headerlink" title="背景图片和颜色"></a>背景图片和颜色</h3><p>对于一些网站，颜色和背景图还是非常必要需要遵循的。如果用户是在 webkit 内核浏览器上打印的话，我们可以强制打印机打印屏幕上所看到的颜色（即强制在打印页面上出现任何的背景图和颜色），一般来说彩色打印机可以做到这点，我们需要一个单独的媒体查询：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> print and (color) &#123;</div><div class="line">   * &#123;</div><div class="line">      <span class="attribute">-webkit-print-color-adjust</span>: exact;</div><div class="line">      <span class="attribute">print-color-adjust</span>: exact;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>遗憾的是，这不能马上应用于firefox opera 和IE.</p>
<blockquote>
<p><a href="http://blog.jobbole.com/44662/" target="_blank" rel="external">传送门~</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不经过任何处理而直接打印网站上的页面会得到一个不理想的效果。&lt;/p&gt;
&lt;p&gt;我们WEB开发人员可以简单采用几个要点来使之达到较为合适的效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用响应式布局设置打印的效果&lt;/li&gt;
&lt;li&gt;在合适的时候打印背景图片和颜色&lt;/li&gt;
&lt;li&gt;添加显示的网址或页面链接，以供参考&lt;/li&gt;
&lt;li&gt;使用css filter 提高打印的图形效果
    
    </summary>
    
      <category term="CSS" scheme="https://callmejay.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://callmejay.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>让你豁然开朗的AJAX和JSONP</title>
    <link href="https://callmejay.github.io/2017/07/07/%E8%AE%A9%E4%BD%A0%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97%E7%9A%84AJAX%E5%92%8CJSONP/"/>
    <id>https://callmejay.github.io/2017/07/07/让你豁然开朗的AJAX和JSONP/</id>
    <published>2017-07-07T14:25:58.000Z</published>
    <updated>2018-02-10T09:29:37.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说说JSONP是怎么产生的："><a href="#先说说JSONP是怎么产生的：" class="headerlink" title="先说说JSONP是怎么产生的："></a>先说说JSONP是怎么产生的：</h3><p>1、一个众所周知的问题，<code>Ajax</code>直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、<code>web</code>服务、<code>WCF</code>，只要是跨域请求，一律不准；</p>
<p>2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有src这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>）；</p>
<a id="more"></a>
<p>3、于是可以判断，当前阶段如果想通过纯<code>web</code>端（<code>ActiveX</code>控件、服务端代理、属于未来的<code>HTML5</code>之<code>Websocket</code>等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p>
<p>4、恰巧我们已经知道有一种叫做<code>JSON</code>的纯字符数据格式可以简洁的描述复杂数据，更妙的是<code>JSON</code>还被<code>js</code>原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p>
<p>5、这样子解决方案就呼之欲出了，<code>web</code>客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的<code>js</code>格式文件（一般以<code>JSON</code>为后缀），显而易见，服务器之所以要动态生成<code>JSON</code>文件，目的就在于把客户端需要的数据装入进去。</p>
<p>6、客户端在对<code>JSON</code>文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像<code>AJAX</code>，但其实并不一样。</p>
<p>7、<strong>为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作<code>JSONP</code></strong>，该协议的一个要点就是允许用户传递一个<code>callback</code>参数给服务端，然后服务端返回数据时会将这个<code>callback</code>参数作为函数名来包裹住<code>JSON</code>数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<h3 id="JSONP的客户端具体实现："><a href="#JSONP的客户端具体实现：" class="headerlink" title="JSONP的客户端具体实现："></a>JSONP的客户端具体实现：</h3><p>1.我们知道，哪怕跨域<code>js</code>文件中的代码（当然指符合<code>web</code>脚本安全策略的），<code>web</code>页面也是可以无条件执行的。<br>假设远程服务器上有一个<code>remote.js</code>文件，可以使用以下方式调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//remote.js</span></div><div class="line">alert(<span class="string">'我是远程文件'</span>);</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//jsonp.html</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>addScript<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'remote.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>运行以后可以看到一个弹出框：我是远程文件，说明跨域调用成功。</p>
<p>2.现在我们在<code>jsonp.html</code>页面定义一个函数，然后在远程<code>remote.js</code>中传入数据进行调用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//jsonp.html</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>addScript<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="keyword">let</span> localHandler = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">        alert(<span class="string">'我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：'</span> + data.result);</div><div class="line">    &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'remote.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//remote.js</span></div><div class="line">localHandler(&#123;<span class="string">"result"</span>:<span class="string">"我是远程js带来的数据"</span>&#125;);</div></pre></td></tr></table></figure>
<p>运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程<code>js</code>调用成功，并且还接收到了远程<code>js</code>带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程<code>js</code>知道它应该调用的本地函数叫什么名字呢？毕竟是<code>json</code>p的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。</p>
<p>3、聪明的开发者很容易想到，只要服务端提供的<code>js</code>脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的<code>js</code>代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成<code>js</code>脚本并响应了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//jsonp.html</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"> <span class="comment">// 得到航班信息查询结果后的回调函数 </span></span></div><div class="line">  <span class="keyword">let</span> flightHandler = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; </div><div class="line">    alert(<span class="string">'你查询的航班结果是：票价 '</span>+data.price + <span class="string">' 元，'</span>+<span class="string">'余票 '</span> + data.tickets + <span class="string">' 张。'</span>); </div><div class="line">  &#125;; </div><div class="line"><span class="comment">// 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） </span></div><div class="line"></div><div class="line"><span class="keyword">let</span> url = <span class="string">"flightResult.aspx?code=CA1998&amp;callback=flightHandler"</span>; </div><div class="line"><span class="comment">// 创建script标签，设置其属性 </span></div><div class="line"></div><div class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>); </div><div class="line">script.setAttribute(<span class="string">'src'</span>, url); <span class="comment">// 把script标签加入head，此时调用开始 </span></div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这次的代码变化比较大，不再直接把远程<code>js</code>文件写死，而是编码实现动态查询，而这也正是<code>jsonp</code>客户端实现的核心部分，本例中的重点也就在于如何完成<code>jsonp</code>调用的全过程。</p>
<p>我们看到调用的<code>url</code>中传递了一个<code>code</code>参数，告诉服务器我要查的是CA1998次航班的信息，而<code>callback</code>参数则告诉服务器，我的本地回调函数叫做<code>flightHandler</code>，所以请把查询结果传入这个函数中进行调用。</p>
<p>OK，服务器很聪明，这个叫做<code>flightResult.js</code>的页面生成了一段这样的代码提供给<code>jsonp.html</code>（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flightHandler(&#123; <span class="string">"code"</span>: <span class="string">"CA1998"</span>, <span class="string">"price"</span>: <span class="number">1780</span>, <span class="string">"tickets"</span>: <span class="number">5</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>我们看到，传递给<code>flightHandler</code>函数的是一个<code>json</code>，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，<code>jsonp</code>的执行全过程顺利完成！</p>
<p>4、到这里为止的话，相信你已经能够理解<code>jsonp</code>的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。</p>
<p>什么？你用的是<code>jQuery</code>，想知道<code>jQuery</code>如何实现<code>jsonp</code>调用？好吧，那我就好人做到底，再给你一段<code>jQuery</code>使用<code>jsonp</code>的代码（我们依然沿用上面那个航班信息查询的例子，假定返回<code>jsonp</code>结果不变）：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Untitled Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"> </span></div><div class="line">    jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       $.ajax(&#123;</div><div class="line">          <span class="attr">type</span>: <span class="string">"get"</span>,</div><div class="line">          <span class="attr">async</span>: <span class="literal">false</span>, </div><div class="line">          <span class="attr">url</span>: <span class="string">"remote.js?code=CA1998"</span>, </div><div class="line">          <span class="attr">dataType</span>: <span class="string">"jsonp"</span>, </div><div class="line">          <span class="attr">jsonp</span>: <span class="string">"callback"</span>,<span class="comment">//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)     </span></div><div class="line">          jsonpCallback:<span class="string">"flightHandler"</span>,<span class="comment">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 </span></div><div class="line">          success: <span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123; </div><div class="line">            alert(<span class="string">'您查询到航班信息：票价： '</span> + json.price + <span class="string">' 元，余票： '</span> + json.tickets + <span class="string">' 张。'</span>); </div><div class="line">          &#125;, </div><div class="line">          <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="string">'fail'</span>); </div><div class="line">         &#125; </div><div class="line">       &#125;); </div><div class="line">   &#125;); </div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>是不是有点奇怪？为什么我这次没有写<code>flightHandler</code>这个函数呢？而且竟然也运行成功了！哈哈，这就是<code>jQuery</code>的功劳了，<code>jquery</code>在处理<code>jsonp</code>类型的<code>ajax</code>时（还是忍不住吐槽，虽然<code>jquery</code>也把<code>jsonp</code>归入了<code>ajax</code>，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供<code>success</code>属性方法来调用，是不是很爽呀？</p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><hr>
<p>这里针对<code>ajax</code>与<code>jsonp</code>的异同再做一些补充说明：<br>1、<code>ajax</code>和<code>jsonp</code>这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个<code>url</code>，然后把服务器返回的数据进行处理，因此<code>jquery</code>和<code>ext</code>等框架都把<code>jsonp</code>作为<code>ajax</code>的一种形式进行了封装；</p>
<p>2、但<code>ajax</code>和<code>jsonp</code>其实本质上是不同的东西。<code>ajax</code>的核心是通过<code>XmlHttpRequest</code>获取非本页内容，而<code>jsonp</code>的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>
<p>3、所以说，其实<code>ajax</code>与<code>jsonp</code>的区别不在于是否跨域，<code>ajax</code>通过服务端代理一样可以实现跨域，<code>jsonp</code>本身也不排斥同域的数据的获取。</p>
<p>4、还有就是，<code>jsonp</code>是一种方式或者说非强制性协议，如同<code>ajax</code>一样，它也不一定非要用<code>json</code>格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用<code>jsonp</code>提供公开服务。</p>
<p>总而言之，<code>jsonp</code>不是<code>ajax</code>的一个特例，哪怕<code>jquery</code>等巨头把<code>jsonp</code>封装进了<code>ajax</code>，也不能改变着一点！</p>
<p><a href="http://www.jianshu.com/p/3e6b316cc9a2" target="_blank" rel="external">传送门~</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先说说JSONP是怎么产生的：&quot;&gt;&lt;a href=&quot;#先说说JSONP是怎么产生的：&quot; class=&quot;headerlink&quot; title=&quot;先说说JSONP是怎么产生的：&quot;&gt;&lt;/a&gt;先说说JSONP是怎么产生的：&lt;/h3&gt;&lt;p&gt;1、一个众所周知的问题，&lt;code&gt;Ajax&lt;/code&gt;直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、&lt;code&gt;web&lt;/code&gt;服务、&lt;code&gt;WCF&lt;/code&gt;，只要是跨域请求，一律不准；&lt;/p&gt;
&lt;p&gt;2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有src这个属性的标签都拥有跨域的能力，比如&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;）；&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ajax" scheme="https://callmejay.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>剖析let/const在for循环中的作用原理</title>
    <link href="https://callmejay.github.io/2017/07/01/%E5%89%96%E6%9E%90let-const%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://callmejay.github.io/2017/07/01/剖析let-const在for循环中的作用原理/</id>
    <published>2017-07-01T12:26:38.000Z</published>
    <updated>2018-02-10T09:29:37.036Z</updated>
    
    <content type="html"><![CDATA[<p>1、先来看一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=[];  </div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;   </div><div class="line">   a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">a[<span class="number">1</span>](); <span class="comment">//3</span></div><div class="line">a[<span class="number">2</span>](); <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>2、再来看一下For循环的过程<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (语句 <span class="number">1</span>; 语句 <span class="number">2</span>; 语句 <span class="number">3</span>)</div><div class="line">&#123;</div><div class="line">  被执行的代码块</div><div class="line">&#125;</div><div class="line"><span class="comment">// 语句 1 在循环（代码块）开始前执行</span></div><div class="line"><span class="comment">// 语句 2 定义运行循环（代码块）的条件</span></div><div class="line"><span class="comment">// 语句 3 在循环（代码块）已被执行之后执行</span></div></pre></td></tr></table></figure></p>
<p>3、例子for循环执行过程伪代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=[]</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(i&lt;<span class="number">3</span>) &#123;</div><div class="line">  a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">i++;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(i&lt;<span class="number">3</span>) &#123;</div><div class="line">  a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">i++;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(i&lt;<span class="number">3</span>) &#123;</div><div class="line">  a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">i++;</div><div class="line"></div><div class="line"><span class="comment">/* 数组a此时的状态</span></div><div class="line">a = [</div><div class="line">  function()&#123;console.log(i)&#125;,</div><div class="line">  function()&#123;console.log(i)&#125;,</div><div class="line">  function()&#123;console.log(i)&#125;</div><div class="line">]</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// a[1] = function()&#123;console.log(i)&#125;</span></div><div class="line"></div><div class="line">a[<span class="number">1</span>](); <span class="comment">// 打印3，因为i现在的值是3</span></div><div class="line"></div><div class="line">注：“i现在的值是<span class="number">3</span>”这句话在某种意义上是不准确的，</div><div class="line">从作用域链的角度来说a[<span class="number">1</span>]在它的<span class="keyword">if</span>&#123;&#125;块作用域内没有找到i，</div><div class="line">要去上一级作用域局部作用域中找，这时候找到了i，</div><div class="line">而局部作用域中i现在的值是<span class="number">3</span>。</div></pre></td></tr></table></figure></p>
<p>4、如果把for循环的var换成let<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=[];  </div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;   </div><div class="line">   a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">a[<span class="number">1</span>](); <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="comment">// 执行过程</span></div><div class="line"><span class="keyword">var</span> a=[]</div><div class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(i&lt;<span class="number">3</span>) &#123;</div><div class="line">    <span class="keyword">let</span> i = i;</div><div class="line">    a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">i++;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(i&lt;<span class="number">3</span>) &#123;</div><div class="line">      <span class="keyword">let</span> i = i;</div><div class="line">    a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;  </div><div class="line">&#125;</div><div class="line">i++;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(i&lt;<span class="number">3</span>) &#123;</div><div class="line">      <span class="keyword">let</span> i = i;</div><div class="line">    a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;   </div><div class="line">&#125;</div><div class="line">i++;</div><div class="line"></div><div class="line"><span class="comment">// console.log(i)在其块级作用域内就找到了i，</span></div><div class="line">每次<span class="keyword">for</span>循环把当前i值存入块级作用域。</div><div class="line">所以a[<span class="number">1</span>]()会打印<span class="number">1</span>；</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、先来看一个例子&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=[];  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;i++)&amp;#123;   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   a[i]=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i)&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;](); &lt;span class=&quot;comment&quot;&gt;//3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;](); &lt;span class=&quot;comment&quot;&gt;//3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性</title>
    <link href="https://callmejay.github.io/2017/06/28/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://callmejay.github.io/2017/06/28/ES6新特性/</id>
    <published>2017-06-28T14:28:04.000Z</published>
    <updated>2018-02-10T09:29:37.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6简介"><a href="#ES6简介" class="headerlink" title="ES6简介"></a>ES6简介</h2><p>​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。<br>​由于ES6是在2015年发布的，所以也叫ES2015。<br>​以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….<br><a id="more"></a></p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><blockquote>
<p>在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。</p>
</blockquote>
<p>块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：</p>
<ul>
<li>函数内部</li>
<li>在代码块（即 { }）内部</li>
</ul>
<h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><blockquote>
<p>使用let声明变量的语法和使用var声明的语法是一样的。<strong>但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">if</span>(a &gt; <span class="number">5</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）</span></div><div class="line">    <span class="keyword">let</span> b = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">//由于b是在if块中使用let声明的，所以此处无法访问到。（报错）</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问<br>2.用let声明的变量也没有声明提前这一特性。<br>3.在同一个块中，let声明的变量也不能重复声明。<br>4.在声明变量的时候尽量使用let，慢慢的抛弃var</p>
<h3 id="const声明-Constant-Declarations"><a href="#const声明-Constant-Declarations" class="headerlink" title="const声明(Constant Declarations)"></a>const声明(Constant Declarations)</h3><blockquote>
<p>在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">const</span> b = <span class="number">20</span>;</div><div class="line">    b = <span class="number">30</span>;  <span class="comment">//错误! 常量不能重新赋值</span></div><div class="line">    <span class="keyword">const</span> c; <span class="comment">//错误！ 常量声明的同时必须赋值。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>1.const的特性除了声明的是常量为，其他与let一样。<br>2.在let和const声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。<br>3.使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。</p>
<h3 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h3><blockquote>
<p>使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123; <span class="comment">// 循环结束之后会立即销毁 i</span></div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//此处无法访问到 i 。</span></div></pre></td></tr></table></figure>
<h3 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h3><blockquote>
<p>看下面的代码，是输出10个10，而不是0，1，2，…</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// 输出 "10" 共10次</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>解决办法需要使用函数的自执行特性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(value);</div><div class="line">        &#125;</div><div class="line">    &#125;(i)));</div><div class="line">&#125;</div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// 输出 0，1，2 ... 9</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> funcs = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</div><div class="line">    func();     <span class="comment">// 输出 0，1，2 ... 9</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>说明：<br>let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。</p>
<h2 id="函数的新增特性"><a href="#函数的新增特性" class="headerlink" title="函数的新增特性"></a>函数的新增特性</h2><h3 id="带默认参数的函数"><a href="#带默认参数的函数" class="headerlink" title="带默认参数的函数"></a>带默认参数的函数</h3><blockquote>
<p>JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</div><div class="line">    timeout = timeout || <span class="number">2000</span>;</div><div class="line">    callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.</p>
<blockquote>
<p>ES6从语言层面面上增加了<strong>默认值的</strong>支持。看下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</div><div class="line">    <span class="comment">// 其余代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="默认参数对-arguments-对象的影响"><a href="#默认参数对-arguments-对象的影响" class="headerlink" title="默认参数对 arguments 对象的影响"></a>默认参数对 arguments 对象的影响</h3><blockquote>
<p>在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">//非严格模式</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></div><div class="line">    a = <span class="number">10</span>;</div><div class="line">    b = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>在ES5的严格模式下，arguments只反映参数的初始值，而不再反映命名参数的变化！</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="comment">//严格模式</span></div><div class="line"><span class="meta">    "use strict"</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></div><div class="line">    a = <span class="number">10</span>;</div><div class="line">    b = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//false。  修改a的值不会影响到arguments[0]的值</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//false</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b = <span class="number">30</span></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] === a); <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//true</span></div><div class="line">    a = <span class="number">10</span>;</div><div class="line">    b = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]  === a); <span class="comment">//false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>] === b); <span class="comment">//false。  b使用了默认值，所以表现的和严格模式一样。</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。</p>
</blockquote>
<h3 id="默认参数表达式-Default-Parameter-Expressions"><a href="#默认参数表达式-Default-Parameter-Expressions" class="headerlink" title="默认参数表达式 (Default Parameter Expressions)"></a>默认参数表达式 (Default Parameter Expressions)</h3><blockquote>
<p>参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123; <span class="comment">//表示使用getValue这个函数的返回值作为second的默认值。</span></div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>));     <span class="comment">// 2.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>));        <span class="comment">// 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。</span></div></pre></td></tr></table></figure>
<blockquote>
<p>有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。<br>由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;  <span class="comment">// 使用第一个参数作为第二个参数的默认值</span></div><div class="line">    <span class="keyword">return</span> first + second;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。</p>
</blockquote>
<h3 id="未命名参数问题"><a href="#未命名参数问题" class="headerlink" title="未命名参数问题"></a>未命名参数问题</h3><blockquote>
<p>Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>])  <span class="comment">//取得传入的多余的参数。</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">&gt;ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数( Rest Parameters)**</div><div class="line">语法：function a(a, … b)&#123; &#125;</div><div class="line">剩余参数使用三个点( … )和变量名来表示。</div><div class="line"></div><div class="line">`<span class="string">``</span>js</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, ...b</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">//true  .多余的参数都被放入了b中。b其实就是一个数组。</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：1.函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。<br>2.虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。<br>3.剩余参数是在函数声明的时候出现的。</p>
</blockquote>
<h3 id="函数中的扩展运算符"><a href="#函数中的扩展运算符" class="headerlink" title="函数中的扩展运算符"></a>函数中的扩展运算符</h3><blockquote>
<p>例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用apply方法。</p>
</blockquote>
<p>看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]    </div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values));  <span class="comment">// 100</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>上面这种方法虽然可行，但是总是不是那么直观<br>使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values));  <span class="comment">//使用扩展运算符。相当于拆解了数组了。</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">200</span>));  <span class="comment">//也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。<br>剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面<br>扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。</p>
</blockquote>
<h2 id="全新的函数：箭头函数（-gt-）"><a href="#全新的函数：箭头函数（-gt-）" class="headerlink" title="全新的函数：箭头函数（=&gt;）"></a>全新的函数：箭头函数（=&gt;）</h2><h3 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h3><blockquote>
<p>基本语法如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(形参列表)=&gt;&#123;</div><div class="line">  <span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">4</span>));</div><div class="line"><span class="comment">//前面的箭头函数等同于下面的传统函数</span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">4</span>))</div></pre></td></tr></table></figure>
<blockquote>
<p>如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。<br>如果函数体内有多条语句，则 {} 不能省略。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">4</span>));</div><div class="line"><span class="comment">//前面的箭头函数等同于下面的传统函数</span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">4</span>));</div><div class="line"></div><div class="line"><span class="comment">//如果这一行代码是没有返回值的，则方法的返回自也是undefined</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">3</span>,<span class="number">4</span>));  <span class="comment">//这个地方的返回值就是undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。<strong>当然如果不传入参数也不可以省略</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span>=&gt;</span> a+<span class="number">3</span>; <span class="comment">//因为只有一个参数，所以()可以省略</span></div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">4</span>)); <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 ()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span>=&gt;</span>(&#123;<span class="attr">name</span>:<span class="string">"lisi"</span>, <span class="attr">age</span>:<span class="number">30</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(foo());</div><div class="line"><span class="comment">//等同于下面的；</span></div><div class="line"><span class="keyword">var</span> foo1 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"lisi"</span>,</div><div class="line">        <span class="attr">age</span> : <span class="number">30</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用箭头函数实现函数自执行"><a href="#使用箭头函数实现函数自执行" class="headerlink" title="使用箭头函数实现函数自执行"></a>使用箭头函数实现函数自执行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = (<span class="function"><span class="params">name</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">name</span>: name,</div><div class="line">            <span class="attr">age</span>: <span class="number">30</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">)(<span class="string">"zs"</span>);</div><div class="line"><span class="built_in">console</span>.log(person);</div></pre></td></tr></table></figure>
<h3 id="箭头函数中无this绑定-No-this-Binding"><a href="#箭头函数中无this绑定-No-this-Binding" class="headerlink" title="箭头函数中无this绑定(No this Binding)"></a>箭头函数中无this绑定(No this Binding)</h3><blockquote>
<p>在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。<br><strong>在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式</strong><br>箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。<strong>如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PageHandler = &#123;</div><div class="line">    <span class="attr">id</span>: <span class="string">"123456"</span>,</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</div><div class="line">            event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>); <span class="comment">// 在此处this的和init函数内的this相同。</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">PageHandler.init();</div></pre></td></tr></table></figure>
<p>看下面的一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = &#123;</div><div class="line">    <span class="attr">foo</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>)   <span class="comment">//此处this为window</span></div><div class="line">&#125;</div><div class="line">p.foo();  <span class="comment">//输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。</span></div><div class="line"><span class="comment">//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>说明：1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。<br>2.由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。</p>
</blockquote>
<h3 id="无arguments绑定"><a href="#无arguments绑定" class="headerlink" title="无arguments绑定"></a>无arguments绑定</h3><blockquote>
<p>虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">arguments</span>[<span class="number">0</span>]; <span class="comment">//箭头函数的返回值是foo函数的第一个参数</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arrow = foo(<span class="number">4</span>, <span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(arrow()); <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<h2 id="对象功能的扩展"><a href="#对象功能的扩展" class="headerlink" title="对象功能的扩展"></a>对象功能的扩展</h2><blockquote>
<p>在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。</p>
</blockquote>
<h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><blockquote>
<p>ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括：</p>
</blockquote>
<ul>
<li>普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。</li>
<li>特异对象（exotic object）的某些内部行为和默认的有所差异。</li>
<li>标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。</li>
<li>内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。</li>
</ul>
<h3 id="对象字面量的语法扩展"><a href="#对象字面量的语法扩展" class="headerlink" title="对象字面量的语法扩展"></a>对象字面量的语法扩展</h3><h4 id="简写的属性初始化"><a href="#简写的属性初始化" class="headerlink" title="简写的属性初始化"></a>简写的属性初始化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="comment">//返回一个对象：属性名和参数名相同。</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">name</span>:name,</div><div class="line">        <span class="attr">age</span>:age</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(createPerson(<span class="string">"lisi"</span>, <span class="number">30</span>)); <span class="comment">// &#123;name:"lisi", age:30&#125;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>ES6中，上面的写法可以简化成如下形式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="comment">//返回一个对象：属性名和参数名相同。</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        name,  <span class="comment">//当对象属性名和本地变量名相同时，可以省略冒号和值</span></div><div class="line">        age</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(createPerson(<span class="string">"lisi"</span>, <span class="number">30</span>)); <span class="comment">// &#123;name:"lisi", age:30&#125;</span></div></pre></td></tr></table></figure>
<p><em>当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。</em></p>
<h4 id="简写的方法声明"><a href="#简写的方法声明" class="headerlink" title="简写的方法声明"></a>简写的方法声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'lisi'</span>,</div><div class="line">    <span class="attr">sayHell</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的名字是："</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.sayHell()</div></pre></td></tr></table></figure>
<blockquote>
<p>在ES6中，上面的写法可以简化成如下的形式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'李四'</span>,</div><div class="line">    sayHell() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的名字是："</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">person.sayHell()</div></pre></td></tr></table></figure>
<h4 id="在字面量中动态计算属性名"><a href="#在字面量中动态计算属性名" class="headerlink" title="在字面量中动态计算属性名"></a>在字面量中动态计算属性名</h4><blockquote>
<p>在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">'李四'</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">20</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> attName = <span class="string">'name'</span>;</div><div class="line"><span class="built_in">console</span>.log(p[attName]) <span class="comment">//这里 attName表示的是一个变量名。</span></div></pre></td></tr></table></figure></p>
<p>而下面的方式使用时没有办法访问到attName这个变量的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attName = <span class="string">'name'</span>;</div><div class="line"><span class="keyword">var</span> p = &#123;</div><div class="line">    <span class="attr">attName</span> : <span class="string">'李四'</span>,  <span class="comment">// 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。</span></div><div class="line">    age : <span class="number">20</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(p[attName])  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attName = <span class="string">'name'</span>;</div><div class="line"><span class="keyword">var</span> p = &#123;</div><div class="line">    [attName] : <span class="string">'李四'</span>,  <span class="comment">// 引用了变量attName。相当于添加了一个属性名为name的属性</span></div><div class="line">    age : <span class="number">20</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(p[attName])  <span class="comment">// 李四</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="新增的方法"><a href="#新增的方法" class="headerlink" title="新增的方法"></a>新增的方法</h3><blockquote>
<p>ECMAScript从第五版开始避免在Object.prototype上添加新的全局函数或方法，转而去考虑具体的对象类型（如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。<br>ES6 在全局Object上添加了几个新的方法来轻松地完成一些特定任务。</p>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。<br>ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>);              <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>);             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>));     <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>);            <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);           <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>);              <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>);             <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>));     <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><em>很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 <em>认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的</em>。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。</em></p>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><blockquote>
<p>使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。<br>assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"lisi"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">20</span>,</div><div class="line">    <span class="attr">friends</span> : [<span class="string">'张三'</span>, <span class="string">'李四'</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(p1, p); <span class="comment">//则p1中就有了与p相同的属性和方法.  p1是接受者，p是提供者</span></div><div class="line"><span class="built_in">console</span>.log(p1);</div><div class="line"><span class="comment">//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）</span></div><div class="line"><span class="built_in">console</span>.log(p1.friends == p.friends);  <span class="comment">//true    p1和p的friends同事指向了同一个数组。</span></div><div class="line">p.friends.push(<span class="string">"王五"</span>);</div><div class="line"><span class="built_in">console</span>.log(p1.friends); <span class="comment">//['张三', '李四', '王五']</span></div></pre></td></tr></table></figure>
<blockquote>
<p>assign方法可以接受任意多的提供者。意味着后面提供者的同名属性会覆盖前面提供者的属性值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"lisi"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">20</span>,</div><div class="line">    <span class="attr">friends</span> : [<span class="string">'张三'</span>, <span class="string">'李四'</span>]</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">'zs'</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p2 = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(p2, p, p1); <span class="comment">//p和p1都是提供者</span></div><div class="line"><span class="built_in">console</span>.log(p2.name); <span class="comment">// zs</span></div></pre></td></tr></table></figure>
<h2 id="字符串功能的增强"><a href="#字符串功能的增强" class="headerlink" title="字符串功能的增强"></a>字符串功能的增强</h2><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><blockquote>
<p>在以前在字符串中查找字符串的时候，都是使用indexOf方法。<br>ES6新增了三个方法来查找字符串。</p>
<ul>
<li>includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。</li>
<li>startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。</li>
<li>endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。</li>
</ul>
<p>每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"!"</span>));             <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>));             <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>));           <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>));        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"x"</span>));             <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>, <span class="number">4</span>));        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>, <span class="number">8</span>));          <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="repeat方法"><a href="#repeat方法" class="headerlink" title="repeat方法"></a>repeat方法</h3><blockquote>
<p>ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span>.repeat(<span class="number">3</span>));         <span class="comment">// "xxx"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello"</span>.repeat(<span class="number">2</span>));     <span class="comment">// "hellohello"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"abc"</span>.repeat(<span class="number">4</span>));       <span class="comment">// "abcabcabcabc"</span></div></pre></td></tr></table></figure>
<h3 id="字符串模板字面量"><a href="#字符串模板字面量" class="headerlink" title="字符串模板字面量"></a>字符串模板字面量</h3><blockquote>
<p>模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应：</p>
<ul>
<li>多行字符串 针对多行字符串的形式概念（formal concept）。</li>
<li>基本的字符串格式化 将字符串中的变量置换为值的能力。</li>
<li>转义 HTML 能将字符串进行转义并使其安全地插入到 HTML 的能力。</li>
</ul>
<p>模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。</p>
</blockquote>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><blockquote>
<p>使用一对反引号 ``(tab正上方的按键)来表示模板字面量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = <span class="string">`Hello world!`</span>;   <span class="comment">//使用模板字面量创建了一个字符串</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(message);               <span class="comment">// "Hello world!"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);        <span class="comment">// "string"</span></div><div class="line"><span class="built_in">console</span>.log(message.length);        <span class="comment">// 12</span></div></pre></td></tr></table></figure>
<h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><blockquote>
<p>在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"abc \</span></div><div class="line">aaaaaa";</div><div class="line"><span class="built_in">console</span>.log(s); <span class="comment">//但是输出的结果中不包括换行</span></div></pre></td></tr></table></figure>
<blockquote>
<p>但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">`abc</span></div><div class="line">aaaaa</div><div class="line">dsalfja</div><div class="line">dfadfja`;</div><div class="line"><span class="built_in">console</span>.log(s);</div></pre></td></tr></table></figure>
<blockquote>
<p>但是要注意： 反引号中的所有空格和缩进都是有效字符。</p>
</blockquote>
<h4 id="字符串置换"><a href="#字符串置换" class="headerlink" title="字符串置换"></a>字符串置换</h4><blockquote>
<p>置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。<br>语法：<strong>${变量名、表达式、任意运算、方法调用等}</strong><br>可以嵌入任何有效的JavaScript代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"李四"</span>;</div><div class="line"><span class="keyword">var</span> msg = <span class="string">`欢迎你<span class="subst">$&#123;name&#125;</span>同学`</span>;</div><div class="line"><span class="built_in">console</span>.log(msg)</div></pre></td></tr></table></figure>
<h4 id="模板标签"><a href="#模板标签" class="headerlink" title="模板标签"></a>模板标签</h4><h5 id="什么是模板标签"><a href="#什么是模板标签" class="headerlink" title="什么是模板标签"></a>什么是模板标签</h5><blockquote>
<p>模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> message = myTag<span class="string">`Hello world`</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>在上面的代码中，myTag就是模板标签。<br>myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。</p>
</blockquote>
<h5 id="定义模板标签"><a href="#定义模板标签" class="headerlink" title="定义模板标签"></a>定义模板标签</h5><blockquote>
<p>一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。<br>标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'张三'</span>,</div><div class="line">    age = <span class="number">20</span>,</div><div class="line">    message = show<span class="string">`我来给大家介绍<span class="subst">$&#123;name&#125;</span>的年龄是<span class="subst">$&#123;age&#125;</span>.`</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">    应该定义一个函数show：</div><div class="line">    参数1：一个字符串数组。在本例中包含三个元素。</div><div class="line">            0:"我来给大家介绍"</div><div class="line">            1:"的年龄是"</div><div class="line">            2:"."</div><div class="line">    参数2和参数3：表示需要置换的字符串的值。  </div><div class="line">    */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">stringArr, value1, value2</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(stringArr); <span class="comment">//</span></div><div class="line">    <span class="built_in">console</span>.log(value1);  <span class="comment">// 张三</span></div><div class="line">    <span class="built_in">console</span>.log(value2);  <span class="comment">// 20</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(message); <span class="comment">//abc</span></div></pre></td></tr></table></figure></p>
<p>为了简化书写，一般把Value1和Value2写成剩余字符串的形式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</div><div class="line">  <span class="comment">// blabla...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构的实用性"><a href="#解构的实用性" class="headerlink" title="解构的实用性"></a>解构的实用性</h3><blockquote>
<p>在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> options = &#123;</div><div class="line">        <span class="attr">repeat</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">save</span>: <span class="literal">false</span></div><div class="line">   &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 从对象中提取数据</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> repeat = options.repeat,</div><div class="line">    save = options.save;</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。</p>
<p>这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。</p>
</blockquote>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><h4 id="对象解构的基本形式"><a href="#对象解构的基本形式" class="headerlink" title="对象解构的基本形式"></a>对象解构的基本形式</h4><blockquote>
<p>对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"><span class="comment">//这里就相当于声明了两个变量： type = node.type;  name:node.name</span></div><div class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在上面的结构中必须要初始化。否则会出现语法错误。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法错误！</span></div><div class="line"><span class="keyword">var</span> &#123; type, name &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 语法错误！</span></div><div class="line"><span class="keyword">let</span> &#123; type, name &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 语法错误！</span></div><div class="line"><span class="keyword">const</span> &#123; type, name &#125;;</div></pre></td></tr></table></figure>
<h4 id="解构赋值表达式"><a href="#解构赋值表达式" class="headerlink" title="解构赋值表达式"></a>解构赋值表达式</h4><blockquote>
<p>如果声明的变量想改变他们的值，也可以使用解构表达式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">&#125;,</div><div class="line">type = <span class="string">"Literal"</span>,</div><div class="line">name = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="comment">//注意：此处必须要在圆括号内才能使用解构表达式</span></div><div class="line">(&#123;type, name&#125; = node);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo""</span></div></pre></td></tr></table></figure>
<h4 id="对象解构时的默认值"><a href="#对象解构时的默认值" class="headerlink" title="对象解构时的默认值"></a>对象解构时的默认值</h4><blockquote>
<p>如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"><span class="comment">//因为node中没有叫value的属性，所以valued的值将会是undefined</span></div><div class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p>不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//手动添加value的默认值为3</span></div><div class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="number">3</span>&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h4 id="赋值给不同的变量名"><a href="#赋值给不同的变量名" class="headerlink" title="赋值给不同的变量名"></a>赋值给不同的变量名</h4><blockquote>
<p>在前面的操作中，都是把对象的属性值，赋值给同名变量。<br>其实也可以赋值给不同名的变量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// localType才是要定义的新的变量。  type是node的属性</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><h4 id="数组解构基本语法"><a href="#数组解构基本语法" class="headerlink" title="数组解构基本语法"></a>数组解构基本语法</h4><blockquote>
<p>数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果只想取数组中的某一项，则可以不用命名。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="comment">//只取数组中的第三项。</span></div><div class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thirdColor);        <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<h4 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h4><blockquote>
<p>你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</div><div class="line">    firstColor = <span class="string">"black"</span>,</div><div class="line">    secondColor = <span class="string">"purple"</span>;</div><div class="line"></div><div class="line">[ firstColor, secondColor ] = colors;  <span class="comment">//可以不用加括号。当然添加也不犯法</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">3</span>,</div><div class="line">    b = <span class="number">4</span>,</div><div class="line">    temp;</div><div class="line">temp = a;</div><div class="line">a = b;</div><div class="line">b = temp;</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b)</div></pre></td></tr></table></figure>
<blockquote>
<p>那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">3</span>,</div><div class="line">    b = <span class="number">4</span>;</div><div class="line"><span class="comment">//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。</span></div><div class="line">[a, b] = [b, a];</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div></pre></td></tr></table></figure>
<h2 id="新的基本类型：Symbol"><a href="#新的基本类型：Symbol" class="headerlink" title="新的基本类型：Symbol"></a>新的基本类型：Symbol</h2><blockquote>
<p>以前我们有5种基本数据类型：Number、String、Boolean、Null、Undefined<br>ES6新增了一种新的数据类型：Symbol<br>在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。</p>
<h3 id="创建Symbol"><a href="#创建Symbol" class="headerlink" title="创建Symbol"></a>创建Symbol</h3><p>Symbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。<br>我们可以使用symbol全局函数来创建Symbol。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();   <span class="comment">//创建一个Symbol</span></div><div class="line"><span class="keyword">let</span> person = &#123;&#125;;</div><div class="line"></div><div class="line">person[firstName] = <span class="string">"张三"</span>;</div><div class="line"><span class="built_in">console</span>.log(person[firstName]);     <span class="comment">// "张三"</span></div></pre></td></tr></table></figure>
<p>说明：上面的代码中，firstName作为symbol类型被创建并赋值给 person对象以作其属性。每次访问这个属性时必须使用该 symbol。</p>
<blockquote>
<p>在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"abc"</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"abc"</span>);</div><div class="line"><span class="built_in">console</span>.log(s1 == s2); <span class="comment">//false</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。</p>
</blockquote>
<h3 id="识别Symbol"><a href="#识别Symbol" class="headerlink" title="识别Symbol"></a>识别Symbol</h3><blockquote>
<p>既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol);         <span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<h3 id="Symbol作为属性名"><a href="#Symbol作为属性名" class="headerlink" title="Symbol作为属性名"></a>Symbol作为属性名</h3><p>​由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</div><div class="line"><span class="comment">// 第一种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    [mySymbol]: <span class="string">'Hello!'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br>1,symbol作为对象的属性的时候，只能使用[ ]去访问，不能使用点去访问。<br>2,symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。</p>
<h3 id="Symbol属性名的遍历"><a href="#Symbol属性名的遍历" class="headerlink" title="Symbol属性名的遍历"></a>Symbol属性名的遍历</h3><p>​ Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol属性名。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</div><div class="line"></div><div class="line">obj[a] = <span class="string">'Hello'</span>;</div><div class="line">obj[b] = <span class="string">'World'</span>;</div><div class="line"><span class="comment">// 返回obj对象所有Symbol类型的属性名组成的数组。</span></div><div class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</div><div class="line"><span class="built_in">console</span>.log(objectSymbols)  <span class="comment">//[Symbol(a), Symbol(b)]</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>看下面代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line">obj[foo] = <span class="string">"lisi"</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出 。   因为遍历不到Symbol型的属性 </span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj);<span class="comment">// []   只能拿到非Symbol类型的属性</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">//[Symbol(foo)]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。<br>Reflect.ownKeys()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</div><div class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Reflect</span>.ownKeys(obj);<span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></div></pre></td></tr></table></figure>
<p>说明：由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<h3 id="Symbol-for-字符串-和Symbol-keyFor-symbol类型的值"><a href="#Symbol-for-字符串-和Symbol-keyFor-symbol类型的值" class="headerlink" title="Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)"></a>Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)</h3><blockquote>
<p>Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个symbol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册</span></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="comment">//第二次搜到上次创建的</span></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(a === b);  <span class="comment">//因为两次搜到的是同一个Symbol，所以此处是true</span></div></pre></td></tr></table></figure>
<p>Symbol.for()和Symbol()都可以创建Symbol类型的数据。<br>二者区别：<br>1，Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。<br>2，Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(a)); <span class="comment">// undefined.   因为a没有想全局环境中登记，所以是undefinded</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(b)); <span class="comment">// foo</span></div></pre></td></tr></table></figure>
<h2 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h2><p>​JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。</p>
<p>​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。</p>
<blockquote>
<p>Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set中的元素不能重复，而数组中的元素可以重复。</p>
<p>一句话总结：Set类型是一个包含无重复元素的有序列表</p>
</blockquote>
<h3 id="创建Set和并添加元素"><a href="#创建Set和并添加元素" class="headerlink" title="创建Set和并添加元素"></a>创建Set和并添加元素</h3><blockquote>
<p>Set本身是一个构造函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Set数据结构对象。</span></div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"><span class="comment">//调用set对象的add方法，向set中添加元素</span></div><div class="line">s.add(<span class="string">"a"</span>);</div><div class="line">s.add(<span class="string">"c"</span>);</div><div class="line">s.add(<span class="string">"b"</span>);</div><div class="line"><span class="comment">//set的size属性可以获取set中元素的个数</span></div><div class="line"><span class="built_in">console</span>.log(s.size)</div></pre></td></tr></table></figure>
<h3 id="Set中不能添加重复元素"><a href="#Set中不能添加重复元素" class="headerlink" title="Set中不能添加重复元素"></a>Set中不能添加重复元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">s.add(<span class="string">"a"</span>);</div><div class="line">s.add(<span class="string">"c"</span>);</div><div class="line">s.add(<span class="string">"b"</span>);</div><div class="line">s.add(<span class="string">"a"</span>);  <span class="comment">//重复，所以添加失败。注意这个地方并不会保存。</span></div><div class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 长度是3</span></div></pre></td></tr></table></figure>
<blockquote>
<p>看下面代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">s.add(<span class="number">5</span>);</div><div class="line">s.add(<span class="string">"5"</span>);</div><div class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 长度是2</span></div></pre></td></tr></table></figure>
<p>在上面的代码中，数字5和字符串5都会添加成功。为什么呢？</p>
<blockquote>
<p>Set是使用什么机制来判断两个元素是否相等的呢？<br><strong>是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。</strong><br>回忆一下：这个方法除了 +0和-0、NaN和NaN认为相等，其余和三个 === 是完全一样的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">s.add(+<span class="number">0</span>);</div><div class="line">s.add(<span class="number">-0</span>);  <span class="comment">//重复添加不进去</span></div><div class="line">s.add(<span class="literal">NaN</span>);</div><div class="line">s.add(<span class="literal">NaN</span>); <span class="comment">//重复添加不进去</span></div><div class="line">s.add([]);</div><div class="line">s.add([]);  <span class="comment">//两个空数组不相等，所以可以添加进去</span></div><div class="line">s.add(&#123;&#125;);</div><div class="line">s.add(&#123;&#125;);  <span class="comment">// 两个空对象也不重复，所以也可以添加进去</span></div><div class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 长度是6</span></div></pre></td></tr></table></figure>
<h3 id="使用数组初始化Set"><a href="#使用数组初始化Set" class="headerlink" title="使用数组初始化Set"></a>使用数组初始化Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。</span></div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>]);</div><div class="line"><span class="built_in">console</span>.log(s.size);</div></pre></td></tr></table></figure>
<h3 id="判断一个值是否在Set中"><a href="#判断一个值是否在Set中" class="headerlink" title="判断一个值是否在Set中"></a>判断一个值是否在Set中</h3><blockquote>
<p>使用Set的 has() 方法可以判断一个值是否在这个set中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">"5"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">6</span>));    <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="移除Set中的元素"><a href="#移除Set中的元素" class="headerlink" title="移除Set中的元素"></a>移除Set中的元素</h3><blockquote>
<p>delete(要删除的值) ：删除单个值<br>clear()：清空所有的值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">5</span>);</div><div class="line">set.add(<span class="string">"5"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// true</span></div><div class="line"></div><div class="line">set.delete(<span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>));    <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 1</span></div><div class="line"></div><div class="line">set.clear();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(set.has(<span class="string">"5"</span>));  <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(set.size);      <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h3 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h3><blockquote>
<p>数组有个方法forEach可以遍历数组。<br>Set也有forEach可以遍历Set。<br>使用Set的forEach遍历时的回调函数有三个参数：<br>function (value, key, ownerSet){</p>
<p>}<br>参数1：遍历到的元素的值<br>参数2：对set集合来说，参数2的值和参数1的值是完全一样的。<br>参数3：这个set自己</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="number">9</span>]);</div><div class="line">set.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">v, k, s</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(v + <span class="string">"   "</span> + (v === k) + <span class="string">"  "</span> + (s === set));   <span class="comment">// 永远是true</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="将Set转换为数组"><a href="#将Set转换为数组" class="headerlink" title="将Set转换为数组"></a>将Set转换为数组</h3><blockquote>
<p>将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。<br>把Set转换为数组使用前面讲到的扩展运算符也很容易</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]),</div><div class="line">    arr = [...set];  <span class="comment">//使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响</span></div><div class="line"><span class="built_in">console</span>.log(arr);             <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这种情况在需要去数组中重复元素的时候非常好用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(items)];</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</div><div class="line">    <span class="comment">//返回的是新的没有重复元素的数组。</span></div><div class="line">    noDuplicates = eliminateDuplicates(numbers);</div><div class="line"><span class="built_in">console</span>.log(noDuplicates);      <span class="comment">// [1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<p><em>Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map.</em></p>
<h2 id="Map数据结构"><a href="#Map数据结构" class="headerlink" title="Map数据结构"></a>Map数据结构</h2><p>​ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。</p>
<p>​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。</p>
<p>​这和使用对象属性做为值的方法大相径庭，因为 对象的属性会被强制转换为字符串类型。</p>
<h3 id="创建Map对象和Map的基本的存取操作"><a href="#创建Map对象和Map的基本的存取操作" class="headerlink" title="创建Map对象和Map的基本的存取操作"></a>创建Map对象和Map的基本的存取操作</h3><blockquote>
<p>Map创建也是使用Map构造函数<br>向Map存储键值对使用set(key, value);方法<br>可以使用get(key),来获取指定key对应的value</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">"a"</span>, <span class="string">"lisi"</span>);</div><div class="line">map.set(<span class="string">"b"</span>, <span class="string">"zhangsan"</span>);</div><div class="line">map.set(<span class="string">"b"</span>, <span class="string">"zhangsan222"</span>);  <span class="comment">// 第二次添加，新的value会替换掉旧的</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"a"</span>));</div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"b"</span>));   <span class="comment">//zhangsan222</span></div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"c"</span>)); <span class="comment">//undefined.如果key不存在，则返回undefined</span></div><div class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h3 id="Map与Set类似的3个方法"><a href="#Map与Set类似的3个方法" class="headerlink" title="Map与Set类似的3个方法"></a>Map与Set类似的3个方法</h3><ul>
<li>has(key) - 判断给定的 key 是否在 map 中存在</li>
<li>delete(key) - 移除 map 中的 key 及对应的值</li>
<li>clear() - 移除 map 中所有的键值对</li>
</ul>
<h3 id="初始化Map"><a href="#初始化Map" class="headerlink" title="初始化Map"></a>初始化Map</h3><blockquote>
<p>创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。<br>也就是传入的实际是一个二维数组！</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//map接受一个二维数组</span></div><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">    <span class="comment">//每一个数组中，第一个是map的key，第二个是map的value。如果只有第一个，则值是undefined</span></div><div class="line">    [<span class="string">"name"</span>, <span class="string">"lisi"</span>],  </div><div class="line">    [<span class="string">"age"</span>, <span class="number">20</span>],</div><div class="line">    [<span class="string">"sex"</span>, <span class="string">"nan"</span>]</div><div class="line">]);</div><div class="line"><span class="built_in">console</span>.log(map.size);</div><div class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>));</div></pre></td></tr></table></figure>
<h3 id="Map的forEach方法"><a href="#Map的forEach方法" class="headerlink" title="Map的forEach方法"></a>Map的forEach方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">    [<span class="string">"name"</span>, <span class="string">"李四"</span>],</div><div class="line">    [<span class="string">"age"</span>, <span class="number">20</span>],</div><div class="line">    [<span class="string">"sex"</span>, <span class="string">"nan"</span>]</div><div class="line">]);</div><div class="line"><span class="comment">/*</span></div><div class="line">    回调函数有三个参数：</div><div class="line">    参数1：键值对的value</div><div class="line">    参数2：键值对的key</div><div class="line">    参数3：map对象本身</div><div class="line">    */</div><div class="line">map.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, ownMap</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`key=<span class="subst">$&#123;key&#125;</span> ,vlue=<span class="subst">$&#123;value&#125;</span>`</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="迭代器和for…of循环"><a href="#迭代器和for…of循环" class="headerlink" title="迭代器和for…of循环"></a>迭代器和for…of循环</h2><h3 id="循环问题"><a href="#循环问题" class="headerlink" title="循环问题"></a>循环问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = colors.length; i &lt; len; i++) &#123;</div><div class="line">    <span class="built_in">console</span>.log(colors[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。<br>迭代器就是为了解决这个问题的。</p>
</blockquote>
<h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>​ 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。</p>
<p>​ 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。</p>
<blockquote>
<p>我们可以使用ES5知识创建一个迭代器</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> done = (i &gt;= items.length);</div><div class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">done</span>: done,</div><div class="line">                <span class="attr">value</span>: value</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建一个可以在指定数组上面迭代的迭代器对象。</span></div><div class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// for all further calls</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<p>从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。<br>幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。</p>
<h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><blockquote>
<p><strong>生成器函数就是返回迭代器的函数！</strong><br>生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。<br>看下面代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成器函数。  注意中间的 * 不能丢</span></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//每个yield的后面的值表示我们迭代到的值。   yield也定义了我们迭代的顺序。</span></div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> it = createIterator();</div><div class="line"><span class="built_in">console</span>.log(it.next().value);   <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(it.next().value);   <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(it.next().value);   <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(it.next().value);  <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。</strong><br>每调用一次迭代器的next方法，如果碰到yield都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用next方法，会从上次停止的地方继续执行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。</span></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">      <span class="comment">//每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125;</span></div><div class="line">        <span class="keyword">yield</span> items[i]; </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// 进一步调用</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。</p>
</blockquote>
<h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><blockquote>
<p>你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">        <span class="keyword">yield</span> items[i];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 1, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 2, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: 3, done: false &#125;"</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div><div class="line"></div><div class="line"><span class="comment">// 进一步调用</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next());           <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：无法使用箭头函数来创建生成器。</p>
</blockquote>
<h3 id="可迭代类型和for-of迭代循环"><a href="#可迭代类型和for-of迭代循环" class="headerlink" title="可迭代类型和for-of迭代循环"></a>可迭代类型和for-of迭代循环</h3><blockquote>
<p>迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。</p>
</blockquote>
<p>​与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。<br>​该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。<br>​换句话说，默认情况下只有 数组、set、Map和字符串才可以使用迭代器去迭代。 (也就可以使用for…of了)<br>​for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！</p>
<blockquote>
<p>使用 for…of 迭代数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</div><div class="line">    <span class="built_in">console</span>.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>使用 for…of 迭代Set:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>, <span class="string">"d"</span>]);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> set)&#123;</div><div class="line">    <span class="built_in">console</span>.log(item)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>使用 for…of 迭代Map：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>, <span class="string">"lisi"</span>],[<span class="string">"sex"</span>, <span class="string">"男"</span>],[<span class="string">"age"</span>, <span class="number">20</span>]]);</div><div class="line">map.set(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>)</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> map)&#123;</div><div class="line">    <span class="built_in">console</span>.log(item);  <span class="comment">//注意：这里迭代到的是由key和value组成的数组。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>使用for … of迭代字符串</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">"abcd"</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> s)&#123;</div><div class="line">    <span class="built_in">console</span>.log(c)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常。</p>
</blockquote>
<p>说明：以数组为例。</p>
<p>​ for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。</p>
<p>​ 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。</p>
<h3 id="访问可迭代类型的默认迭代器"><a href="#访问可迭代类型的默认迭代器" class="headerlink" title="访问可迭代类型的默认迭代器"></a>访问可迭代类型的默认迭代器</h3><blockquote>
<p>Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">"abcd"</span>;</div><div class="line"><span class="keyword">let</span> it = s[<span class="built_in">Symbol</span>.iterator]();  <span class="comment">//调用字符串的Symbol.iterator方法</span></div><div class="line"><span class="built_in">console</span>.log(it.next());  <span class="comment">//返回迭代器迭代到的第一个对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p>因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello"</span>));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(&#123;<span class="string">"name"</span>:<span class="string">"李四"</span>&#125;)); <span class="comment">// false。普通对象不可迭代</span></div></pre></td></tr></table></figure>
<h3 id="自定义可迭代类型"><a href="#自定义可迭代类型" class="headerlink" title="自定义可迭代类型"></a>自定义可迭代类型</h3><blockquote>
<p>开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> collection = &#123;</div><div class="line">    <span class="attr">items</span>: [],</div><div class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</div><div class="line">            <span class="keyword">yield</span> item;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">collection.items.push(<span class="number">1</span>);</div><div class="line">collection.items.push(<span class="number">2</span>);</div><div class="line">collection.items.push(<span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote>
<p>和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。<br>这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。<br>尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。</p>
</blockquote>
<h3 id="ES5之前的模拟的类"><a href="#ES5之前的模拟的类" class="headerlink" title="ES5之前的模拟的类"></a>ES5之前的模拟的类</h3><p>​在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// 输出 "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>说明：前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。</p>
<h3 id="ES6中基本的类声明"><a href="#ES6中基本的类声明" class="headerlink" title="ES6中基本的类声明"></a>ES6中基本的类声明</h3><blockquote>
<p>在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//class关键字必须是小写。   后面就是跟的类名</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 等效于 PersonType 构造函数。</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;  <span class="comment">//这个表示类的构造函数。constuctor也是关键字必须小写。</span></div><div class="line">        <span class="keyword">this</span>.name = name;  <span class="comment">//创建属性。  也叫当前类型的自有属性。</span></div><div class="line">    &#125; </div><div class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName.   这里的sayName使用了我们前面的简写的方式。</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// 输出 "Nicholas"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);          <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass);                    <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName);  <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p>说明：<br>1，自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。<br>2，类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。</p>
<p><strong>虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记:</strong><br>1，类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。<br>2，类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。<br>3，所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。<br>4，所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。<br>5，不使用 new 来调用类构造函数会抛出错误。也就是 必须使用new 类() 的方式使用<br>6，试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的）</p>
<h3 id="匿名类表达式"><a href="#匿名类表达式" class="headerlink" title="匿名类表达式"></a>匿名类表达式</h3><blockquote>
<p>函数有函数表达式，类也有类表达式。<br>类表达式的功能和前面的类的声明是一样的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    <span class="comment">// 等效于 PersonType 构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">person.sayName();   <span class="comment">// 输出 "Nicholas"</span></div></pre></td></tr></table></figure>
<h3 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 等效于 PersonType 构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的.</p>
</blockquote>
<h3 id="作为一等公民的类型"><a href="#作为一等公民的类型" class="headerlink" title="作为一等公民的类型"></a>作为一等公民的类型</h3><blockquote>
<p>在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。<br>类也是一等公民。</p>
</blockquote>
<p>类可以作为参数传递<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">classDef</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    sayHi() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.sayHi();        <span class="comment">// "Hi!"</span></div></pre></td></tr></table></figure></p>
<p>立即调用类构造函数，创建单例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line">person.sayName();       <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure></p>
<h3 id="动态计算类成员的命名"><a href="#动态计算类成员的命名" class="headerlink" title="动态计算类成员的命名"></a>动态计算类成员的命名</h3><blockquote>
<p>类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> methodName = <span class="string">"sayName"</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [methodName]() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">"Nicholas"</span>);</div><div class="line">me.sayName();           <span class="comment">// "Nicholas"</span></div></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><blockquote>
<p>在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 静态方法。  直接添加到构造方法上。  (其实是把构造函数当做一个普通的对象来用。)</span></div><div class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 实例方法</span></div><div class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">"Nicholas"</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>在上面的create方法在其他语言中一般都是作为静态方法来使用的。<br>ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 等效于 PersonType 构造函数</span></div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 等效于 PersonType.prototype.sayName</span></div><div class="line">    sayName() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 等效于 PersonType.create。</span></div><div class="line">    <span class="keyword">static</span> create(name) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">"Nicholas"</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：静态成员通过实例对象不能访问，只能通过类名访问！！！</p>
</blockquote>
<h3 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a>ES6中的继承</h3><blockquote>
<p>在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    Father.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line">Son.prototype = <span class="keyword">new</span> Father();</div><div class="line">Son.prototype.constructor = Son;</div><div class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="string">"儿子"</span>, <span class="number">20</span>);</div><div class="line">son1.sayAge();  <span class="comment">//20</span></div><div class="line">son1.sayName(); <span class="comment">//儿子</span></div></pre></td></tr></table></figure>
<h4 id="继承的基本写法"><a href="#继承的基本写法" class="headerlink" title="继承的基本写法"></a>继承的基本写法</h4><blockquote>
<p>如果在ES6通过类的方式完成继承就简单了很多。<br>需要用到一个新的关键字：extends</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    sayName()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  <span class="comment">//extents后面跟表示要继承的类型</span></div><div class="line">    <span class="keyword">constructor</span>(name, age)&#123;</div><div class="line">        <span class="keyword">super</span>(name);  <span class="comment">//相当于以前的：Father.call(this, name);</span></div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//子类独有的方法</span></div><div class="line">    sayAge()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="string">"李四"</span>, <span class="number">30</span>);</div><div class="line">son1.sayAge();</div><div class="line">son1.sayName();</div><div class="line"><span class="built_in">console</span>.log(son1 <span class="keyword">instanceof</span> Son);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(son1 <span class="keyword">instanceof</span> Father);  <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p><em>这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。</em><br><strong>关于super的使用，有几点需要注意：</strong><br>1，你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。<br>2，你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。<br>3，在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。</p>
<h4 id="在子类中屏蔽父类的方法"><a href="#在子类中屏蔽父类的方法" class="headerlink" title="在子类中屏蔽父类的方法"></a>在子类中屏蔽父类的方法</h4><blockquote>
<p>如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    sayName()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  <span class="comment">//extents后面跟表示要继承的类型</span></div><div class="line">    <span class="keyword">constructor</span>(name, age)&#123;</div><div class="line">        <span class="keyword">super</span>(name);  <span class="comment">//相当于以前的：Father.call(this, name);</span></div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//子类独有的方法</span></div><div class="line">    sayAge()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//子类中的方法会屏蔽到父类中的同名方法。</span></div><div class="line">    sayName()&#123;</div><div class="line">            <span class="keyword">super</span>.syaName();  <span class="comment">//调用被覆盖的父类中的方法。 </span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我是子类的方法，我屏蔽了父类："</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="string">"李四"</span>, <span class="number">30</span>);</div><div class="line">son1.sayAge();</div><div class="line">son1.sayName();</div></pre></td></tr></table></figure>
<p>如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。<br>注意：<br>1，如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法<br>2，普通方法调用需要使用super.父类的方法() 来调用。</p>
<h4 id="静态方法也可以继承"><a href="#静态方法也可以继承" class="headerlink" title="静态方法也可以继承"></a>静态方法也可以继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> foo()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我是父类的静态方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">Son.foo(); <span class="comment">//子类也继承了父类的静态方法。  这种方式调用和直接通过父类名调用时一样的。</span></div></pre></td></tr></table></figure>
<h2 id="Moudle"><a href="#Moudle" class="headerlink" title="Moudle"></a>Moudle</h2><blockquote>
<p>JavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。<br>其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。<br>当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。<br>ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。</p>
</blockquote>
<h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>​ 模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义：</p>
<ol>
<li>模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。</li>
<li>模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。</li>
<li>模块顶级作用域中的 this 为 undefined 。</li>
<li>模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。</li>
<li>模块必须输出可被模块外部代码使用的相关内容。</li>
<li>一个模块可以引入另外的模块。</li>
</ol>
<h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>​ 可以使用 export 关键字来对外暴露模块中的部分代码。<br>​ 一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出变量</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"Nicholas"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> magicNumber = <span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="comment">// 输出函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出类</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(length, width) &#123;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 该函数没有使用export关键字   所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 - num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义一个函数...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 * num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 可以把这个函数的引用导出。  和导出函数是一样的。</span></div><div class="line"><span class="keyword">export</span> &#123; multiply &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><blockquote>
<p>一旦有了导出内容的模块，则可以在另一个模块中使用import关键字来获取他们。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; identifier1, identifier2 &#125; <span class="keyword">from</span> <span class="string">"./a.js"</span>;</div></pre></td></tr></table></figure>
<p>​ import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）。浏览器中的 <code>&lt;script&gt;</code>元素也使用了这个路径形式，意味着它必须包含文件扩展名。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ES6简介&quot;&gt;&lt;a href=&quot;#ES6简介&quot; class=&quot;headerlink&quot; title=&quot;ES6简介&quot;&gt;&lt;/a&gt;ES6简介&lt;/h2&gt;&lt;p&gt;​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。&lt;br&gt;​由于ES6是在2015年发布的，所以也叫ES2015。&lt;br&gt;​以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="ES6" scheme="https://callmejay.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript特效三大系列总结</title>
    <link href="https://callmejay.github.io/2017/06/20/JavaScript%E7%89%B9%E6%95%88%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93/"/>
    <id>https://callmejay.github.io/2017/06/20/JavaScript特效三大系列总结/</id>
    <published>2017-06-20T11:46:53.000Z</published>
    <updated>2018-02-10T09:29:37.032Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要是讲js的DOM元素的位置关系的三大系列：offset系列，scroll系列，client系列。希望你看完之后能更加了解，熟练应用。let’s go~<br><a id="more"></a></p>
<h3 id="offset系列"><a href="#offset系列" class="headerlink" title="offset系列"></a>offset系列</h3><h4 id="offset系列的5个属性"><a href="#offset系列的5个属性" class="headerlink" title="offset系列的5个属性"></a>offset系列的5个属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> offsetLeft : 用于获取元素到最近的定位父盒子的左侧距离</div><div class="line">    * 计算方式: 当前元素的左边框的左侧到定位父盒子的左边框右侧</div><div class="line">    * 如果父级盒子没有定位, 那么会接着往上找有定位的盒子</div><div class="line">    * 如果上级元素都没有定位,那么最后距离是与body的left值</div><div class="line"></div><div class="line"><span class="number">2.</span> offsetTop : 用于获取元素到最近定位父盒子的顶部距离</div><div class="line">    * 计算方式:当前元素的上边框的上侧到定位父盒子的上边框下侧</div><div class="line">    * 如果父级盒子没有定位,那么会接着往上找有定位的盒子</div><div class="line">    * 如果上级元素都没有定位,那么最后距离是与body的top值</div><div class="line"></div><div class="line"><span class="number">3.</span> offsetWidth :用于获取元素的真实宽度(除了margin以外的宽度)</div><div class="line"></div><div class="line"><span class="number">4.</span> offsetHeight : 用于获取元素的真实高度(除了margin以外的高度)</div><div class="line"></div><div class="line"><span class="number">5.</span> offsetParent :用于获取该元素中有定位的最近父级元素</div><div class="line">    * 如果当前元素的父级元素都没有进行定位,那么offsetParent为body</div></pre></td></tr></table></figure>
<h4 id="与style-left-top-width-height-的区别"><a href="#与style-left-top-width-height-的区别" class="headerlink" title="与style.(left/top/width/height)的区别:"></a>与style.(left/top/width/height)的区别:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> offset系列的是只读属性,而通过style的方式可以读写</div><div class="line"><span class="number">2.</span> offset系列返回的数值类型(结果四舍五入),style返回的是字符串</div><div class="line"><span class="number">3.</span> offsetLeft 和 offsetTop 可以返回没有定位的元素的left值和top值,而style不可以</div></pre></td></tr></table></figure>
<h3 id="scroll系列"><a href="#scroll系列" class="headerlink" title="scroll系列"></a>scroll系列</h3><h4 id="scroll系列的4个属性"><a href="#scroll系列的4个属性" class="headerlink" title="scroll系列的4个属性"></a>scroll系列的4个属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> scrollHeight :元素中内容的实际高度(没有边框)</div><div class="line">    * 如果内容不足,就是元素的高度</div><div class="line"></div><div class="line"><span class="number">2.</span> scrollWidth: 元素中内容的实际宽度(没有边框)</div><div class="line">    * 如果内容不足,就是元素的宽度</div><div class="line"></div><div class="line"><span class="number">3.</span> scrollTop: onscroll事件发生时,元素向上卷曲出去的距离</div><div class="line"></div><div class="line"><span class="number">4.</span> scrollLeft : onscroll事件发生时,元素向左卷曲出去的距离</div></pre></td></tr></table></figure>
<h4 id="兼容问题"><a href="#兼容问题" class="headerlink" title="兼容问题"></a>兼容问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">* 未声明 DTD: 谷歌,火狐,IE9+支持</div><div class="line"></div><div class="line">  <span class="built_in">document</span>.body.scrollTop/scrollLeft</div><div class="line"></div><div class="line">* 已经声明DTD:IE8以下支持</div><div class="line"></div><div class="line"> <span class="built_in">document</span>.documentElement.scrollTop/scrollLeft </div><div class="line"></div><div class="line">* 火狐/谷歌/ie9+以上支持的</div><div class="line"></div><div class="line">  <span class="built_in">window</span>.pageYOffest/pageXOffest</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 兼容处理的代码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getScroll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">left</span>: <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="number">0</span>,</div><div class="line">        <span class="attr">top</span>: <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop || <span class="number">0</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用方法:</span></div><div class="line"><span class="number">1.</span> 取得scrollLeft值: getScroll().left</div><div class="line"><span class="number">2.</span> 取得scrollTop值: getScroll().top</div></pre></td></tr></table></figure>
<h3 id="client系列"><a href="#client系列" class="headerlink" title="client系列"></a>client系列</h3><h4 id="client系列的4个常用属性"><a href="#client系列的4个常用属性" class="headerlink" title="client系列的4个常用属性"></a>client系列的4个常用属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> clientWidth : 获取网页可视区域的宽度</div><div class="line"></div><div class="line"><span class="number">2.</span> clientHeight: 获取网页可视区域的高度</div><div class="line"></div><div class="line"><span class="number">3.</span> clientX :获取鼠标事件发生时的应用客户端区域的水平坐标</div><div class="line"></div><div class="line"><span class="number">4.</span> clientY :获取鼠标事件发生时的应用客户端区域的垂直坐标</div></pre></td></tr></table></figure>
<h4 id="兼容问题-1"><a href="#兼容问题-1" class="headerlink" title="兼容问题"></a>兼容问题</h4><h5 id="clientWidth-和-clientHeight的兼容问题"><a href="#clientWidth-和-clientHeight的兼容问题" class="headerlink" title="clientWidth 和 clientHeight的兼容问题"></a>clientWidth 和 clientHeight的兼容问题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//由浏览器对象不同导致</span></div><div class="line"></div><div class="line">* 未声明 DTD: 谷歌,火狐,IE9+支持</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.clientWidth/clientHeight</div><div class="line"></div><div class="line">* 已经声明DTD:IE8以下支持</div><div class="line"></div><div class="line"><span class="built_in">document</span>.documentElement.clientWidth/clientHeight</div><div class="line"></div><div class="line">* 火狐/谷歌/ie9+以上支持的</div><div class="line"></div><div class="line"> <span class="built_in">window</span>.innerWidth/innerHeight</div><div class="line"></div><div class="line"><span class="comment">// 兼容处理的代码</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">client</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.innerWidth)&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="string">"width"</span>:<span class="built_in">window</span>.innerWidth,</div><div class="line">            <span class="string">"height"</span>:<span class="built_in">window</span>.innerHeight</div><div class="line">        &#125;;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode === <span class="string">"CSS1Compat"</span>)&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="string">"width"</span>:<span class="built_in">document</span>.documentElement.clientWidth,</div><div class="line">            <span class="string">"height"</span>:<span class="built_in">document</span>.documentElement.clientHeight</div><div class="line">        &#125;;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="string">"width"</span>:<span class="built_in">document</span>.body.clientWidth,</div><div class="line">            <span class="string">"height"</span>:<span class="built_in">document</span>.body.clientHeight</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用方法:</span></div><div class="line"><span class="number">1.</span> 取得clientWidth的值: client().width</div><div class="line"><span class="number">2.</span> 取得clientHeight的值: client().height</div></pre></td></tr></table></figure>
<h5 id="clientX-和-clientY的兼容问题"><a href="#clientX-和-clientY的兼容问题" class="headerlink" title="clientX 和 clientY的兼容问题"></a>clientX 和 clientY的兼容问题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//由事件参数对象的兼容性问题导致</span></div><div class="line"></div><div class="line"><span class="number">1.</span> 谷歌,火狐,IE9+: 事件参数对象随着事件处理函数的参数传入</div><div class="line"><span class="number">2.</span> IE8以下: event对象必须作为<span class="built_in">window</span>对象的一个属性(<span class="built_in">window</span>.event)</div><div class="line"></div><div class="line"><span class="comment">// 兼容处理的代码</span></div><div class="line"><span class="comment">//将client和scroll的兼容问题进行对象的封装</span></div><div class="line"><span class="keyword">var</span> evtTools=&#123;</div><div class="line">    <span class="comment">//获取兼容的事件参数对象</span></div><div class="line">    getEvt:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.event?<span class="built_in">window</span>.event:e;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//获取的是可视区域的横坐标</span></div><div class="line">    getClientX:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getEvt(e).clientX;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//获取的是可视区域的纵坐标</span></div><div class="line">    getClientY:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getEvt(e).clientY;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//获取向左卷曲出去的距离的横坐标</span></div><div class="line">    getScrollLeft:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.pageXOffset||<span class="built_in">document</span>.body.scrollLeft||<span class="built_in">document</span>.documentElement.scrollLeft||<span class="number">0</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//获取向上卷曲出去的距离的纵坐标</span></div><div class="line">    getScrollTop:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.pageYOffset||<span class="built_in">document</span>.body.scrollTop||<span class="built_in">document</span>.documentElement.scrollTop||<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">网页可见区域宽： <span class="built_in">document</span>.body.clientWidth;</div><div class="line">网页可见区域高： <span class="built_in">document</span>.body.clientHeight;</div><div class="line">网页可见区域宽： <span class="built_in">document</span>.body.offsetWidth   (包括边线的宽);</div><div class="line">网页可见区域高： <span class="built_in">document</span>.body.offsetHeight  (包括边线的宽);</div><div class="line">网页正文全文宽： <span class="built_in">document</span>.body.scrollWidth;</div><div class="line">网页正文全文高： <span class="built_in">document</span>.body.scrollHeight;</div><div class="line">网页被卷去的高： <span class="built_in">document</span>.body.scrollTop;</div><div class="line">网页被卷去的左： <span class="built_in">document</span>.body.scrollLeft;</div><div class="line">网页正文部分上： <span class="built_in">window</span>.screenTop;</div><div class="line">网页正文部分左： <span class="built_in">window</span>.screenLeft;</div><div class="line">屏幕分辨率的高： <span class="built_in">window</span>.screen.height;</div><div class="line">屏幕分辨率的宽： <span class="built_in">window</span>.screen.width;</div><div class="line">屏幕可用工作区高度： <span class="built_in">window</span>.screen.availHeight;</div><div class="line">屏幕可用工作区宽度：<span class="built_in">window</span>.screen.availWidth;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要是讲js的DOM元素的位置关系的三大系列：offset系列，scroll系列，client系列。希望你看完之后能更加了解，熟练应用。let’s go~&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="DOM" scheme="https://callmejay.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>js图片懒加载及优化</title>
    <link href="https://callmejay.github.io/2017/06/18/js%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>https://callmejay.github.io/2017/06/18/js图片懒加载及优化/</id>
    <published>2017-06-18T14:20:23.000Z</published>
    <updated>2018-02-10T09:29:37.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为啥要用图片懒加载"><a href="#为啥要用图片懒加载" class="headerlink" title="为啥要用图片懒加载"></a>为啥要用图片懒加载</h2><p>对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。<br>所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求（指向默认的一张图那就只需请求一次）。可以指向loading的地址。</p>
<p>当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。</p>
<blockquote>
<p>注：图片要指定宽高。<br>关于窗口各种宽度，可以看下面两篇文章：<br><a href="http://www.cnblogs.com/kongxianghai/p/4192032.html" target="_blank" rel="external">scrollWidth,clientWidth,offsetWidth的区别</a><br><a href="http://www.cnblogs.com/fullhouse/archive/2012/01/16/2324131.html" target="_blank" rel="external">JS中关于clientWidth offsetWidth scrollWidth 等的含义</a></p>
<h2 id="图片懒加载的实现代码"><a href="#图片懒加载的实现代码" class="headerlink" title="图片懒加载的实现代码"></a>图片懒加载的实现代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">        <span class="selector-tag">img</span> &#123;</div><div class="line">            <span class="attribute">display</span>: block;</div><div class="line">            <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</div><div class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> num = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>).length;</div><div class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</div><div class="line">    <span class="keyword">let</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></div><div class="line">    lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></div><div class="line">     <span class="built_in">window</span>.onscroll = lazyload;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></div><div class="line">        <span class="keyword">let</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">//可见区域高度</span></div><div class="line">        <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; num; i++) &#123;</div><div class="line">            <span class="comment">// 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度</span></div><div class="line">            <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</div><div class="line">                <span class="keyword">if</span> (img[i].getAttribute(<span class="string">"src"</span>) == <span class="string">""</span>) &#123;</div><div class="line">                    img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</div><div class="line">                &#125;</div><div class="line">                n = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#125;)()</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</blockquote>
<h2 id="使用节流函数进行优化"><a href="#使用节流函数进行优化" class="headerlink" title="使用节流函数进行优化"></a>使用节流函数进行优化</h2><p>如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。</p>
<p>同时还有以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。<br>1.window对象的resize、scroll事件<br>2.拖拽时的mousemove事件<br>3.射击游戏中的mousedown、keydown事件<br>4.文字输入、自动完成的keyup事件<br><strong>解决这个问题的方法有去抖动和节流的方法</strong></p>
<ul>
<li>去抖动原理： 当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。<blockquote>
<p>不足:当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了</p>
</blockquote>
</li>
<li>节流原理：预设一个执行周期，如果这个周期结束了都还没触发函数，那就会执行一次函数；如果这个周期还没结束就触发了函数，那定时器将重置，开始新周期。<blockquote>
<p>达到了想要的效果，既没有频繁的执行也没有延迟执行<br><br></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="运用节流函数的图片懒加载代码"><a href="#运用节流函数的图片懒加载代码" class="headerlink" title="运用节流函数的图片懒加载代码"></a>运用节流函数的图片懒加载代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">        <span class="selector-tag">img</span> &#123;</div><div class="line">            <span class="attribute">display</span>: block;</div><div class="line">            <span class="attribute">margin-bottom</span>: <span class="number">50px</span>;</div><div class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> num = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>).length;</div><div class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</div><div class="line">    <span class="keyword">let</span> n = <span class="number">0</span>; <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></div><div class="line">    lazyload(); <span class="comment">//页面载入完毕加载可是区域内的图片</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123; <span class="comment">//监听页面滚动事件</span></div><div class="line">        <span class="keyword">let</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">//可见区域高度</span></div><div class="line">        <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop; <span class="comment">//滚动条距离顶部高度</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; num; i++) &#123;</div><div class="line">            <span class="comment">// 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度</span></div><div class="line">            <span class="keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;</div><div class="line">                <span class="keyword">if</span> (img[i].getAttribute(<span class="string">"src"</span>) == <span class="string">""</span>) &#123;</div><div class="line">                    img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</div><div class="line">                &#125;</div><div class="line">                n = i + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">// 采用了节流函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, delay, time</span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> timeout,</div><div class="line">        startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">let</span> context = <span class="keyword">this</span>,</div><div class="line">            args = <span class="built_in">arguments</span>,</div><div class="line">            curTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">            clearTimeout(timeout);</div><div class="line">            <span class="comment">// 如果达到了规定的触发时间间隔，触发 handler</span></div><div class="line">            <span class="keyword">if</span> (curTime - startTime &gt;= time) &#123;</div><div class="line">                fun.apply(context, args);</div><div class="line">                startTime = curTime;</div><div class="line">                <span class="comment">// 没达到触发间隔，重新设定定时器</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                timeout = setTimeout(fun, delay);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,throttle(lazyload,<span class="number">500</span>,<span class="number">1000</span>));</div><div class="line">&#125;)()</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为啥要用图片懒加载&quot;&gt;&lt;a href=&quot;#为啥要用图片懒加载&quot; class=&quot;headerlink&quot; title=&quot;为啥要用图片懒加载&quot;&gt;&lt;/a&gt;为啥要用图片懒加载&lt;/h2&gt;&lt;p&gt;对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。&lt;br&gt;所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://callmejay.github.io/categories/JavaScript/"/>
    
    
      <category term="image-lazyload" scheme="https://callmejay.github.io/tags/image-lazyload/"/>
    
  </entry>
  
  <entry>
    <title>疯狂HCJ讲义（一）</title>
    <link href="https://callmejay.github.io/2017/06/15/%E7%96%AF%E7%8B%82HCJ%E8%AE%B2%E4%B9%89%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://callmejay.github.io/2017/06/15/疯狂HCJ讲义（一）/</id>
    <published>2017-06-15T14:04:22.000Z</published>
    <updated>2018-02-10T09:29:37.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML5的常用元素与属性"><a href="#HTML5的常用元素与属性" class="headerlink" title="HTML5的常用元素与属性"></a>HTML5的常用元素与属性</h2><h3 id="HTML5新增通用属性"><a href="#HTML5新增通用属性" class="headerlink" title="HTML5新增通用属性"></a>HTML5新增通用属性</h3><h4 id="contentEditable属性"><a href="#contentEditable属性" class="headerlink" title="contentEditable属性"></a>contentEditable属性</h4><p>HTML5为大部分元素都增加了contentEditable属性,如果将该属性设置为true，浏览器会允许开发者直接在页面编辑该元素。<br>contentEditable属性具有可继承的特点，如果一个HTML元素的父元素是“可编辑”状态，那么它也是默认可编辑的。<br><a id="more"></a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contentEditable</span>=<span class="string">"true"</span> </span></div><div class="line"><span class="attr">style</span>=<span class="string">"width:500px;height:300px;border:1px solid #000"</span>&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ondbclick</span>=<span class="string">"this.contentEditable=true"</span>&gt;</span>双击编辑内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="designMode属性"><a href="#designMode属性" class="headerlink" title="designMode属性"></a>designMode属性</h4><p>designMode属性相当于全局的contentEditable属性，如果把整个页面的designMode属性设置为on时，该页面所有支持contentEditable属性的元素都变成可编辑状态。<br>在JavaScript代码中只能修改整个HTML页面的designMode属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.designMode = <span class="string">"on"</span>;</div></pre></td></tr></table></figure></p>
<h4 id="hidden属性"><a href="#hidden属性" class="headerlink" title="hidden属性"></a>hidden属性</h4><p>HTML5所有元素提供了hidden属性，这个hidden属性支持true,false属性，如果把某一元素的hidden设置成true，就意味着浏览器不显示该组件，也不会保留该组件所占用的空间。<br><em>提示：hidden属性可以代替CSS样式的display=none。</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span> <span class="attr">hidden</span>=<span class="string">"true"</span>&gt;</span>这是文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> </span></div><div class="line"><span class="attr">onclick</span>=<span class="string">"var target=document.getElementById('target');</span></div><div class="line">target.hidden=!target.hidden;"&gt;显示隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="spellcheck属性"><a href="#spellcheck属性" class="headerlink" title="spellcheck属性"></a>spellcheck属性</h4><p>HTML为input,textarea等元素增加了spellcheck属性，支持true,false属性，如果设置spellcheck=”true”,浏览器会负责对用户输入的文本内容执行输入检查，如果检查不通过，浏览器会对拼错的单词进行提示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span> <span class="attr">rows</span>=<span class="string">"3"</span> <span class="attr">cols</span>=<span class="string">"40"</span> &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>注：目前支持spellcheck属性的浏览器有chrome,Safari,Opera.Internet Explorer和Firefox暂不支持。</p>
<h3 id="HTML5新增常用元素"><a href="#HTML5新增常用元素" class="headerlink" title="HTML5新增常用元素"></a>HTML5新增常用元素</h3><p><code>&lt;article&gt;</code>侧重于表达一篇独立的，完整的文章；<br><code>&lt;section&gt;</code>侧重于对页面内容进行分块；<br><code>&lt;nav&gt;</code>专门用于定义页面上的导航栏<br><code>&lt;aside&gt;</code>主要用来渲染成侧边栏<br><code>&lt;footer&gt;</code>主要用于为<article...>元素定义‘脚注’部分，包括该文章的版权信息，作者的授权信息等。<br><code>&lt;figure&gt;</code>用于表示一块独立的图片区域，可包含多个<img>元素所代表的图片，还可包含一个<code>&lt;figcaption&gt;</code>作为定义图片区域的标题。</article...></p>
<h3 id="HTML5头部和元信息"><a href="#HTML5头部和元信息" class="headerlink" title="HTML5头部和元信息"></a>HTML5头部和元信息</h3><p><code>&lt;base/&gt;</code>必须是空元素，可以使用id作为其唯一标识，还有以下两个属性：<br><code>href</code>：指定所有链接的基准链接<br><code>target</code>：指定超链接默认在哪个窗口打开链接，属性值只能是_blank,_self,_parent,_top。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.php"</span>&gt;</span>啦啦啦啦<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>&lt;meta/&gt;</code>用于定义页面元信息，也就是一些name-content对，该元素除了可以指定id属性外，还有以下三个属性：<br><code>http-equiv</code>: 指定元信息的名称，该属性指定的名称具有特殊意义，它可以向浏览器传回一些有用的信息，帮助浏览器正确的处理网页内容。它支持的几个值有以下：<br><em>Refresh</em>: 指浏览器多长时间自动刷新页面，如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--设置2秒后自动刷新指定网站--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Refresh"</span> <span class="attr">content</span>=<span class="string">"2,URL=http://www.baidu.com"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p><em>Expires</em>: 指定网页的过期时间，一旦网页过期，必须重新从服务器下载，如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"Sat Sep 27 16:12:33 CST 2008"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>name</code>: 指定元信息的名称，该名称可以随意指定<br><code>content</code>: 指定元信息值</p>
<h2 id="HTML5表单相关元素和属性"><a href="#HTML5表单相关元素和属性" class="headerlink" title="HTML5表单相关元素和属性"></a>HTML5表单相关元素和属性</h2><h3 id="HTML原有的表单及表单控件"><a href="#HTML原有的表单及表单控件" class="headerlink" title="HTML原有的表单及表单控件"></a>HTML原有的表单及表单控件</h3><h4 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h4><p><code>&lt;form.../&gt;</code>元素用于生成输入表单，该元素不会生成可视化部分，在HTML5以前表单控件都必须放在<code>&lt;form.../&gt;</code>之内。其特有属性有：<br><em>action</em>:指定当点击确定提交表单时，该表单被提交到那个地址。<br><em>method</em>:指定提交表单时的请求类型。可以是get/post,默认是get.<br><em>target</em>: 指定使用哪种方式打开目标URL.<br><em>name</em>: 指定表单的唯一名称，建议和id属性值保持一致。<br><em>enctype</em>: 指定对表单内容进行编码所使用的字符集。有三个值:<br>application/x-www-form-urlencoded:默认的编码方式。只处理表单控件的value值，采用这种编码方式的表单会将value值处理成URL编码方式。<br>multipart/for-data:这种编码方式会以二进制流的形式处理表单数据，用于上传文件<br>text/plain:主要适用于直接通过表单发送邮件的方式</p>
<h4 id="使用input元素"><a href="#使用input元素" class="headerlink" title="使用input元素"></a>使用input元素</h4><p>1.单行文本框：指定<code>&lt;input.../&gt;</code>type属性为text<br>2.密码输入框：指定<code>&lt;input.../&gt;</code>type属性为password<br>3.隐藏域：指定<code>&lt;input.../&gt;</code>type属性为hidden<br>4.单选框：指定<code>&lt;input.../&gt;</code>type属性为radio<br>5.复选框：指定<code>&lt;input.../&gt;</code>type属性为checkbox<br>6.图像域：指定<code>&lt;input.../&gt;</code>type属性为image,可以指定width和height属性<br>7.文本上传域：指定<code>&lt;input.../&gt;</code>type属性为file</p>
<blockquote>
<p>input元素有以下属性：<br>checked:设置单选框和复选框初始状态是否处于选中状态，<br>disabled:设置首次加载时禁用此元素。该元素无法获得输入，无法选中及响应状态。<br>maxlength: 该属性值是一个数字，指定文本框中允许输入的最大字符数。<br>readonly: 指定文本框内的值不允许用户修改<br>src: 指定图像域所显示的图像URL.只有type=image时可指定该属性</p>
</blockquote>
<h3 id="HTML5新增的属性和元素"><a href="#HTML5新增的属性和元素" class="headerlink" title="HTML5新增的属性和元素"></a>HTML5新增的属性和元素</h3><h4 id="HTML5为表单控件新增的属性"><a href="#HTML5为表单控件新增的属性" class="headerlink" title="HTML5为表单控件新增的属性"></a>HTML5为表单控件新增的属性</h4><blockquote>
<p><code>form</code>属性：用于定义该表单控件所属的表单，该属性值应该是它所属表单的id。通过为表单控件添加指定的form属性，可以让表单控件定义在<code>&lt;form.../&gt;</code>外，从而提高灵活性。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"addForm"</span> <span class="attr">action</span>=<span class="string">"add"</span>&gt;</span></div><div class="line">        物品名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"添加"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">    物品描述：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"desc"</span> <span class="attr">form</span>=<span class="string">"addForm"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当提交该表单时，该多行文本域也会生成对应的请求参数。</p>
<blockquote>
<p>formaction属性<br>当页面中的一个表单，包含两个以上的提交按钮，但是程序需要提交到不同的action，这是可以为不同的提交按钮指定对应的formaction,可以动态的让表单提交到不同的URL,省去用js来实现。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span> <span class="attr">formaction</span>=<span class="string">"regist"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span> <span class="attr">formaction</span>=<span class="string">"login"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>autofocus属性<br>当为某个表单控件添加该属性后，浏览器打开该页面时该组件会自动获得焦点。整个页面最多只能有一个表单控件可以获得该属性。<br></p>
<p>list属性<br>相当于文本框和下拉菜单组合的组件，既允许用户输入，也允许用户通过下拉菜单进行选择。list属性的值应该是一个<code>&lt;datalist.../&gt;</code>组建的id。意思是list属性必须和<code>&lt;datalist.../&gt;</code>元素一起使用。<br><code>&lt;datalist.../&gt;</code>元素相当于一个看不见得<code>&lt;select.../&gt;</code>元素，用于生成一个隐藏的下拉菜单。当双击指定了list属性的文本框时，该文本框会显示<code>&lt;datalist.../&gt;</code>生成的下拉菜单。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    请输入图书：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">list</span>=<span class="string">"books"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"购买"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"books"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"java"</span>&gt;</span>疯狂java讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Android"</span>&gt;</span>疯狂Android讲义<span class="tag">&lt;/<span class="name">option</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注：目前只有Firefox ,Opera最新版支持该属性。</p>
<h4 id="功能丰富的input元素"><a href="#功能丰富的input元素" class="headerlink" title="功能丰富的input元素"></a>功能丰富的input元素</h4><p>HTML5为<code>&lt;input.../&gt;</code>元素的tyoe属性新增了如下几种类型<br><code>color</code>： 让<code>&lt;input.../&gt;</code>元素生成一个元素选择器。<br><code>date</code>：让<code>&lt;input.../&gt;</code>元素生成一个日期选择器。<br><code>time</code>：让<code>&lt;input.../&gt;</code>元素生成一个时间选择器。<br><code>datetime</code>：让<code>&lt;input.../&gt;</code>元素生成一个UTC日期，时间选择器。<br><code>week</code>：让<code>&lt;input.../&gt;</code>元素生成一个用户选择第几周的文本框。<br><code>month</code>：让<code>&lt;input.../&gt;</code>元素生成一个月份选择器。<br><code>email</code>：让<code>&lt;input.../&gt;</code>元素生成一个元素选择器,可指定multiple属性<br><code>tel</code>：让<code>&lt;input.../&gt;</code>元素生成一个只允许输入手机号文本框。<br><code>number</code>：让<code>&lt;input.../&gt;</code>元素生成一个只能输入数字的文本框。<br><code>range</code>：让<code>&lt;input.../&gt;</code>元素生成一个拖动条。可指定min,max,step属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML5的常用元素与属性&quot;&gt;&lt;a href=&quot;#HTML5的常用元素与属性&quot; class=&quot;headerlink&quot; title=&quot;HTML5的常用元素与属性&quot;&gt;&lt;/a&gt;HTML5的常用元素与属性&lt;/h2&gt;&lt;h3 id=&quot;HTML5新增通用属性&quot;&gt;&lt;a href=&quot;#HTML5新增通用属性&quot; class=&quot;headerlink&quot; title=&quot;HTML5新增通用属性&quot;&gt;&lt;/a&gt;HTML5新增通用属性&lt;/h3&gt;&lt;h4 id=&quot;contentEditable属性&quot;&gt;&lt;a href=&quot;#contentEditable属性&quot; class=&quot;headerlink&quot; title=&quot;contentEditable属性&quot;&gt;&lt;/a&gt;contentEditable属性&lt;/h4&gt;&lt;p&gt;HTML5为大部分元素都增加了contentEditable属性,如果将该属性设置为true，浏览器会允许开发者直接在页面编辑该元素。&lt;br&gt;contentEditable属性具有可继承的特点，如果一个HTML元素的父元素是“可编辑”状态，那么它也是默认可编辑的。&lt;br&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://callmejay.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://callmejay.github.io/tags/HTML/"/>
    
  </entry>
  
</feed>
