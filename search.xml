<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试知识总结（1)]]></title>
    <url>%2F2018%2F10%2F30%2F%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93(1)%2F</url>
    <content type="text"><![CDATA[new 语法糖的实现1, 创建一个新的对象2, 链接到原型3, 绑定this4, 返回新的对象 123456789101112function create()&#123; // 创建一个新的对象 var obj = new Object(); // 获得构造函数 var fn = [].shift.call(arguments); // 链接到原型 obj.__proto__ = fn.prototype; // 绑定this 执行构造函数 var result = fn.apply(obj,arguments); // 确保返回的是对象 return typeof(result) === 'object' ? result : obj;&#125; 模拟实现Call 和 apply可以从以下几点来考虑如何实现 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ 1234567891011121314Function.prototype.myCall = function(context)&#123; var context = context || window; // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') =&gt; a.fn = getValue context.fn = this; // this就是调用call的函数 // 将 context 后面的参数取出来 var args = [...arguments].slice(1); // getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24') var result = context.fn(...args); // 删除fn delete context.fn; return result;&#125; 以上就是 call 的思路，apply 的实现也类似 1234567891011121314Function.prototype.myApply = function(context)&#123; var context = context || window context.fn = this // 判断是否存在第二个参数 且为数组 if(arguments[1] &amp;&amp; Array.isArray(arguments[1]))&#123; var result = context.fn(...arguments[1]); &#125;else &#123; var result = context.fn(); &#125; delete context.fn; return result;&#125; bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; Vue双向绑定的简单实现（数据劫持和发布订阅）Vue内部实现实用了Object.defineProperty()和发布订阅模式来实现双向数据绑定。 123456789101112131415161718192021222324252627282930313233343536function observe(data)&#123; // 判断是不是对象 if(!obj || typeof data !== 'object')&#123; return; &#125; // 遍历对象， for(key in data)&#123; defineReactive(data,key,obj[key]); &#125;&#125;function defineReactive(data,key,value)&#123; // 递归子属性值 observe(value); Object.defineProperty(data,key,&#123; enumerable: true, configurable: true, get: function reactiveGetter()&#123; return value; &#125;, set:function reactiveSetter(newVal)&#123; value = newVal; &#125; &#125;)&#125;var data = &#123;name: 'Jay'&#125;;observe(data);data.name = 'John'; // set valuedata.name; // get value 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅。 1&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析compile如上模板代码时，遇上 就会给属性 name 添加发布订阅。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 通过 Dep 解耦class Dep()&#123; constructor()&#123; this.subs = []; &#125; // 订阅 addSub( sub )&#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; // 发布 notify()&#123; this.subs.forEach( sub =&gt; &#123; sub.update(); &#125;) &#125;&#125;// 全局属性，通过该属性配置 Watcher 是watcher和dep关联的唯一桥梁，任何时候，都必须保证Dep.target只有一个值。Dep.target = null;function update()&#123; document.querySelector('div').innerText = value&#125;class Watcher()&#123; constructor(obj,key,cb)&#123; // 将 Dep.target 指向自己 Dep.target = this; this.cb = cb; this.obj = obj; this.key = key; this.value = obj[key]; // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 保证只有一个 Dep.target = null; &#125; update()&#123; // 获得新值 // this.value = this.obj[this.key]; ？？ 上面已经获取 这里应该不用二次获取了 // 调用 update 更新Dom this.cb(this.value); &#125;&#125;var data = &#123; name: 'yck' &#125;;observe(data);// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, 'name', update);// update Dom innerTextdata.name = 'yyy'; 接下来对 defineReactive改造 12345678910111213141516171819202122232425262728function defineReactive(data,key,value)&#123; observe(value); var dp = new Dep(); Object.defineProperty(data,key,&#123; enumerable: true, configurable: true, get: function reactiveGetter()&#123; console.log('get value') // 将 Watcher 添加到订阅 if(Dep.target)&#123; dp.addSub(Dep.target); &#125; return value; &#125;, set: function reactiveSetter(newVal)&#123; console.log('set value') value = newVal; // 执行 watcher 的 update 方法 dp.notify(); &#125; &#125;)&#125; 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写更优雅的JavaScript代码]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%BC%96%E5%86%99%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[代码技巧优先 ES6 新特性写法1234567891011121314151617181920212223242526272829303132333435// 箭头函数function foo()&#123; console.log('hello world')&#125;const foo = () =&gt; console.log('hello world')// 数组去重const formatArray = arr =&gt; [...new Set(arr)]// 数组合并const newArr = [...arr1, ...arr2, 'value']// 对象浅拷贝const newObj = &#123;...obj&#125;// 解构赋值const person = &#123;name: 'bao', age: 18&#125;const &#123; name, age &#125; = person// 常见对象属性取值前判断对象是否存在// 如下是 react + antd 渲染 table 的简单代码，对象存在性判断 + 默认值设置render()&#123; const &#123; downloadList &#125; = this.props.store.downloadList let items = downloadList &amp;&amp; downloadList.items || [] let itemCount = downloadList &amp;&amp; downloadList.itemCount || 10 return &lt;Table dataSource=&#123;items&#125; pagination=&#123;&#123;total: itemCount&#125;&#125; /&gt;&#125;// 优化后render()&#123; const &#123; items, itemCount &#125; = this.props.manageStore.downloadList || &#123;&#125; return &lt;Table dataSource=&#123;items || []&#125; pagination=&#123;&#123;total: itemCount || 10&#125;&#125;/&gt;&#125; 优化逻辑判断语句大量的 if else 逻辑判断难以维护，且性能较差，可用多种方式代替 123456789101112131415161718192021222324252627// 对象配置法// 函数内部有条件判断，且 return 值时，满足条件立即return，而不要在结尾returnconst foo = v =&gt; &#123; if (v === 'name') &#123; return 'bao' &#125; else if (v === 'age') &#123; return '18' &#125; else if (v === 'height') &#123; return '180' &#125;&#125;const cfg = &#123; name: 'bao', age: '18', height: '180'&#125;const foo = v =&gt; cfg[v]// 数组配置法if (value === 'hello' || value === 'world' || value === 'blabla') &#123; // ...&#125;// 配置数组形式const rightValue = ['hello', 'world', 'blabla']if (rightValue.includes[value]) &#123; // ...&#125; 善用 &amp;&amp; 、 || 和 三元运算12345678910111213if (name === 'bao') &#123; someFunc()&#125;name === 'bao' &amp;&amp; someFunc()if (name === 'bao') &#123; someFunc()&#125; else &#123; elseFunc()&#125;name === 'bao' ? someFunc() : elseFunc() 对象属性变量应用如在 react 中，调用 action 方法来获取数据，不同条件执行不同方法 12345678if (isMember) &#123; let res = await actions.getMemberInfo(params)&#125; else &#123; let res = await actions.getCommonUserInfo(params)&#125;const actionName = isMember ? 'getMemberInfo' : 'getCommonUserInfo'let res = await actions[actionName](params) 用 Array.map(), Array.filter() 代替数组 for 循环实现简易写法12345678910111213141516171819202122let arr = [1, 2, 3, 4, 'A', 'B']// 1. 取出 arr 中数字项为新数组let numArr = []for(let i in arr)&#123; if(typeof arr[i] === 'number')&#123; numArr.push(arr[i]) &#125;&#125;// 改用filterlet numArr2 = arr.filter(item =&gt; typeof item === 'number')console.log(numArr2) // [1,2,3,4]// 2. 获得新数组，元素是 arr 每个元素作为 value, key 为 arr 下标的对象, 不修改 arrlet strArr = []for(let i in arr)&#123; strArr.push(&#123;[i]: arr[i]&#125;)&#125;// 改用 maplet strArr2 = arr.map((item, i) =&gt; (&#123;[i]: arr[i]&#125;))console.log(strArr2) // [ &#123; '0': 1 &#125;,&#123; '1': 2 &#125;,&#123; '2': 3 &#125;, &#123; '3': 4 &#125;, &#123; '4': 'A' &#125;, &#123; '5': 'B' &#125; ] 浅拷贝、深拷贝 复杂数据类型对象深拷贝建议使用库来实现，如 lodash.cloneDeep12345678910111213// 浅拷贝let obj1 = &#123; a: 11, b: &#123; ba: 22 &#125; &#125;let obj2 = &#123;...obj1&#125;console.log(obj2); // ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​console.log(obj1 === obj2); // falseconsole.log(obj2.b === obj1.b); // true// 深拷贝，这种方法需要对象能够被 json 序列化let obj3 = JSON.parse(JSON.stringify(obj1))console.log(obj3); // ​​​​​&#123; a: 11, b: &#123; ba: 22 &#125; &#125;​​​​​console.log(obj3===obj1); // falseconsole.log(obj3.b===obj1.b); // true 更高效的代码使用局部变量代替引用类型查找局部变量的读取速度最快，而引用类型的数据读取需要按引用指针去查找，所以可以对多次使用的引用类型属性 使用局部变量读取一次，重复使用 123456789101112let obj = &#123; person: &#123; man: &#123; bao: &#123; age: 18 &#125; &#125; &#125;&#125;let age = obj.person.man.bao.age// use age do many things 删除多个对象属性时先使属性为 null删除属性时，js 引擎会去查找该属性的值是否是其他对象的引用，所以删除前提前赋值为 null，可以减少 js 引擎的检测过程，提高效率 1234567891011let obj = &#123; person: &#123; man: &#123; bao: &#123; age: 18 &#125; &#125; &#125;&#125;obj.person = nulldelete obj.person]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3之animation]]></title>
    <url>%2F2018%2F08%2F17%2FCSS3%E4%B9%8Banimation%2F</url>
    <content type="text"><![CDATA[首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。 123div:hover &#123; animation: 1s 1s rainbow linear 3 forwards normal;&#125; 用keyframes关键字，定义rainbow效果。 12345@keyframes rainbow &#123; 0% &#123; background: #c00; &#125; 50% &#123; background: orange; &#125; 100% &#123; background: yellowgreen; &#125;&#125; 上面的animation属性是简写，可以拆分成多个单独的属性 123456789div:hover &#123; animation-name: rainbow; // 效果名称 animation-duration: 1s; // 执行一次所需是时间 animation-timing-function: linear; // 动画的速度曲线, linear是匀速，还有ease, ease-in加速,ease-out减速，cubic-bezier(http://cubic-bezier.com) 自定义速度模式等 animation-delay: 1s; // 延时多久执行动画 animation-fill-mode:forwards; // 动画保持在结束状态, forwards是停在结束时，backwards 是停在开始时，none 回到动画没开始状态 animation-direction: normal; // 动画播放的方向, 有alternate（start-end -&gt; end-start -&gt; start-end）、reverse(end-start -&gt; end-start) animation-iteration-count: 3; // 动画执行次数 还有infinite&#125; 12345678div &#123; animation: rainbow 1s linear infinite; animation-play-state: paused; // 没有鼠标没有悬停时，动画状态是暂停；&#125;div:hover &#123; animation-play-state: running; // 一旦悬停，动画状态改为继续播放。&#125; 举个栗子：实现动画的播放，暂停和重新开始 html部分 1234567&lt;div id="box" class="box"&gt;&lt;/div&gt;&lt;p id="text"&gt;&lt;/p&gt;&lt;div class="control"&gt; &lt;button id="play" value="播放"&gt;播放&lt;/button&gt; &lt;button id="pause" value="暂停"&gt;暂停&lt;/button&gt; &lt;button id="restart" value="重新开始"&gt;重新开始&lt;/button&gt;&lt;/div&gt; css部分 12345678910111213141516171819202122232425262728293031323334353637@keyframes mymove &#123; 0% &#123; margin-left: 0px; &#125; 50% &#123; margin-left: 400px; &#125; 100% &#123; margin-left: 0px; &#125;&#125;@keyframes mymove1 &#123; 0% &#123; margin-left: 0px; &#125; 50% &#123; margin-left: 400px; &#125; 100% &#123; margin-left: 0px; &#125;&#125;.box &#123; margin: 50px 0; width: 100px; height: 100px; background-color: #5578a2;&#125;.play &#123; animation: mymove 5s infinite ease;&#125;.restart &#123; animation: mymove1 5s infinite ease;&#125;.pause &#123; animation-play-state: paused;&#125; js部分 1234567891011121314151617181920212223242526272829303132var play = document.getElementById('play'), pause = document.getElementById('pause'), restart = document.getElementById('restart'), text = document.getElementById('text'), box = document.getElementById('box');// 暂停pause.addEventListener('click', function() &#123; if (box.classList.contains('play')) &#123; box.className = 'pause play box'; &#125; else &#123; box.className = 'pause restart box'; &#125; text.innerHTML = this.value;&#125;);// 播放play.addEventListener('click', function() &#123; if (box.classList.contains('play')) &#123; box.className = 'play box'; &#125; else &#123; box.className = 'restart box'; &#125; text.innerHTML = this.value;&#125;);// 重新开始restart.addEventListener('click', function() &#123; if (box.classList.contains('play')) &#123; box.className = 'restart box'; &#125; else &#123; box.className = 'play box'; &#125; text.innerHTML = this.value;&#125;); 参考资料CSS3 animation 属性妙用]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（强制类型转换）]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这里先插入下几个重要的点，先看先知：1.转Boolean 1在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。 2.对象转基本类型对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。 3.四则运算符只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 1234561 + '1' // '11'2 * '2' // 4[1, 2] + [2, 1] // '1,22,1'// [1, 2].toString() -&gt; '1,2'// [2, 1].toString() -&gt; '2,1'// '1,2' + '2,1' = '1,22,1' 值类型转换将值从一种类型转换成另一种类型称为类型转换（type casting）,这是显式的情况；隐式的转换称为强制类型转换（coercion）。 区分: 类型转换发生在静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时（runtime）。 1234var a = 12;var b = a + ''; // 隐式转换var c = String(a); // 显示转换]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记（原生函数）]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原生函数（native function）,也是JavaScript的内建函数（built-in function）.常见的原生函数有： String() Number() Boolean() Array() Object() Function() RegExp() Date() Error() Symbol() 原生函数可以被当做构造函数来使用，但是构造出来的对象和我们设想的不太一样 1234567var a = new String('123');typeof a; // 'object' 不是 ‘string’a instanceof String // trueObject.Prototype.toString.call(a) // '[object String]' 通过构造函数(如 new String(&#39;abc&#39;))创造出来的是封装了基本类型值（如‘abc’）的封装对象。 可以通过console.log(a)来查看封装对象。 需要注意的是，new String(&#39;abc&#39;)创造出来的是字符串’abc’的封装对象，而不是基本类型值’abc’。 内部属性[[class]]所有typeof返回值为“object”的对象都包含一个内部属性[[class]],这个属性无法访问，只能通过Object.prototype.toString()来查看。 1Object.prototype.toSting([1,2,3]) // [object Array] 数组的内部[[class]]属性值是“Array”。对象的内部[[class]]属性和创建该对象的内建函数相对应。但是 12Object.prototype.toString(null) // '[object Null]'Object.prototype.toString(undefined) // '[object Undefined]' 虽然是’null’和’undefined’这样的原生函数并不存在，但是内部[[class]]的属性值仍然是‘Null’和‘Undefined’ 其他的基本类型值（如字符串，布尔，数字）的情况有所不同，通常称为‘包装’（boxing）; 123Object.prototype.toString('123') // [object String]Object.prototype.toString(123) // [object Number]Object.prototype.toString(false) // [object Boolean] 上面的基本类型值被各自的封装对象包装，所以他们的内部[[class]]属性值“String”,“Number”,“Boolean”。 封装对象包装封装对象（object wrapper）扮演者重要的角色。我们都知道基本类型没有.length和.toString()这样的属性和方法，那他们是如何做到的呢？没错！就是通过封装对象访问的。此时JavaScript会自动为 基本类型值 包装（box或者wrap）一个封装对象。 1234var a = 'abc';a.length // 3a.toUpperCase() // ABC 这时候我们会想：如果我们要经常使用属性和方法。为甚不一开始就创建封装对象，这样JavaScript引擎就不用每次都自动创建了。But~~实际上 浏览器已经做了性能优化，直接使用封装对象反而会降低执行效率。所以我们不需要直接使用封装对象，让JS引擎自己去决定什么时候使用封装对象。 封装对象释疑比如Boolean 12345var a = new Boolean(false);if(!a)&#123; console.log('Oops'); // 实际上不会执行到这里&#125; 我们为false创建了一个封装对象，然而该对象总是返回真值（truthy）。 ✔️如果想要自行封装基本类型值，可以使用Object(..)函数（不带new关键字） 12345678910111213var a = 'abc';var b = new String(a);var c = Object(a);typeof a // stringtypeof b // objecttypeof c // objectb instanceof String; // truec instanceof String; // trueObject.prototype.toString.call(b); // [object String]Object.prototype.toString.call(c); // [object String] 再次强调，我们一般不推荐使用封装对象。 拆封✔️如果想得到封装对象中的基本类型值，可以使用valueOf()函数： 1234567var a = new String('abc');var b = new Number(22);var c = new Boolean(false);a.valueOf();// 'abc'b.valueOf();// 22c.valueOf(); // true 在需要用到封装对象中的基本类型值得地方会发生隐式拆封。 12345var a = new String('abc');var b = a + '';typeof a;// 'object'typeof b; // 'string' 原生函数作为构造函数关于数组（array），对象（object），函数（function）和正则表达式，实际上，使用常量和使用构造函数效果是一样的。（创建的值都是通过封装对象来包装）。 Array(..)123456// 构造函数Array(..)不要求必须带 new 关键字，不带时，它会被自动补上var a = new Array(1,2,3);a; // [1,2,3]var b = [1,2,3];b; // [1,2,3] Array构造函数只带一个参数时，会被作为数组的预设长度(length),创造出来的只是一个空数组。 我们将包含至少一个“空单元”的数组称为“稀疏数组”. Date(..)和Error(..)创建日期对象必须使用 new Date()。 Date(..)主要是用来获取当前的Unix时间戳（从1970年1月1日开始计算。以秒为单位）。 构造函数Error(..)带不带new关键字都可以。创建错误对象（error object）主要是为了获得当前运行栈的上下文。栈的上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。 错误对象通常与throw一起使用。 12345function fn(x)&#123; if(x)&#123; throw new Error('x was not be provided'); &#125;&#125; 错误对象至少包含一个message属性。最好的办法是调用toSting()来获得经过格式化的便于阅读的错误信息。 Symbol()ES6中新加入了一个基本数据类型–符号（Symbol）。符号是具有唯一性的特殊值（并非绝对）。用它来命名对象属性不容易导致重名。 符号可以用作属性名，但是无论是在代码还是控制台上都无法查看和访问它的值，只会显示为诸如Symbol(Symbol.create)这样的值。 ES6中有一些预定义符号，以Symbol的静态属性形式出现， 如Symbol.create,Symbol.iterator等。可以这样用： 1obj[Symbol.iterator] = function()&#123;/*..*/&#125; ✔️我们可以使用Symbol(..)原生构造函数来自定义符号。但它比较特殊，不能带new关键字，否则会报错： 123456789var mysym = Symbol('my own symbol');mysym; // Symbol(my own symbol)mysym.toString(); // "Symbol(my own symbol)"typeof mysym; // 'symbol'var a = &#123;&#125;;a[mysym] = 'abc';Object.getOwmPropertySymbols(a); // [Symbol(my own symbol)] 虽然符号实际上并非私有属性（通过Object.getOwmPropertySymbols(..)便可以公开获得对象中的所有符号），但是它却主要用于私有或者特殊属性。很多人稀罕用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖节流]]></title>
    <url>%2F2018%2F07%2F20%2F%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。因为防抖动的轮子很多，这里也不重新自己造个轮子了，直接使用大神分析的 underscore 的源码来解释防抖动。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */function debounce(func, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) result = func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timeout); timeout = null; &#125;; return debounced;&#125; 上面代码使用例子： 1234567891011121314var count = 1;var container = document.getElementById('container');function getUserAction(e) &#123; container.innerHTML = count++;&#125;;var setUseAction = debounce(getUserAction, 10000, true);container.onmousemove = setUseAction;document.getElementById("button").addEventListener('click', function()&#123; setUseAction.cancel();&#125;) debounced解析 节流节流的原理很简单： 如果你持续触发事件，每隔一段时间，只执行一次事件。 根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。 使用时间戳123456789101112131415function throttle(func,wait)&#123; var time = 0, context, args; return function()&#123; context = this; args = arguments; var now = +new Date(); // 执行条件 if(now - time &gt; wait)&#123; func.apply(context,args); time = now; &#125; &#125;&#125; 使用定时器123456789101112131415function throttle(func, wait)&#123; var timer, context, args; return function()&#123; context = this; args = argumens; if(!timer) &#123; timer = setTimeout(function()&#123; func.apply(context,args); timer = null; &#125;,wait) &#125; &#125;&#125; 比较两个方法： 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 有人就说了：我想要一个有头有尾的！就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！ 合并123456789101112131415161718192021222324252627282930function throttle(func, wait) &#123; var timeout, context, args, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; func.apply(context, args) &#125;; var throttled = function() &#123; var now = +new Date(); //下次触发 func 剩余的时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果没有剩余的时间了或者你改了系统时间 if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; 但是我有时也希望无头有尾，或者有头无尾，这个咋办？ 那我们设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定: leading：false 表示禁用第一次执行trailing: false 表示禁用停止触发的回调 1234567891011121314151617181920212223242526272829303132function throttle(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : new Date().getTime(); timeout = null; func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; &#125;; return throttled;&#125; throttle解析]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript立即执行函数(IIFE)与闭包]]></title>
    <url>%2F2018%2F06%2F22%2FJavaScript%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-IIFE-%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言一直没搞清楚立即执行函数和闭包之间的关系，总结一下： 闭包有很多种理解：访问不到内部作用域，函数就是这样，所以函数就是闭包； 闭包还有一种理解：通过把函数内部的变量和方法返回出来，这样外部作用域就可以访问内部作用域了，并且 立即执行函数和闭包之间没有必然的联系，虽然它们经常结合一起使用； 立即执行函数只是一种函数的调用方式； 闭包的目的则是外部函数可以访问内部函数的作用域； 立即执行函数（IIFE）立即执行函数、立即执行表达式、IIFE（immediately invoked function expression）、自执行函数，叫法不同，都是一样的； 立即执行函数是指声明完之后便直接执行的函数，这类函数通常是一次性使用的，因此没必要给这类函数命名，直接让它执行就好了； 主要目的是做的一些封装，防止变量全局污染，以及保证内部变量的安全； javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用IIFE可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。 JQuery使用的就是这种方法，将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中，在全局作用域中调用JQuery代码时，可以达到保护JQuery内部变量的作用。 定义一个函数，函数后面加上括号，即可完成调用； 123456&lt;script type="text/javascript"&gt; function ()&#123;&#125;(); // SyntaxError: Unexpected token ( //引擎在遇到关键字function时，会默认将其当做是一个函数声明，函数声明必须有一个函数名，所以在执行到第一个左括号时就报语法错误了； //函数表达式的函数名则可有可无； //在function前面加！、+、 -、=甚至是逗号等或者把函数用（）包起来都可以将函数声明转换成函数表达式；我们一般用（）把函数声明包起来或者用 = &lt;/script&gt; 引擎在遇到关键字function时，会默认将其当做是一个函数声明，函数声明必须有一个函数名，所以在执行到第一个左括号时就报语法错误了； 然后我们给它加上函数名: 12345&lt;script type="text/javascript"&gt; function abc()&#123;&#125;(); // SyntaxError: Unexpected token ) //在一个表达式后面加上括号，表示该表达式立即执行； //而如果是在一个语句后面加上括号，该括号完全和之前的语句没什么关系，而只是一个分组操作符，用来控制运算中的优先级（小括号里的先运算）。&lt;/script&gt; 上面代码可以写成： 12345&lt;script type="text/javascript"&gt; function abc()&#123;&#125;; ();// SyntaxError: Unexpected token ) //分组操作符内的表达式不能为空，执行到右括号时，发现表达式为空，所以报错。&lt;/script&gt; 然而函数表达式的函数名则可有可无； 在function前面加！、+、 -、=甚至是逗号等或者把函数用（）包起来都可以将函数声明转换成函数表达式；我们一般用（）把函数声明包起来或者用 = ； 我们在函数后面加上括号，然后再用另一个括号把它们都包起来； javascript中，括号内不允许包含语句，但可以是表达式； 引擎先遇到括号，然后遇到关键字function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明； 123456789101112131415&lt;script type="text/javascript"&gt; (function ()&#123;/*code*/&#125;()); //javascript中，括号内不允许包含语句，但可以是表达式； //引擎先遇到括号，然后遇到关键字function , 就自动把括号里面的代码识别为函数表达式，而不是函数声明 (function()&#123;/*code*/&#125;)(); //也可以这样写 var a = function()&#123;/*code*/&#125;(); //我们可以在函数表达式后面直接加括号，而不用把函数包起来； //但还是推荐外部加上()： var b = (function()&#123;/*code*/&#125;()); var c = (function()&#123;/*code*/&#125;)(); //因为外部如果没有()，我们得去function()&#123;/*code*/&#125;后面看是否存在()，判断b/c是一个函数还是一个函数内部的返回值 //为了代码的可读性，还是要在外部加上()，无论是否已经是表达式；&lt;/script&gt; javascript只有函数拥有局部作用域，立即执行函数也有这一特点，我们可以利用它减少全局变量造成的空间污染； 1234567891011&lt;script type="text/javascript"&gt; (function abc()&#123; console.log(abc);//function abc()&#123;...&#125; var a = 1; console.log(a);//1 &#125;)()// console.log(a); //ReferenceError: a is not defined console.log(abc);//ReferenceError: abc is not defined //立即执行函数的函数名在外部也是找不到的 //函数表达式的标识符在外部作用域是找不到的，只有内部作用域可以找到&lt;/script&gt; 闭包(closure)闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作；简单的说，外部作用域就可以访问函数内部作用域的变量了。 由于作用域的关系，我们在函数外部是无法直接访问到函数内部的变量的，但是函数内部可以把这个变量传给全局变量或者返回出来，这样外部作用域就可以访问函数内部作用域的变量了； 简单的说，闭包就是有权限访问另一个函数内部作用域的变量的函数； javascript具有自动垃圾回收机制，函数运行完之后，其内部的变量和数据会被销毁； 但是闭包就是在外部可以访问此函数内部作用域的变量，所以闭包的一个特点就是只要存在引用函数内部变量的可能，JavaScript就需要在内存中保留这些变量。而且JavaScript运行时需要跟踪这个内部变量的所有外部引用，直到最后一个引用被解除（主动把外部引用赋为null或者页面关闭），JavaScript的垃圾收集器才能释放相应的内存空间；这句话不是很好理解，下面用代码展示； 12345678910111213141516171819202122232425262728&lt;script type="text/javascript"&gt; function outer()&#123; var a = 1; function inner()&#123; return a++; &#125; return inner; &#125; var abc = outer(); //outer()只要执行过，就有了引用函数内部变量的可能，然后就会被保存在内存中； //outer()如果没有执行过，由于作用域的关系，看不到内部作用域，更不会被保存在内存中了； console.log(abc());//1 console.log(abc());//2 //因为a已经在内存中了，所以再次执行abc()的时候，是在第一次的基础上累加的 var def = outer(); console.log(def());//1 console.log(def());//2 //再次把outer()函数赋给一个新的变量def，相当于绑定了一个新的outer实例； //console.log(a);//ReferenceError: a is not defined //console.log(inner);//ReferenceError: a is not defined //由于作用域的关系我们在外部还是无法直接访问内部作用域的变量名和函数名 abc = null; //由于闭包占用内存空间，所以要谨慎使用闭包。尽量在使用完闭包后，及时解除引用，释放内存；&lt;/script&gt; 立即执行函数能配合闭包保存状态 123456789101112131415&lt;script type="text/javascript"&gt; for(var i = 0; i &lt; 3; i++)&#123; setTimeout(function()&#123; console.log(i); //3 3 3 //在执行到这一行时，发现匿名函数里没有i，然后向往外部作用域找，然后找到的其实是for循环执行完了的i，也就是2++，3 &#125;,0); &#125;; for(var i = 0; i &lt; 3; i++)&#123; setTimeout((function(x)&#123; console.log(x); //0 1 2 &#125;)(i),0); //在立即执行函数内部i传给了x，并且锁在内存中，所以不会变 &#125;; &lt;/script&gt; 插件用立即函数配合闭包写插件，防止变量全局污染，以及保证内部变量的安全； 12345678910111213141516171819202122&lt;script type="text/javascript"&gt;var Person = (function()&#123; var _sayName = function(str)&#123; str = str || 'shane'; return str; &#125; var _sayAge = function(age)&#123; age = age || 18; return age; &#125; return &#123; SayName : _sayName, SayAge : _sayAge &#125;&#125;)();//通过插件提供的API使用插件console.log(Person.SayName('lucy')); //lucyconsole.log(Person.SayName());//shaneconsole.log(Person.SayAge());//18&lt;/script&gt; 一道经典面试题下面的ul中，如何点击每一个 li 的时候弹出其下标? 12345&lt;ul&gt; &lt;li&gt;index 00000&lt;/li&gt; &lt;li&gt;index 11111&lt;/li&gt; &lt;li&gt;index 22222&lt;/li&gt;&lt;/ul&gt; 方法一： 闭包 123456789101112131415161718192021&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oLi = document.getElementsByTagName('ul')[0].children; for (var i = 0; i &lt; oLi.length; i++)&#123; // 第一种写法 (function(index)&#123; oLi[index].onclick = function()&#123; console.log(index); &#125;; &#125;)(i); // 第二种写法 oLi[i].onclick = (function(index)&#123; return function()&#123; console.log(index); &#125; &#125;)(i); &#125; &#125;&lt;/script&gt; 方法二： 将下标作为对象的一个属性，添加到每个数组元素中，（name: “ i “, value: i 的值）; 1234567891011&lt;script type="text/javascript"&gt; window.onload = function()&#123; var oLi = document.getElementsByTagName('ul')[0].children; for (var i = 0; i &lt; oLi.length; i++)&#123; oLi[i].i = i; oLi[i].onclick = function()&#123; console.log(this.i); &#125;; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之发布订阅模式]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近在看设计模式的知识，而且在工作当中，做一些打点需求的时候，正好直接利用了发布订阅模式去实现的，这让我对发布订阅这种设计模式更加的感兴趣了，于是借此机会也和大家说说这个好东东吧！ 其实在早期还是用jq开发的时代，有很多地方，我们都会出现发布订阅的影子，例如有trigger和on方法 再到现在的vue中，emit和on方法。他们都似乎不约而同的自带了发布订阅属性一般，让开发变得更加高效好用起来 那么废话不多说了，先来看看发布订阅模式到底何方神圣吧 说到发布订阅模式，它其实是一种对象间一对多的依赖关系(不是综艺节目以一敌百那种)，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知. 作用 广泛用于异步编程中（替代了传统回调函数） 对象之间松散耦合的编写代码 当然，胖子也不是一天吃成的。所以我们要想实现一个自己的发布订阅模式，以后在工作中使用，也需要一点点来的，表捉急，先从最简单的说起。 自定义事件1234567891011121314151617181920212223242526272829303132333435363738394041let corp = &#123;&#125;; // 自定义一个公司对象// 这里放一个列表用来缓存回调函数corp.list = [];// 订阅事件corp.on = function(fn)&#123; // 直接把fn先存到列表中 this.list.push(fn);&#125;// 发布事件corp.emit = function()&#123; // 当发布的时候再把列表里存的函数依次执行 this.list.forEach( cb =&gt; &#123; cb.apply(this,arguments); &#125;)&#125;;// 测试用例corp.on(function (position, salary) &#123; console.log('你的职位是：' + position); console.log('期望薪水：' + salary);&#125;);corp.on(function(skill, hobby) &#123; console.log('你的技能有： ' + skill); console.log('爱好： ' + hobby);&#125;);corp.emit('前端', 10000);corp.emit('端茶和倒水', '足球');/* 你的职位是：前端 期望薪水：10000 你的技能有： 前端 爱好： 10000 你的职位是：端茶和倒水 期望薪水：足球 你的技能有： 端茶和倒水 爱好： 足球*/ 上面通过自定义事件实现了一个简单的发布订阅模式，不过从打印出来的结果来看，有点小尴尬。Why？ 因为在正常的情况下，希望打印的是酱紫的： 123456/* 你的职位是：前端 期望薪水：10000 你的技能有： 端茶和倒水 爱好： 足球*/ 之所以出现此种情况，那是在on方法的时候一股脑的都将fn函数全部放到了列表中。然而需要的只是一个简单的key值，就可以解决了。让我们改写一下上面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152let corp = &#123;&#125;;// 这次换成一个对象类型的缓存列表corp.list = &#123;&#125;;corp.on = function(key,fn)&#123; // 如果对象中没有对应的key值 // 也就是说明没有订阅过 // 那就给key创建个缓存列表 if(!this.list[key])&#123; this.list[key] = []; &#125; // 把函数添加到对应key的缓存列表里 this.list[key].push(fn);&#125;corp.emit = function()&#123; // 第一个参数是对应的key值 // 直接用数组的shift方法取出 let key = [].shift.call(arguments); // 获取该键值中存在的所有函数 fns = this.list[key]; // 如果不存在或者没有返回 if(!fns || fns.length ==== 0) return false; // 遍历key值对应的缓存列表 // 依次执行函数的方法 fns.forEach( cb =&gt; &#123; cb.apply(this,arguments) &#125;)&#125;// 测试用例corp.on('join', (position, salary) =&gt; &#123; console.log('你的职位是：' + position); console.log('期望薪水：' + salary);&#125;);corp.on('other', (skill, hobby) =&gt; &#123; console.log('你的技能有： ' + skill); console.log('爱好： ' + hobby);&#125;);corp.emit('join', '前端', 10000);corp.emit('join', '后端', 10000);corp.emit('other', '端茶和倒水', '足球');/* 你的职位是：前端 期望薪水：10000 你的职位是：后端 期望薪水：10000 你的技能有： 端茶和倒水 爱好： 足球*/ 来个通用的现在来搞个通用的发布订阅模式实现，和刚才的差不多，不过这次起名也要隆重些了，直接叫event吧，看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let event = &#123; list: &#123;&#125;, // 订阅 on(key,fn)&#123; if(!this.list[key])&#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, // 发布 emit()&#123; let key = [].shift.call(arguments); fns = this.list[key]; if(!fns || fns.length === 0)&#123; return false; &#125; fns.forEach( cb =&gt; &#123; cb.apply(this,arguments); &#125;) &#125;, // 取消订阅 remove(key,fn)&#123; let fns = this.list[key]; // 如果不存在对应的key if(!fns) return false; // 如果没有传入函数，就会将key值对应缓存列表中的函数都清空掉 if(!fn) fns &amp;&amp; (fns.length = 0); //如果都存在 fns.forEach( (cb,i) =&gt; &#123; if(cb === fn) &#123; fns.splice(i,1); &#125; &#125;) &#125;&#125;;function cat() &#123; console.log('一起喵喵喵');&#125;function dog() &#123; console.log('一起旺旺旺');&#125;event.on('pet', data =&gt; &#123; console.log('接收数据'); console.log(data);&#125;);event.on('pet', cat);event.on('pet', dog);// 取消dog方法的订阅event.remove('pet', dog);// 发布event.emit('pet', ['二哈', '波斯猫']);/* 接收数据 [ '二哈', '波斯猫' ] 一起喵喵喵*/ 这样其实就实现了一个可以使用的发布订阅模式了，其实说起来也是比较简单的，来一起屡屡思路吧. 思路： 创建一个对象(缓存列表) on方法用来把回调函数fn都加到缓存列表中 emit方法取到arguments里第一个当做key，根据key值去执行对应缓存列表中的函数 remove方法可以根据key值取消订阅 总结优点： 对象之间的解耦 异步编程中，可以更松耦合的代码编写 缺点： 创建订阅者本身要消耗一定的时间和内存 多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 强如发布订阅模式，也是劲酒虽好，不要贪杯的道理哦。过度使用的话，都会出现上述缺点的问题。不过合理开发合理利用，这都不是什么大问题的。 原文]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F06%2F04%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。 二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。 二分搜索树二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。 这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。 实现123456789101112131415161718192021222324252627282930313233343536class Node &#123; constructor(value) &#123; this.value = value this.left = null this.right = null &#125;&#125;class BST &#123; constructor() &#123; this.root = null this.size = 0 &#125; getSize() &#123; return this.size &#125; isEmpty() &#123; return this.size === 0 &#125; addNode(v) &#123; this.root = this._addChild(this.root, v) &#125; // 添加节点时，需要比较添加的节点值和当前 // 节点值的大小 _addChild(node, v) &#123; if (!node) &#123; this.size++ return new Node(v) &#125; if (node.value &gt; v) &#123; node.left = this._addChild(node.left, v) &#125; else if (node.value &lt; v) &#123; node.right = this._addChild(node.right, v) &#125; return node &#125;&#125; 以上是最基本的二分搜索树实现，接下来实现树的遍历。 对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。 以下都是递归实现，如果你想学习非递归实现，可以 点击这里阅读 123456789101112131415161718192021222324252627282930313233343536373839// 先序遍历可用于打印树的结构// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。preTraversal() &#123; this._pre(this.root)&#125;_pre(node) &#123; if (node) &#123; console.log(node.value) this._pre(node.left) this._pre(node.right) &#125;&#125;// 中序遍历可用于排序// 对于 BST 来说，中序遍历可以实现一次遍历就// 得到有序的值// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。midTraversal() &#123; this._mid(this.root)&#125;_mid(node) &#123; if (node) &#123; this._mid(node.left) console.log(node.value) this._mid(node.right) &#125;&#125;// 后序遍历可用于先操作子节点// 再操作父节点的场景// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。backTraversal() &#123; this._back(this.root)&#125;_back(node) &#123; if (node) &#123; this._back(node.left) this._back(node.right) console.log(node.value) &#125;&#125; 以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。 12345678910111213141516breadthTraversal() &#123; if (!this.root) return null let q = new Queue() // 将根节点入队 q.enQueue(this.root) // 循环判断队列是否为空，为空 // 代表树遍历完毕 while (!q.isEmpty()) &#123; // 将队首出队，判断是否有左右子树 // 有的话，就先左后右入队 let n = q.deQueue() console.log(n.value) if (n.left) q.enQueue(n.left) if (n.right) q.enQueue(n.right) &#125;&#125; 接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反 1234567891011121314getMin() &#123; return this._getMin(this.root).value&#125;_getMin(node) &#123; if (!node.left) return node return this._getMin(node.left)&#125;getMax() &#123; return this._getMax(this.root).value&#125;_getMax(node) &#123; if (!node.right) return node return this._getMin(node.right)&#125; 向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。 12345678910111213141516floor(v) &#123; let node = this._floor(this.root, v) return node ? node.value : null&#125;_floor(node, v) &#123; if (!node) return null if (node.value === v) return v // 如果当前节点值还比需要的值大，就继续递归 if (node.value &gt; v) &#123; return this._floor(node.left, v) &#125; // 判断当前节点是否拥有右子树 let right = this._floor(node.right, v) if (right) return right return node&#125; 排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node &#123; constructor(value) &#123; this.value = value this.left = null this.right = null // 修改代码 this.size = 1 &#125;&#125;// 新增代码_getSize(node) &#123; return node ? node.size : 0&#125;_addChild(node, v) &#123; if (!node) &#123; return new Node(v) &#125; if (node.value &gt; v) &#123; // 修改代码 node.size++ node.left = this._addChild(node.left, v) &#125; else if (node.value &lt; v) &#123; // 修改代码 node.size++ node.right = this._addChild(node.right, v) &#125; return node&#125;select(k) &#123; let node = this._select(this.root, k) return node ? node.value : null&#125;_select(node, k) &#123; if (!node) return null // 先获取左子树下有几个节点 let size = node.left ? node.left.size : 0 // 判断 size 是否大于 k // 如果大于 k，代表所需要的节点在左节点 if (size &gt; k) return this._select(node.left, k) // 如果小于 k，代表所需要的节点在右节点 // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量 if (size &lt; k) return this._select(node.right, k - size - 1) return node&#125; 接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况 需要删除的节点没有子树 需要删除的节点只有一条子树 需要删除的节点有左右两条树 对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。 1234567891011121314delectMin() &#123; this.root = this._delectMin(this.root) console.log(this.root)&#125;_delectMin(node) &#123; // 一直递归左子树 // 如果左子树为空，就判断节点是否拥有右子树 // 有右子树的话就把需要删除的节点替换为右子树 if ((node != null) &amp; !node.left) return node.right node.left = this._delectMin(node.left) // 最后需要重新维护下节点的 `size` node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node&#125; 最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。 当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。 你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。 12345678910111213141516171819202122232425262728293031delect(v) &#123; this.root = this._delect(this.root, v)&#125;_delect(node, v) &#123; if (!node) return null // 寻找的节点比当前节点小，去左子树找 if (node.value &lt; v) &#123; node.right = this._delect(node.right, v) &#125; else if (node.value &gt; v) &#123; // 寻找的节点比当前节点大，去右子树找 node.left = this._delect(node.left, v) &#125; else &#123; // 进入这个条件说明已经找到节点 // 先判断节点是否拥有拥有左右子树中的一个 // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样 if (!node.left) return node.right if (!node.right) return node.left // 进入这里，代表节点拥有左右子树 // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值 let min = this._getMin(node.right) // 取出最小值后，删除最小值 // 然后把删除节点后的子树赋值给最小值节点 min.right = this._delectMin(node.right) // 左子树不动 min.left = node.left node = min &#125; // 维护 size node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序（Bubble Sort） 大家开始学习冒泡排序的，一般都是从冒泡排序开始，这是最简单的排序，，但是从运算时间来说，冒泡排序是最差的一个。 算法描述 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 先来实现一下冒泡排序：123456789101112function bubbleSort (arr) &#123; let len = arr.length; if(len &lt;= 1) return arr; for(let i=0; i&lt;len; i++)&#123; for(let j=0; j&lt;len-1; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 注意当算法执行外循环的第二轮时，最后两个数组已经是正确排序了，尽管如此，在后续的比较中，它们还一直在进行着比较，即便这是不必要的。因此，我们可以改进一下：123456789101112function bubbleSort (arr) &#123; let len = arr.length; if(len &lt;= 1) return arr; for(let i=0; i&lt;len; i++)&#123; for(let j=0; j&lt;len-1-i; j++)&#123; if(arr[j] &gt; arr[j+1])&#123; [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 12345678910111213141516function BubbleSort (arr) &#123; let len = arr.length; if(len &lt;= 1) return arr; let pos; // 先声明标志变量 var i = len-1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; pos= 0; //每趟开始时,无记录交换 for (var j= 0; j&lt; i; j++) if (arr[j]&gt; arr[j+1]) &#123; pos= j; //记录交换的位置 var tmp = arr[j]; arr[j]=arr[j+1];arr[j+1]=tmp; &#125; i= pos; //为下一趟排序作准备 &#125; return arr;&#125; 冒泡排序动图演示 选择排序（Select Sort） 选择排序是一种简单直观的排序算法，它的工作原理是：首先找到数据结构中的最小值,然后将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。 12345678910111213141516function SelectSort (arr) &#123; var len = arr.length; var indexMin,temp; for(var i=0; i&lt;len-1; i++)&#123; indexMin = i; for(var j=i+1; j&lt;len; j++)&#123; if(arr[indexMin] &gt; arr[j]) indexMin = j; // 找到最小的值，保存其索引 &#125; if(i !== indexMin) &#123; // 交换位置sels temp = arr[i]; arr[i] = arr[indexMin]; arr[indexMin] = temp; &#125; &#125; return arr;&#125; 选择排序动图演示 插入排序（Insertion Sort）算法介绍 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法的描述和实现一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 1234567891011121314function insertionSort(arr)&#123; var len = arr.length; var temp, j; for(var i=1; i&lt;len; i++)&#123; temp = arr[i]; j = i; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125; return arr;&#125; 改进插入排序：查找插入位置时使用二分查找的方式12345678910111213141516171819202122function binaryInsertSort(arr)&#123; if(Array.isArray(arr))&#123; for(var i=0;i&lt;arr.length;i++)&#123; var key=arr[i],left=0,right=i-1; while(left&lt;=right)&#123; var middle = parseInt((left+right)/2); if(key &lt; arr[middle])&#123; right = middle - 1; &#125;else &#123; left = middle+1; &#125; &#125; for(var j = i-1;j&gt;=left;j--)&#123; arr[j+1] = arr[j]; &#125; arr[left] = key; &#125; return array; &#125;else &#123; return "arr is not an Array"; &#125;&#125; 插入排序演示图示 归并排序(Merge Sort) 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 算法介绍 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述和实现具体算法描述如下： 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 1234567891011121314151617181920212223242526function mergeSort(arr)&#123; // 采用自上而下的递归方法 var len = arr.length; if(arr &lt; 2) return arr; var middle = Math.floor(len/2); left = arr.slice(0,middle); right = arr.slice(middle); return merge(mergeSort(left),mergeSort(right));&#125;function merge(left,right)&#123; var result = []; while(left.length &amp;&amp; right.length)&#123; if(left[0]&lt;=right[0])&#123; result.push(left.shift()); &#125;else &#123; result.push(right.shift()) &#125; &#125; while(left.length) result.push(left.shift()); while(right.length) result.push(right.shift()); result();&#125; 归并排序动图演示]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之对象的扩展]]></title>
    <url>%2F2018%2F03%2F13%2FES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[属性的简洁表示ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。123456const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: 'bar'&#125;// 等同于const baz = &#123;foo: foo&#125;; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 除了属性简写，方法也可以简写。123456789101112const o = &#123; method() &#123; return "Hello!"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return "Hello!"; &#125;&#125;; 下面是一个实际的例子.12345678910111213let birth = '2000/01/01';const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便。12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS 模块输出一组变量，就非常合适使用简洁写法。123456789101112131415161718192021let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。1234567891011121314const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125; 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。12345678const obj = &#123; class () &#123;&#125;&#125;;// 等同于var obj = &#123; 'class': function() &#123;&#125;&#125;; 上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。 如果某个方法的值是一个Generator函数，前面需要加上星号。12345const obj = &#123; * m() &#123; yield 'hello world'; &#125;&#125;; 属性名表达式JavaScript 定义对象的属性，有两种方法。12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。1234var obj = &#123; foo: true, abc: 123&#125;; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 下面是另一个例子。12345678910let lastWord = 'last word';const a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // "hello"a[lastWord] // "world"a['last word'] // "world" 表达式还可以用于定义方法名。1234567let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。12345678// 报错const foo = 'bar';const bar = 'abc';const baz = &#123; [foo] &#125;;// 正确const foo = 'bar';const baz = &#123; [foo]: 'abc'&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: "valueB"&#125; 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 方法的name属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。1234567const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // "sayName" 上面代码中，方法的name属性返回函数名（即方法名）。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。123456789101112const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name// TypeError: Cannot read property 'name' of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo" 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。123456(new Function()).name // 'anonymous'var doSomething = function () &#123; // ...&#125;;doSomething.bind().name // 'bound doSomething' 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。12345678const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;;obj[key1].name // "[description]"obj[key2].name // "" 上面代码中，key1对应的 Symbol 值有描述，key2没有。 Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true ES5 可以通过下面的代码，部署Object.is。12345678910111213Object.defineProperty(Object, 'is', &#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); Object.assign() 基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果只有一个参数，Object.assign会直接返回该参数。12const obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。1typeof Object.assign(2) // "object" 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。12Object.assign(undefined) // 报错Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。123456const v1 = 'abc';const v2 = true;const v3 = 10;const obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; "0": "a", "1": "b", "2": "c" &#125; 上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。123Object(true) // &#123;[[PrimitiveValue]]: true&#125;Object(10) // &#123;[[PrimitiveValue]]: 10&#125;Object('abc') // &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125; 上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。1234567Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;))// &#123; b: 'c' &#125; 上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。 属性名为 Symbol 值的属性，也会被Object.assign拷贝。12Object.assign(&#123; a: 'b' &#125;, &#123; [Symbol('c')]: 'd' &#125;)// &#123; a: 'b', Symbol(c): 'd' &#125; 注意点浅拷贝Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。 同名属性的替换对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。1234const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; 上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }的结果。这通常不是开发者想要的，需要特别小心。 一些函数库提供Object.assign的定制版本（比如 Lodash 的_.defaultsDeep方法），可以得到深拷贝的合并。 数组的处理Object.assign可以用来处理数组，但是会把数组视为对象。12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 取值函数的处理Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。1234567const source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; 上面代码中，source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。 常见用途Object.assign方法有很多用处。 为对象添加属性12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; // ··· &#125;, anotherMethod() &#123; // ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; // ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; // ···&#125;; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 克隆对象123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象将多个对象合并到某个对象。12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 为属性指定默认值12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; 上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。 注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。1234567891011const DEFAULTS = &#123; url: &#123; host: 'example.com', port: 7070 &#125;,&#125;;processContent(&#123; url: &#123;port: 8000&#125; &#125;)// &#123;// url: &#123;port: 8000&#125;// &#125; 上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。 属性的可枚举性和遍历 可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。12345Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable// falseObject.getOwnPropertyDescriptor([], 'length').enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。12Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, 'foo').enumerable// false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 for…infor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 原型的操作方法JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法. __proto__ 属性__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。123456789// es6 的写法const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es5 的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; 该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下。12345678910111213141516171819202122232425Object.defineProperty(Object.prototype, '__proto__', &#123; get() &#123; let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); &#125;, set(proto) &#123; if (this === undefined || this === null) &#123; throw new TypeError(); &#125; if (!isObject(this)) &#123; return undefined; &#125; if (!isObject(proto)) &#123; return undefined; &#125; let status = Reflect.setPrototypeOf(this, proto); if (!status) &#123; throw new TypeError(); &#125; &#125;,&#125;);function isObject(value) &#123; return Object(value) === value;&#125; 如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。12Object.getPrototypeOf(&#123; __proto__: null &#125;)// null Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。12345// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); 该方法等同于下面的函数。1234function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 下面是一个例子。12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。123Object.setPrototypeOf(1, &#123;&#125;) === 1 // trueObject.setPrototypeOf('foo', &#123;&#125;) === 'foo' // trueObject.setPrototypeOf(true, &#123;&#125;) === true // true 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。12345Object.setPrototypeOf(undefined, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefinedObject.setPrototypeOf(null, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefined Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。1Object.getPrototypeOf(obj); 下面是一个例子。123456789101112function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false 如果参数不是对象，会被自动转为对象。123456789101112131415// 等同于 Object.getPrototypeOf(Number(1))Object.getPrototypeOf(1)// Number &#123;[[PrimitiveValue]]: 0&#125;// 等同于 Object.getPrototypeOf(String('foo'))Object.getPrototypeOf('foo')// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;// 等同于 Object.getPrototypeOf(Boolean(true))Object.getPrototypeOf(true)// Boolean &#123;[[PrimitiveValue]]: false&#125;Object.getPrototypeOf(1) === Number.prototype // trueObject.getPrototypeOf('foo') === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true 如果参数是undefined或null，它们无法转为对象，所以会报错。12345Object.getPrototypeOf(null)// TypeError: Cannot convert undefined or null to objectObject.getPrototypeOf(undefined)// TypeError: Cannot convert undefined or null to object super关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 上面代码中，对象obj的find方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;// 报错const obj = &#123; foo: function () &#123; return super.foo &#125;&#125; 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让JavaScript引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。1234567891011121314151617const proto = &#123; x: 'hello', foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: 'world', foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() // "world" 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。 遍历对象的方法Object.keys()ES5 引入了bject.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。123var obj = &#123;foo:'bar',baz:42&#125;;Object.keys(obj);// ["foo", "baz"] ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。123const obj = &#123; foo: 'bar', baz: 42 &#125;;Object.values(obj)// ["bar", 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。123const obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;Object.values(obj)// ["b", "c", "a"] 上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a. Object.values只返回对象自身的可遍历属性。12const obj = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);Object.values(obj) // [] 上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。1234567const obj = Object.create(&#123;&#125;, &#123;p: &#123; value: 42, enumerable: true &#125;&#125;);Object.values(obj) // [42] Object.values会过滤属性名为 Symbol 值的属性。12Object.values(&#123; [Symbol()]: 123, foo: 'abc' &#125;);// ['abc'] 如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。12Object.values('foo')// ['f', 'o', 'o'] 上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。12Object.values(42) // []Object.values(true) // [] 对象的扩展运算符《数组的扩展》一章中，已经介绍过扩展运算符（…）。123const [a, ...b] = [1, 2, 3];a // 1b // [2, 3] 解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。12let &#123; x, y, ...z &#125; = null; // 运行时错误let &#123; x, y, ...z &#125; = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。12let &#123; ...x, y, z &#125; = obj; // 句法错误let &#123; x, ...y, ...z &#125; = obj; // 句法错误 上面代码中，解构赋值不是最后一个参数，所以会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。123456let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。 下面是另一个例子。1234567const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...&#123; y, z &#125; &#125; = o;x // 1y // undefinedz // 3 上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。12345678function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用 x 和 y 参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。 扩展运算符对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 这等同于使用Object.assign方法。123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。1234567891011121314151617// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。 扩展运算符可以用于合并两个对象。123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。1234567let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。 这用来修改现有对象部分的属性就很方便了。1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。1234567let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;// 等同于 even if property keys don’t clash, because objects record insertion order:let aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);// 等同于let aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。1234const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;; 如果扩展运算符后面是一个空对象，则没有任何效果。123&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125; even if property keys don’t clash, because objects record insertion order: 如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。1let emptyObject = &#123; ...null, ...undefined &#125;; // 不报错 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 1234567891011121314151617// 并不会抛出错误，因为 x 属性只是被定义，但没执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入对象]]></title>
    <url>%2F2018%2F03%2F07%2FJavaScript%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[创建对象简单做法使用Object构造函数创建123// 对象实例的创建var obj = new Object() obj.key = 'value' //使用构造函数创建一个空对象，并赋值s 使用对象字面量表示法创建1234var obj = &#123; key1: 'value1', key2: 'value2'&#125; 字面量表示法与 Object 构造函数创建法唯一的区别是，在字面量表示法里你可以给对象添加多个 键/值 对，但是在构造形式中你必须逐个添加属性。 现在ES6可以使用更简洁的方式创建对象：12345678910111213141516171819let age = 20;let sex = 'sexy';let obj = &#123; name: 'jay', // 简洁表示法，等同于 age: age age, // 简洁表示法，等同于 sayName： function() &#123;&#125; sayName()&#123;&#125;, //属性名表达式，等同于 lover:'rose' ['lo'+'ver']: 'rose', // 属性名表达式，等同于 sexy: 'male' [sex]: 'male'&#125; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 ‘[object Object]’，这一点要特别小心。 工厂模式即用函数来封装创建对象的细节。多次调用该函数来创建多个相似对象。12345678910function createPerson(name, age) &#123; var o = &#123;&#125; o.name = name o.age = age o.sayName = function() &#123;console.log(this)&#125; return o&#125; var a = createPerson('a', 20)var b = createPerson('b', 22) 工厂模式虽然解决多创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 模仿‘类’的设计构造函数模式构造函数包括像Array,Object这样的原生构造函数，他们在js运行时会自动出现在执行环境中。此外，我们可以创建自定义构造函数，从而定义自定义类型的属性和方法。现在构造函数重写上个例子：12345678910function Person(name,age) &#123; this.name = name; this.age = age; this.sayName = function () &#123; console.log(this); &#125;;&#125;let a = new Person('a',20);a instanceof Person // true 构造函数就是普通的函数，不存在特殊语法。构造函数与其他函数唯一的区别就在于调用他们的方式不同。任何函数只要通过new操作符来调用，那它就可以作为构造函数。使用new操作符调用函数，或者说发生构造函数调用时，会自动执行下面操作： 创建一个全新的对象。 这个新对象会被执行[[Prototype]] 链接。 这个新对象会绑定到函数调用时的this。 如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象。 由于构造函数调用时会自动执行 [[Prototype]] 链接，也就是把新对象的原型链指向构造函数的 prototype。所以使用instanceof或isPrototypeOf方法可以判断他们的类型。 上面这种构造函数解决了对象类型识别的问题，但是每个方法都要在每个实例上重新创建一遍，在上面的例子中，a 和 b 都有个名为sayName()的方法，这两个方法虽然名字、内容、功能相同，但却分别在 a 和 b 中都重新创建了一次，这是没有必要的。 更好的方法应该是将公用的方法放到他们的原型上，也就是接下来要说的原型模式。 原型模式所有函数都有一个不可枚举的prototype(原型)属性，这个属性时一个指针，指向一个对象。123function Foo () &#123;&#125;Foo.prototype // &#123;&#125; 上一节【构造函数模式】里面有说，new操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 所指向的对象。 这里出现了一个重点词原型链，我们先解释下什么叫做原型链。 原型链也被称为 [[Prototype]]链，是对象的内置属性。原型链是 ECMAScript 中实现继承的主要办法，其基本思想就是让一个引用类型继承另一个引用类型的属性和和方法。 例如我们新建个对象 a，然后给它指定它的原型链的指向：123456var a = &#123;&#125;var b = &#123;x: 2&#125; Object.setPrototypeOf(a, b) a.x // 2 这个例子中我们通过Object.setPrototypeOf()方法把 a 的原型链指向 b，然后 a 就继承了 b 的属性，当查询 a 中没有的 x 属性时，会指向到 b.x 的值。 这里原理上说是委托比说是继承更符合真实情况。因为真实情况如上段所说是 a 把自身没有的属性查询委托给 b，如果 b 中也没 x 属性的话，系统会继续循着原型链往上查。所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。如果 Object.prototype 也没有的话就会提示 undefined。 这里提示一下，由于所有普通的对象都”源于“（或者说把 [[Prototype]] 链的顶端设置为）这个 Object.prototype 对象，所以它包含 Javascript 中许多通用的功能。 上面说过，new操作符会新建一个对象，并把该对象的原型链指向构造函数的 prototype 属性所指向的对象（即原型对象）。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。例如：1234567891011function Person() &#123;&#125;Person.prototype = &#123; name: 'h', sayName () &#123; alert(this.name); &#125;&#125;var a = new Person() a.sayName() // h 这种方法因为重写了Person.prototype,所以默认的Person.prototype.constructor也会丢失，如果要修复constructor,可以使用Object.defineProperty().1234Object.defineProperty(Person.prototype,'constructor',&#123; enumerable: false, value: Person&#125;) 不过实例一般都是要有属于自己的全部属性的。所以日常开发中设计对象更常见的做法是构造函数模式跟原型模式组合使用：12345678910function Person (name) &#123; this.name = name;&#125;Person.prototype.sayName = function () &#123; alert(this.name);&#125;let a = new Person('Jack');a.sayName(); // Jack 这里很像一些面向“类”的语言的行为，a 和 b 是 Person 类的实例，a 和 b 继承了 Person 类的特性。但实际上 JavaScript 和面向类的语言不同，它并没有类作为对象的抽象模式或者说蓝图。JavaScript 中只有对象。 使用ES6 Class上面说的原型是通过构造函数，定义并生成新对象。但这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。ES6 提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。 不过需要注意的是， ES6 的 class 语法是并不是向 JavaScript 中引入了一种新的“ 类” 机制。 class 基本上只是现有 [[Prototype]] 机制的一种语法糖。 也就是说， class 并不会像传统面向类的语言一样在声明时静态复制所有行为。 如果你（ 有意或无意） 修改或者替换了父“ 类” 中的一个方法， 那子“ 类” 和所有实例都会受到影响， 因为它们在定义时并没有进行复制， 只是使用基于 [[Prototype]] 的实时委托。 ES6 的类，完全可以看作构造函数的另一种写法。12345class Foo &#123;&#125;typeof Foo // 'function'Foo === Foo.prototype.constructor // true 面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。123456789101112class Foo &#123; constructor () &#123; this.name = name; &#125; sayName () &#123; console.log(this.name); &#125;&#125;let a = new Foo('a');a.sayName(); // a 构造函数的prototype 属性，在ES6的‘类’上继续存在，事实上，类的所有方法都定义上类的prototype 属性上面。123456789101112class Foo &#123; constructor () &#123;&#125; toString () &#123;&#125; toValue () &#123;&#125;&#125;// 等同于Foo.prototype = &#123; toString()&#123;&#125;, toValue () &#123;&#125;&#125; 由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678class Foo &#123; constructor()&#123;&#125;&#125; Object.assign(Foo.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); ES6 Class 与 普通构造函数的不同点主要有 4 个： (1)constructor 方法 constructor方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。1234567class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125; new Foo() instanceof Foo // false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。1234567class Foo &#123;constructor() &#123;return Object.create(null);&#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without 'new' (2)类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与普通构造函数的行为不一致。123456789101112/ classclass Foo &#123; constructor(name) &#123; this.name = name &#125; sayName()&#123; console.log(this.name) &#125;&#125; Object.keys(Foo.prototype) // []Object.getOwnPropertyNames(Foo.prototype) // ["constructor","sayName"] 1234567891011//构造函数function Foo(name) &#123; this.name = name&#125; Foo.prototype.sayName = function() &#123; alert(this.name) &#125; Object.keys(Foo.prototype) // ["sayName"]Object.getOwnPropertyNames(Foo.prototype) // ["constructor", "sayName"] 上面代码中，sayName方法是 Foo 类内部定义的方法，它是不可枚举的。而定义在 Foo.prototype 中的话则是可枚举的。 (3) Class不存在变量提升（hoist），这点与ES5完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo 类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 (4)子类的继承 Class 之间可以通过 extends 关键字实现继承，这比普通构造函数通过修改原型链实现继承，要清晰和方便很多。12class Foo &#123;&#125;class Bar extends Foo &#123;&#125; 上面代码定义了一个 Bar 类，该类通过extends关键字，继承了 Foo 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 Foo 类。下面，我们在 Bar 内部加上代码。1234567891011121314151617181920212223242526class Foo &#123; constructor (name,age) &#123; this.name = name; this.age = age; &#125; sayProfile () &#123; return `hello, my name is $&#123;this.name&#125;, $&#123;this.age&#125; years old` &#125;&#125;class Bar extends Foo &#123; constructor (name ,age, lover) &#123; super(name,age);// 调用父类的 constructor(name,age), 约等于普通构造函数中的 Foo.call(this, name, age) this.age = Number(this.age) + 5; this.lover = lover; &#125; sayIntro() &#123; alert(super.sayProfile() + `, my lover is $&#123;this.lover&#125;, again, I am $&#123;this.name&#125;`) &#125;&#125;var a = new Bar('Jack', '20', 'Rose') a.sayIntro() // "hello, my name is Jack, 25 years old, my lover is Rose, again, I am 上面代码中，子类 Bar 的constructor方法和sayIntro方法之中，都出现了super关键字，super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。在上面的代码中 子类 Bar 的构造函数中super(name, age)相当于Foo.prototype.constructor.call(this, name, age)。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 要注意的是，子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用super方法，子类就得不到 this 对象。在子类的构造函数中，只有调用super之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 普通构造函数的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Foo.call(this)）。ES6 Class 的继承机制完全不同，实质是先创造父类的实例对象 this（所以必须先调用super方法），然后再用子类的构造函数修改 this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法：123constructor (...args) &#123; super(...args);&#125; 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。上面代码代码中的 super.sayProfile()就是将super当作一个对象使用。这时，super在普通方法之中，指向 Foo.prototype，所以super.sayProfile()就相当于Foo.prototype.sayProfile()。 ES6 规定，通过super调用父类的方法时，super会绑定子类的 this。所以sayProfile输出的this.age是子类 Bar 的 age 25岁。 刚刚说到在静态方法中super指向父类。 静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910class Foo &#123; static sayHi () &#123; return 'hello'; &#125;&#125;Foo.sayHi(); // hello var a = new Foo();a.sayHi(); // TypeError: a.sayHi is not a function 上面代码中ayHi()就是 Foo 的静态方法，它只能通过 Foo 调用，不能通过 Foo 的实例调用。 如果super作为对象用在静态方法中，这时super将指向父类，而不是父类的原型对象。12345678910111213141516class Foo &#123; static sayHi() &#123; // 父类 return 'hello'; &#125; sayHi () &#123; // 原型 return 'oops'; &#125;&#125;class Bar extends Foo &#123; static sayBob () &#123; return super.sayHi() + 'Bob'; &#125;&#125;Bar.sayBob (); // 'hello Bob' 面向委托的设计（对象关联风格）有些开发者比较诟病这种模仿“类”的设计模式，因为继承意味着复制，JavaScript（默认）并不会复制对象属性。相反，JavaScript 会在两个对象之间创建一个关联（我们把这种关联成为原型链），这样对象就可以通过委托访问另一个对象的属性和函数。委托这个术语可以更加准确地描述 JavaScript 中的对象关联机制。 即便通过 ES6 class 让 js 看起来更像“类”，也只是一种模仿的假象。在传统的面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改，但是 Javascript 最强大的特性就是它的动态性，任何对象的定义都可以修改（除非你把它定义为不可变）。 一些开发者认为 ES6 的 class 想伪装成一种很好的语法问题的解决方案，但实际上却让问题更难解决且让 JavaScript 更难理解。因为它隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托机制。让本来简洁优雅的 [[Prototype]] 机制变的非常别扭。 我们比较下继承与委托设计的区别。 我们先想想类（继承）的设计方法：先定义一个通用的父类 F，在父类 F 中定义所有任务都有的行为，接着定义子类 a 和 b，他们都继承自父类并且会添加一些特殊行为来处理对应的任务。 再用委托的思想来考虑同样的问题：首先先定义一个对象 F，它包含所有任务都可以使用（委托）的具体行为。接着，对于每个任务你都会定义一个对象来储存对应的数据和行为，你会把特定的任务对象都关联到 F 功能对象上面，让他们在需要的时候可以进行委托。基本你可以想象成 a 和 F 之间是兄弟关系，a 完成不了的任务东西都委托给 F完成。 JavaScript 中原型链实际上是委托的关系而不是继承。委托行为意味着某些对象在找不到属性或方法引用时会把这个请求委托给另一个对象。 我们先看一个使用类设计风格的例子：123456789101112131415function Foo (name) &#123; this.name = name;&#125;Foo.prototype.intro = function() &#123; return 'my name is ' + this.name;&#125;function Bar (name) &#123; Foo.call(this,name);&#125;Bar.prototype = Object.create(Foo.prototype);Bar.prototype.speak = function()&#123;alert(this.intro())&#125;;var a = new Bar('a');a.speak(); // my name is a 这个例子里子类 Bar 继承了父类 Foo，然后生成了 a 这个实例，a 通过 new 构造函数委托了 Bar.prototype，Bar.prototype 通过Object.create()方法委托了 Foo.prototype()。这种风格很常见，你应该已经熟悉了。 当然我们可以用 class 让这段代码看起来更简洁明了：1234567891011121314151617class Foo &#123; constructor(name) &#123; this.name = name &#125; intro() &#123; return 'my name is ' + this.name &#125;&#125; class Bar extends Foo &#123; constructor(name) &#123; super(name) &#125; speak() &#123; alert(super.intro()) &#125;&#125; var a = new Bar('a') a.speak() 现在再来看看同例的对象关联风格的设计：123456789101112131415161718Foo = &#123; init: function(name) &#123; this.name = name &#125;, intro: function() &#123; return 'my name is ' + this.name &#125;&#125; Bar = Object.create(Foo)Bar.speak = function() &#123; alert(this.intro())&#125; var a = Object.create(Bar)a.init('a') a.speak() 这段代码中我们同样利用 [[Prototype]] 把 a 委托给 Bar 并把 Bar 委托给 Foo，和上段代码一样，我们仍然实现了三个对象的关联。 但非常重要的一点是，这段代码简洁了许多，我们只是把对象关联起来，并不需要那些既复杂又令人困惑的模仿类的行为（构造函数、原型以及 new）。 对象的内容对象的内容是由一些储存在特定命名位置的（任意类型的）值组成的，我们称之为属性。 getter与settergetterget 语法将一个对象属性绑定到查询该属性时将被调用的一个函数上。该方法会覆盖单个属性默认的 [[Get]] 操作（获得属性值的操作）。 用法： {get prop() { … } } // prop 为要绑定到给定函数的属性名 {get expression { … } } //从ECMAScript 2015 (ES6)开始，还可以使用一个计算的属性名的表达式绑定到给定的函数。 例如：1234567891011121314151617var myObj = &#123; get a () &#123; return 2; &#125;&#125;;// 也可以通过 defineProperty 创建Object.defineProperty(myObj, 'b', &#123; get: function () &#123;return this.a*2&#125;, enumable: true&#125;)myObj.a // 2myObj.b // 4myObj.a = 3 myObj.a // 2 如上面例子，不管是对象文字语法中的get a() { .. }， 还是defineProperty(...)中的显式定义， 二者都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，它的返回值会被当作属性访问的返回值。 同时由于我们只定义了 a 的 getter， 所以对 a 的值进行设置时 set 操作会忽略赋值操作，且不会抛出错误。 为了让属性更合理， 我们还应当定义 setter。 setterset 语法会覆盖单个属性默认的 [[Put]] 操作（赋值操作）。 通常来说 getter 和 setter 是成对出现的（ 只定义一个的话通常会产生意料之外的行为）。 例如：1234567891011var myObj = &#123; get a () &#123; return this._a_; &#125;, set a(val) &#123; this._a_ = val * 2; &#125;&#125;myObj.a = 2;myObj.a // 4 注意，在本例中， 实际上我们把赋值（ [[Put]]） 操作中的值 2 存储到了另一个变量_a_中。 名称_a_只是一种惯例， 没有任何特殊的行为，和其他普通属性一样。 遍历对象属性for…infor keys in object 循环可以遍历对象的可枚举属性列表（包括 [[Prototype]] 原型链）。 for..in循环是无法直接获取属性值的，你需要手动获取属性值。 需要注意的是遍历对象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。 for…offor..of循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。 我们先看一下迭代器的定义： 可迭代协议 可迭代协议允许 JavaScript 对象去定义或定制它们的迭代行为, 例如（定义）在一个 for..of 结构中什么值可以被循环（得到）。一些内置类型都是内置的可遍历对象并且有默认的迭代行为, 比如 Array、Map, 另一些类型则不是 (比如 Object) 。 为了变成可遍历对象， 一个对象必须实现 @@iterator 方法, 意思是这个对象（或者它原型链上的某个对象）必须有一个名字是 Symbol.iterator 的属性: 数组有内置的 @@iterator， 因此for..of可以直接应用在数组上:1234567var myArr = [1,2,3];for(var v of myArr)&#123; console.log(v);&#125;// 1// 2// 3 我们再通过数组的Symbol.iterator属性看看@@iterator是怎么工作的：123456var myArr = [1,2,3];it = myArr[Symbol.iterator]()it.next() // &#123;value: 1, done: false&#125;it.next() // &#123;value: 2, done: false&#125;it.next() // &#123;value: 3, done: false&#125;it.next() // &#123;value: undefined, done: true&#125; 如你所见，调用迭代器的next()方法会返回形式为{value: .., done: ..}的值，value是当前的遍历值，done是一个布尔值，表示是否还有可以遍历的值。 上面示例中需要注意的一点，我们使用符号Symbol.iterator来获取对象的@@iterator内部属性。引用类似 iterator 的特殊属性时要使用符号名，而不是符号包含的值。此外，虽然看起来很像一个对象，但@@iterator本身并不是迭代器对象，而是返回迭代器对象的函数——这点非常精妙并且重要。 可是普通对象没有内置的@@iterator，所以无法完成for..of遍历。制定者之所以这样做，有许多复杂的原因，不过简单来说，这样做是为了避免影响未来的对象类型。 但我们可以给任何想遍历的对象自定义@@iterator，例如：1234567891011121314151617181920212223242526272829303132var myObj = &#123;a:1, b:2&#125;Object.defineProperty(myObj, Symbol.iterator, &#123; enumerable: false, writable: false, configurable: true, value: function() &#123; var o = this; var idx = 0; var ks = Object.keys(o); return &#123; next: function() &#123; return &#123; value: o[ks[idx++]], done: (idx &gt; ks.length) &#125; &#125; &#125; &#125;&#125;)// 手动遍历 myObjvar it = myObj[Symbol.iterator]()it.next() // &#123;value: 1, done: false&#125;it.next() //&#123;value: 2, done: false&#125;it.next() //&#123;value: undefined, done: true&#125;// 用 for..of 遍历 myObjfor(var v of myObj) &#123; console.log(v)&#125;// 1// 2 对象的代理ProxyES6 中引入的 Proxy 是一个元编程的特性。元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。 Proxy 对象用于定义基本操作的自定义行为 (例如属性查找，赋值，枚举，函数调用等)。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。也就说它可以 “代理” 对象的原生行为，替换为执行自定义行为。 Proxy语法如下：1let p = new Proxy(target,handler); 其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 举个栗子，我们知道当我们要获取对象的属性值的时候，对象内部会调用 get 方法去获取这个属性，如果该属性不存在在该对象中，则会继续向 [[Prototype]] 原型链向上寻找，一直找到 Object.prototype。 如果我们按上一节的方法给该属性设置了get()方法，则查询该属性值时会返回get() 方法的返回值。Proxy 可以给所有查询不到的属性设置统一的get()方法。 例如：12345678910var a = &#123;x: 2&#125;var obj = new Proxy(a, &#123; get: function(target, name)&#123; return name in target ? target[name] : 3 &#125;&#125;)obj.x // 2obj.y // 3obj.z // 3a.y // undefined 需要注意的是，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。12345var a = &#123;x:2&#125;var obj = new Proxy(a,&#123;&#125;)obj.y = 3a.y = 3; 有一个技巧是把 Proxy 实例作为其他对象的原型对象，这样就可以让其他对象继承（或者说委托？）Proxy 实例的拦截方法。123456789var obj = new Proxy (&#123;&#125;,&#123; get:function ()&#123; return 233; &#125;&#125;)var a = Object.create(obj);a.someprop // 233 此外，Proxy 对象还提供了一个revoke方法，可以随时注销所有的代理操作。12345678910var p = Proxy.revocable(&#123;&#125;, &#123; get() &#123; return 1 &#125;&#125;);var a = p.proxya.x // 1p.revoke()a.x // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是 Proxy 实例，revoke属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行revoke函数之后，再访问 Proxy 实例，就会抛出一个错误。 Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 包括 get()、set() 在内，Proxy 支持的拦截操作有十多种，包含了大部分对象的方法操作的拦截。具体请查阅 ECMAScript 6 入门 及 MDN 文档 对象方法原型相关 create,setPrototypeOf,getPrototypeOfObject.create(proto, [ propertiesObject ])该方法使用指定的原型对象和其属性创建了一个新的对象。可理解为该方法会创建一个对象并把这个对象的 [[Prototype]]关联到指定对象。 需要注意的是，Object.create(null)会创建一个拥有空（或者 null）[[Prototype]] 链的对象，这个对象无法进行委托。由于这个对象没有原型链，所以instanceof操作符无法进行判断，因此总是返回 false。这些特殊的空 [[Prototype]] 对象通常被称作“字典”，他们完全不会受到原型链的干扰，因此非常适合用来储存数据。 Object.setPrototypeOf(obj, prototype)该方法是ES6的新方法，用于设置一个指定的对象的原型 ( 例如,内置的 [[Prototype]] 属性）到另一个对象或 null。可以代替 ES5 的Object.create。 例如有两个对象 a 和 b，我们需要把 b 设为 a 的原型，以便 a 可以继承 b 的属性：12345678var a = &#123;x: 1&#125;;var b = &#123;y: 2&#125;;Object.setPrototypeOf(a,b);a.x //1a.y // 2Object.getOwnPropertyNames(a) // ["x"] 上例中把 b 设为 a 的原型，因此当向 a 查询 y 时，由于 a 本身没有 y 属性，所以会循着原型链查询到 b 的 y。 再例如有两个函数（函数也是对象哦！） Bar 和 Foo，我们需要把 Bar.prototype 关联到 Foo.prototype:12345678910111213141516// 创建 Foofunction Foo(name) &#123;this.name = name&#125;Foo.prototype.sayName= function() &#123;return this.name&#125;// 创建 Barfunction Bar(name)&#123;Foo.call(this, name)&#125;//关联 prototype// ES6 之前需要抛弃默认的 Bar.prototypeBar.prototype = Object.create(Foo.prototype)// ES6 开始可以直接修改现有的 Bar.prototypeObject.setPrototypeOf(Bar.prototype, Foo.prototype)var a = new Bar('a')a.sayName() 如果不考虑Object.create(..)方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它其实比 ES6 及其之后的方法更短切可读性更高。 Object.getPrototypeOf(obj)该方法返回指定对象的原型（即内部 [[Prototype]] 属性的值）。如果没有继承属性，则返回 null 。1234var a = &#123;&#125;var b = Object.create(a) Object.getPrototypeOf(b) === a // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入数组]]></title>
    <url>%2F2018%2F02%2F26%2FJavaScript%E6%B7%B1%E5%85%A5%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组基础简介数组是应用最广泛的数据存储结构。它被植入到大部分编程语言中。在 ECMAScript 中数组是非常常用的引用类型。 属性lengthlength属性表示数组的长度，即其中元素的个数。JavaScript数组的length属性时可变的，当length属性被设置的更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大;当length属性被设置的比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。 prptotype返回对象类型原型的引用。prototype属性是object共有的。一般用来给数组实例添加方法。 constructor表示创建对象的函数。说明：constructor属性是所有具有prototype的对象的成员。constructor属性保存了对构造特定对象实例的函数的引用。 基本操作创建数组12345678// 数组实例的创建var arr = [];var arr = new Array();var arr = new Array(5); // 创建一个length为5的数组 [undefined, undefined, undefined, undefined, undefined]var arr = new Array(1,2,3); // 创建数组并赋值 [1,2,3]var arr = new Array(3).fill(5); // 创建一个length为3的数组，并里面赋值均为5 [5,5,5] var arr = Array.of(7); // 创建数组并赋值[7]var arr = Array.of(1,2,4); // 创建数组并赋值 [1,2,4] 检测数组123456789// 判断一个对象是不是一个数组var arr = [];if(arr instanceof Array) &#123;&#125; // 方法1if(Object.prototype.toString.call(arr) == '[object Array]') &#123;&#125;// 方法2if(Array.isArray(arr)) &#123;&#125; // 方法3if(arr.constructor == Array)&#123;&#125; // 方法4 数组方法Array.isArray(obj)检测对象是否Array,是则范湖true,否则为false.Array.from(arrayLike,mapFn,thisArg)该方法从一个类似数组或可迭代对象创建一个新的数组实例。参数 arrayLike 是想要转换成真实数组的类数组对象或可遍历对象。mapFn 是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg是可选参数，为执行 mapFn 函数时 this 的值。 所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组。 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。12345678910111213var arrayLike = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;;let arrayLike2 = &#123;length:3&#125;;let str = 'abcd';let newArray = Array.from(arrayLike); // ['a','b','c']let newArray2 = Array.from(arrayLike, (i) =&gt; &#123; i+ '1'&#125;); // ['a1','b1','c1']let newArray3= Array.from(arrayLike2); // [undefined,undefined,undefined]let newArray4= Array.from(str); // ['a','b','c','d'] Array.of(item…)该方法用于创建数组实例。该方法用于替代 Array() 或 new Array()。Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。1234Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] 数组实例方法转换方法arr.join(separator)把数组构构造成字符串，它先把数组中的每个元素转换成字符串，然后再用 separator 分隔符把它们链接在一起，separator 分隔符默认是逗号 “,”，要想做到无间隔链接，可以使用空字符串作为 separator：1234var arr = [1,2,3,4,5]arr.join('|') //"1|2|3|4|5"arr.join("") //12345//另所有对象有具有的 toLocaleString、toString、valueOf，可以看作是join的特殊用法，不常用 栈方法arr.push(item…)将一个或多个新元素添加到数组结尾，并返回数组新长度。arr.pop()移除最后一个元素并返回该元素值。 队列方法arr.unshift(item…)将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度。arr.shift()移除第一个元素并返回该元素值，数组中元素自动前移.如果这个数组是空的，它会返回 undefined。shift 通常比 pop 慢的多。 重排序方法arr.reverse()反转数组的顺序。arr.sort(compareFn)给数组排序，默认升序。 注意： sort 默认会将数组内容视为字符串来排序，所以对数字排序时默认的排序规则会错的离谱。一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数，如果两个参数相等则返回0，如果第一个参数应该排在前面则返回一个负数，如果第二个参数应该排在前面则返回一个正数：12345//数组排序var arr = [2,3,1,5,4]arr.sort(function(a, b) &#123;return a - b&#125;) // [1,2,3,4,5] 操作方法arr.concat(item…)该方法产生一份 arr 的浅复制，并将多个数组（也可以是字符串，或者是数组和字符串的混合）附加在其后连接为一个数组，返回连接好的新的数组。 arr.slice(start, end)该方法对数组中的一段做浅复制，首先复制数组 arr[start] 至 arr[end] 的部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素（或者理解成 end 的默认值为 arr.length）。字符串也有个同名方法 string.slice。 arr.splice(start, deleteCount, item…)该方法从 arr 中移除一个或多个元素，并将新的 item 插入至移除元素的开始位置， 参数 start 是移除元素的开始位置，deleteCount 是要移除的元素的个数，item 是要被插入的元素。它返回一个包含被移除元素的数组。 arr.copyWithin(target, start, end)该方法复制数组的一部分到同一数组中的另一个位置（会覆盖原成员），并返回修改后的数组。使用这个方法，会修改当前数组。参数 target 为开始替换数据的位置，若 target 大于等于 arr.length，将会不发生拷贝。start 是可选参数，为开始读取数据的位置，默认为0。end 是可选参数，为停止读取数据的位置，默认为 arr.length。12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 arr.fill(value, start, end)该方法使用给定值填充一个数组，参数 value 是用来填充数组的值。start 是可选参数，为填充开始位置，默认为 0。end 是可选参数，为填充的结束位置，默认为 arr.length。123456789101112131415161718192021[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1 , 2) // [1, 4, 3]``` fill 方法是个可变方法, 它会改变调用它的 this 对象本身, 然后返回它, 而并不是返回一个副本。##### 位置方法**arr.indexOf(searchElement,start)**该方法返回要查找的项在数组中的位置，如果没找到返回 -1。接受两个参数，searchElement 是要查找的项，start 是查找起始位置的索引，默认是0。**arr.lastIndexOf(searchElement, start)**从 start 位置开始向前查找，start 默认值为 arr.length – 1。注意该方法在比较查找项与数组中每一项时，会使用全等操作符，也就是要求查找的项必须严格相等。**arr.includes(searchElement, fromIndex)**该方法用来判断当前数组是否包含某指定的值，如果是，则返回 true，否则返回 false。参数 searchElement 为需要查找的元素值。参数 fromIndex 是可选参数，从该索引处开始查找 searchElement，如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索，默认为 0。 如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索。该方法属于ES7，但Babel转码器已经支持。```js[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。1234[NaN].indexOf(NaN)// -1[NaN].includes(NaN)// true includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。1234(function()&#123;console.log([].includes.call(arguments, 2)) // trueconsole.log([].includes.call(arguments, 4)) // false&#125;)(1,2,3) 迭代方法arr.every(callback,thisArg)对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。callback 被调用时传入三个参数：元素值，元素的索引，原数组。thisArg 为可选参数，指定执行 callback 时使用的 this 值。 arr.some(callback,thisArg)对数组中的每一项运行给定函数，如果该函数对任意一项返回true,则返回true。 arr.filter(callback,thisArg)对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 arr.forEach(callback)对数组中的每一项运行给定函数，这个函数没有返回值。本质上和使用for一样。 arr.map(callback)对数组中的每一项运行给定的函数，返回每次函数调用后结果组成的数组。 arr.find(callback,thisArg)该方法对数组所有成员依次执行callback函数，直到找出第一个返回值为true的成员并返回。如果没有，则返回undefined.1[1,2,-5,19].find((v,i,arr) =&gt; v &lt; 0) // -5 arr.findIndex(callback, thisArg)该方法与 arr.find() 类似，对数组中的成员依次执行 callback 函数，直至找到第一个返回值为 true 的成员，然后返回该成员的索引。如果没有符合条件的成员，则返回 -1。1[1, 5, 10, 15].findIndex((v, i , arr)=&gt; v &gt; 9) // 2 arr.entries()arr.keys()arr.values()这三个方法都返回一个新的Array iterator对象，可以用for...of循环进行遍历，区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。12345678910111213141516171819for (let index of ['a', 'b'].keys()) &#123; console.log(index); &#125;// 0// 1 for (let elem of ['a', 'b'].values()) &#123; console.log(elem) ;&#125;// 'a'// 'b' for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" var arr = ["a", "b";var iterator = arr.entries(); // undefined console.log(iterator); // Array Iterator &#123;&#125; console.log(iterator.next().value); // [0, "a"]console.log(iterator.next().value); // [1, "b"] 归并方法arr.reduce(callback,initialValue)arr.reduceRight(callback,initialValue)这个两个方法都会迭代数组所有的项，然后返回一个最终值。reduce()方法从数组的第一项开始，逐个遍历到最后，而reduceRight()则从数组的最后一项开始，向前遍历到第一项。它们接受两个参数，callback 每一项上调用的函数，callback 被调用时传入四个参数：上一次调用回调返回的值、正在处理的元素、正在处理的元素的索引值（如果提供了 initialValue ，从0开始；否则从1开始）、原数组。initialValue 是可选项，作为归并基础的初始值，其值用于第一次调用 callback 的第一个参数。 数组常见问题练习数组合并多个一维数组合并如有两个一维数组，要将他们合并成一个数组:1234var arr1 = [1, 2]var arr2 = [3, 4] // =&gt; [1,2,3,4] Array.prototype.concat()方法1var arr = arr1.concat(arr2) //[1, 2, 3, 4] for循环和Array.prototype.push()123456function flation(arr1, arr2) &#123; for (var i = 0; i &lt; arr2.length; i++) &#123; arr1.push(arr2[i]) &#125; return arr1&#125; reduce()或reduceRight()方法12345function flatten (arr1,arr2)&#123; arr2.reduce(function(prev,curr)&#123; return prev.push(curr); &#125;,arr1)&#125; 多维（复合）数组合并成一维数组例如有这么一组多维数组，要把它拍平成1维数组：123var myArray = [[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11]; // =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11] Array.prototype.push()方法123456789101112131415unction flatten(arr, result) &#123; if (!result) &#123; result = [] &#125; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i].constructor == Array) &#123; flatten(arr[i], r) &#125; else &#123; result.push(arr[i]) &#125; &#125; return result&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11] Array.prototype.concat()方法12345678910//省略对二维以上数组的判断function flatten(arr) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; result = result.concat(arr[i]) &#125; return result&#125;flatten([[1, 2],[3, 4, 5], [6, 7, 8, 9]]);//[1, 2, 3, 4, 5, 6, 7, 8, 9] flatten([[1, 2],[3, 4, 5], [6, 7, 8, 9],10,11]);//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 可以通过Function.prototype.apply()方法，让其变得更简单:1234//省略对二维以上数组的判断function flatten(arr) &#123; return Array.prototype.concat.apply([], arr)&#125; 在 ES6 中，还可以这样写：1234//省略对二维以上数组的判断function flatten(arr) &#123; return [].concat(...arr)&#125; 如果要处理三维或更多维数组，则需要加一些判断：123456function flatten(arr) &#123; arr = [].concat.apply([], arr) return arr.some(Array.isArray) ? flatten(arr) : arr&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])//[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10, 11] 使用join()和split()利用数组实例的join()方法和字符串实例的split()方法，也可以将多维数组拍平：12345function flatten(arr) &#123; return arr.join(',').split(',')&#125;flatten([[1, 2], [3, 4, 5], [6, 7, 8, 9], [11,12,[12,13,[14]]], 10, 11])//["1", "2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "12", "13", "14", "10", "11"] 这种方法的缺点在于返回的数组内全是字符串，如果不需要校验内容类型的话，可以使用这种方法。 数组去重双重循环去重思路： 构建一个空数组来存放去重后的数组 对原数组做循环遍历，每次从数组中取出一个元素与结果数组做对比 如果原数组取出的元素与结果数组元素相同，则跳出循环；反之则将其存放到结果数组。 1234567891011121314151617181920function unique (arr) &#123; let result = []; if(arr.length&lt;2) return; result[0] = arr[0]; for(let i = 1;i&lt;arr.length;i++)&#123; var repeat = false; for(let j= 0;j&lt;result.length;j++) &#123; if(arr[i] == result[j]) &#123; repeat = true; break; &#125; &#125; if(!repeat) &#123; result.push(arr[i]); &#125; &#125; return result;&#125;unique([1, 2, 3, 4, 3, 2, 'a', 'b', 'a']);//[1, 2, 3, 4, "a", "b"] 这种方法也可以采用forEach()方法和indexOf()方法模拟实现：123456789function unique (arr) &#123; let result = []; if(arr.length&lt;2) return; result[0] = arr[0]; arr.forEach((item) =&gt; &#123; if(!result.includes(item)) result.push(item); &#125;) return result;&#125; 排序遍历去重思路： 构建一个空数组来存放去重后的数组 用sort()方法对原数组做一个排序，排完序后对数组做遍历，检测数组中第i个元素与结果数组中的最后一个元素是否相同，如果不同，则放到结果数组中。 1234567891011function unique () &#123; arr.sort(); var result = []; arr.forEach( item =&gt; &#123; if(item !== result[result.length -1]) &#123; result.push(item); &#125; &#125;) return result;&#125;unique([1, 2, 3, 4, 3, 2, 'a', 'b', 'a']); 这种方法有两个特色： 去重后的数组会做排序，主要是因为原数在去重前做了排序 去重后的数组，与数字相同的数字字符无法区分，比如‘1’和1 对象键值对法思路： 创建一个js对象及新数组 遍历原数组，每次取出一个元素与js对象的键做对比 如果不包含，将存入对象的元素的值推入到结果数组中，并将object对象中该属性名的值设为1 12345678910111213function unique(arr) &#123; var result = [] var object = &#123;&#125; for (var i = 0; i &lt; arr.length; i++) &#123; if (!object[typeof(arr[i]) + arr[i]]) &#123; //键名里加入typeof(arr[i])是为了区别不同类型的值，如1和`1` result.push(arr[i]) object[typeof(arr[i]) + arr[i]] = 1 &#125; &#125; return result&#125;unique([1, 2, 3, 4, 3, 2, '1', 'a', 'b', 'a']);//[1, 2, 3, 4, "a", "b"] 这种方法比较耗内存，但运行下来耗时最少，是较为优秀的方案。 使用ES6的Set和Map方法12345678910111213// 借助Map数据结构function unique (arr) &#123; const seen = new Map(); return arr.filter((item) =&gt; !seen.has(item) &amp;&amp; seen.set(item,1));&#125;//借助 Set 数据结构function unique(arr) &#123; return Array.from(new Set(arr)) //或 return [...new Set(arr)]&#125; unique([1, 2, 3, 4, 3, 2, '1', 'a', 'b', 'a']);//[1, 2, 3, 4, "1", "a", "b"] 数组随机排序递归的方法思路:不断从原数组中随机取一个元素放进新数组，同时删除原数组中该值，递归重复至全部取出。1234567891011121314function randomSort(arr,newArr = []) &#123; // 如果原数组只有一个值 if(arr.length == 1) &#123; newArr.push(arr[0]); return newArr; // 递归结束 &#125;; let random = Math.ceil(Math.random()*arr.length-1); newArr.push(arr[random]); arr.splice(random,1); return randomSort(arr,newArr);&#125;randomSort([1, 2, 3, 4, 5, 6, 7]); //[2, 3, 1, 5, 6, 7, 4]randomSort([1, 2, 3, 4, 5, 6, 7]); //[3, 4, 2, 5, 1, 6, 7] 随机交换数组内的元素 (原理from underscore.js）思路：遍历数组，每次从i位置后元素随机挑一个放到i位置，将原i位置元素放至被挑元素位置12345678910Array.prototype.shuffle = function() &#123; var len = this.length, arr = this.slice(0), temp, index; for (var i = 0; i &lt; len; i++) &#123; index = i + Math.floor(Math.random() * (len - i)) [arr[i],arr[index]] = [arr[index],arr[i]]; &#125; return arr.slice(0) &#125; 随机从原数组抽取一个元素,加入到新数组思路：遍历数组，每次从数组中随机挑一个元素（随机数最大值为原数组剩余长度），将该元素拿出来放入新数组。```jsArray.prototype.shuffle = function() { var len = this.length, arr = this.slice(0), result = [], index; for (var i = 0; i &lt; len; i++) { index = Math.floor(Math.random() * (len - i)) result.push(arr.splice(index, 1)[0]) } return result;1}[1, 2, 3, 4, 5, 6, 7].shuffle()//[5, 3, 2, 1, 7, 4, 6]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深入之继承的多种方式]]></title>
    <url>%2F2018%2F02%2F26%2FJavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型链继承1234567891011121314151617function Parent () &#123; this.name = 'Jay';&#125;Parent.prototype.getName = function() &#123; console.log(this.name);&#125;function Child ()&#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()); // Jay 存在的问题：1，引用类型的属性被所有的实例共享，eg:12345678910111213141516171819function Parent () &#123; this.names = ["Jhon","Michel"];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.names.push('Lili');console.log(child1.names); // ["Jhon","Michel","Lili"]var child2 = new Child();console.log(child2.names); // ["Jhon","Michel","Lili"] 2，在创建Child的实例时，不能向Parent传参 借用构造函数（经典继承）1234567891011121314151617function Parent () &#123; this.names = ["Jhon","Michel"];&#125;function Child () &#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push('Lili');console.log(child1.names); // ["Jhon","Michel","Lili"]var child2 = new Child();console.log(child2.names); // ["Jhon","Michel"] 优点：1，避免了引用类型的属性被所有实例共享。2，可以在Child中间向Parent传参. eg:123456789101112131415function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this,name);&#125;var child1 = new Child('kaer');console.log(child1.name); // kaervar child2 = new Child('james');console.log(child2.name); // james 缺点：方法都在构造函数里定义，每次创建实例都会创建一遍方法。 组合继承原型链继承和经典继承的组合。12345678910111213141516171819202122232425function Parent (name) &#123; this.name = name; this.colors = ['red','cyan'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child (name,age) &#123; Parent.call(this,name); this.age = age;&#125;Child.prototype = new Parent();var child1 = new Child('xiaoming',20);child1.colors.push('black');console.log(child1.name,child1.age,child1.colors); // xiaoming 20 ["red", "cyan", "black"]var child2 = new Child('david',23);console.log(child2.name,child2.age,child2.colors); // david 23 ["red", "cyan"] 优点：融合原型链继承和构造函数的优点，是JavaScript中最常用的继承模式。 原型式继承12345function CreateObj (o) &#123; function F () &#123;&#125; F.prototype = o; return new F();&#125; 上面就是ES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型。缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person);var person2 = createObj(person);person1.name = 'person1';console.log(person2.name); // kevinperson1.firends.push('taylor');console.log(person2.friends); // ["daisy", "kelly", "taylor"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的name值，而是因为person1.name = ‘person1’，给person1添加了name值，并非修改了原型上的name值. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。1234567function createObj (o) &#123; var clone = object.create(o); clone.sayName = function() &#123; console.log('hi'); &#125; return clone;&#125; 缺点: 跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承组合继承最大的缺点就是虎调用两次父构造函数。一次是设置子类型实例的原型的时候：1Child.prototype = new Parent(); 一次是在创建子类型实例的时候：1var child1 = new Child('david',23); 回想下new的模拟实现，其实在这句中，我们会执行：1Parent.call(this,name); 在这里，我们又会调用了一次Parent构造函数。所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[‘red’, ‘blue’, ‘green’]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现：12345678910111213141516171819202122function Parent (name) &#123; this.name = name; this.colors = ['red','cyan'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child (name,age) &#123; Parent.call(this,name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var Child1 = new Child('david',23);console.log(child1); 最后封装一下这个函数方法：1234567891011121314function object(o) &#123; functin F () &#123;&#125; F.prototype = o; return new F();&#125;function prototype (child,parent) &#123; var prototype = object(parent.prototype); prototype.constructor = child; child.prototype = prototype;&#125;// 当我们使用的时候prototype(Child,Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握JavaScript面试基础3]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%803%2F</url>
    <content type="text"><![CDATA[new关键字如果使用new关键字来调用函数式很特别的形式。我们把那些用new调用的函数叫做构造函数(constructor function)。 使用了new的函数到底做了什么事情呢？ 创建一个新的对象 将对象的prototype设置为构造函数的prototype 执行构造函数，this执行新构造的对象 返回该对象。如果构造函数返回对象，那么返回该构造对象。 123456// 为了更好地理解底层，我们来定义new关键字function myNew(constructor, ...arguments) &#123; var obj = &#123;&#125; Object.setPrototypeOf(obj, constructor.prototype); return constructor.apply(obj, arguments) || obj&#125; 使用new和不使用的区别在哪里呢？123456789function Bird() &#123; this.wings = 2;&#125;/* 普通的函数调用 */let fakeBird = Bird();console.log(fakeBird); // undefined/* 使用new调用 */let realBird= new Bird();console.log(realBird) // &#123; wings: 2 &#125; 为了便于对比理解，译者额外增加了测试了一种情况：1234567function MBird()&#123; this.wings =2; return "hello";&#125;let realMBrid = new MBird();console.log(realMBird) // &#123; wings: 2 &#125; 你会发现，这一句return “hello”并没有生效！ 原型和继承原型(Prototype)是JavaScript中最容易搞混的概念，其中一个原因是prototype可以用在两个不同的情形下。 原型关系每一个对象都有一个prototype对象，里面包含了所有它的原型的属性。.__proto__是一个不正规的机制(ES6中提供)，用来获取一个对象的prototype。你可以理解为它指向对象的parent。所有普通的对象都继承.constructor属性，它指向该对象的构造函数。当一个对象通过构造函数实现的时候，__proto__属性指向构造函数的构造函数的.prototype。Object.getPrototypeOf()是ES5的标准函数，用来获取一个对象的原型。 原型属性每一个函数都有一个.prototype属性，它包含了所有可以被继承的属性。该对象默认包含了指向原构造函数的.constructor属性。每一个使用构造函数创建的对象都有一个构造函数属性。 接下来通过例子来帮助理解：1234567891011121314151617181920212223function Dog(breed, name)&#123; this.breed = breed, this.name = name&#125;Dog.prototype.describe = function() &#123; console.log(`$&#123;this.name&#125; is a $&#123;this.breed&#125;`)&#125;const rusty = new Dog('Beagle', 'Rusty');/* .prototype 属性包含了构造函数以及构造函数中在prototype上定义的属性。*/console.log(Dog.prototype) // &#123; describe: ƒ , constructor: ƒ &#125;/* 使用Dog构造函数构造的对象 */console.log(rusty) // &#123; breed: "Beagle", name: "Rusty" &#125;/* 从构造函数的原型中继承下来的属性或函数 */console.log(rusty.describe()) // "Rusty is a Beagle"/* .__proto__ 属性指向构造函数的.prototype属性 */console.log(rusty.__proto__) // &#123; describe: ƒ , constructor: ƒ &#125;/* .constructor 属性指向构造函数 */console.log(rusty.constructor) // ƒ Dog(breed, name) &#123; ... &#125; 原型链原型链是指对象之间通过prototype链接起来，形成一个有向的链条。当访问一个对象的某个属性的时候，JavaScript引擎会首先查看该对象是否包含该属性。如果没有，就去查找对象的prototype中是否包含。以此类推，直到找到该属性或则找到最后一个对象。最后一个对象的prototype默认为null。 拥有vs继承一个对象有两种属性，分别是它自身定义的和继承的。123456789101112131415function Car() &#123; &#125;Car.prototype.wheels = 4;Car.prototype.airbags = 1;var myCar = new Car();myCar.color = 'black';/* 原型链中的属性也可以通过in来查看: */console.log('airbags' in myCar) // trueconsole.log(myCar.wheels) // 4console.log(myCar.year) // undefined/* 通过hasOwnProperty来查看是否拥有该属性: */console.log(myCar.hasOwnProperty('airbags')) // false — Inheritedconsole.log(myCar.hasOwnProperty('color')) // true Object.create(obj) 创建一个新的对象，prototype指向obj。123456var dog = &#123; legs: 4 &#125;;var myDog = Object.create(dog);console.log(myDog.hasOwnProperty('legs')) // falseconsole.log(myDog.legs) // 4console.log(myDog.__proto__ === dog) // true 继承是引用传值继承属性都是通过引用的形式。看例子：1234567891011var objProt = &#123; text: 'original' &#125;;var objAttachedToProt = Object.create(objProt);console.log(objAttachedToProt.text) // original// 我们更改objProt的text属性，objAttachedToProt的text属性同样更改了objProt.text = 'prototype property changed';console.log(objAttachedToProt.text) // prototype property changed// 但是如果我们讲一个新的对象赋值给objProt，那么objAttachedToProt的text属性不受影响objProt = &#123; text: 'replacing property' &#125;;console.log(objAttachedToProt.text) // prototype property changed 异步JavaScriptJavaScript是一个单线程程序语言，也就是说JavaScript引擎一次只能执行某一段代码。它导致的问题就是：如果有一段代码需要耗费很长的时间执行，其它的操作就被卡住了。JavaScript使用Call Stack来记录函数的调用。一个Call Stack可以看成是一摞书。最后一本书放在最上面，也最先被移走。最先放的书在最底层，最后被移走。 为了避免复杂代码占用CPU太长时间，一个解法就是定义异步回调函数。我们自己来定义一个异步函数看看：1234567function greetingAsync(name, callback)&#123; let greeting = "hello, " + name ; setTimeout(_ =&gt; callback(greeting),0);&#125;greetingAsync("fundebug", console.log);console.log("start greeting"); 我们在greetingAsync中构造了greeting语句，然后通过setTimeout定义了异步，callback函数，是为了让用户自己去定义greeting的具体方式。为方便起见，我们时候直接使用console.log。 上面代码执行首先会打印start greeting，然后才是hello, fundebug。也就是说，greetingAsync的回调函数后执行。在网站开发中，和服务器交互的时候需要不断地发送各种请求，而一个页面可能有几十个请求。如果我们一个一个按照顺序来请求并等待结果，串行的执行会使得网页加载很慢。通过异步的方式，我们可以先发请求，然后在回调中处理请求结果，高效低并发处理。 下面通过一个例子来描述整个执行过程：123456789101112131415161718const first = function () &#123; console.log('First message')&#125;const second = function () &#123; console.log('Second message')&#125;const third = function() &#123; console.log('Third message')&#125;first();setTimeout(second, 0);third();// 输出: // First message // Third message // Second message 初始状态下，浏览器控制台没有输出，并且事件管理器(Event Manager)是空的； first()被添加到调用栈 将console.log(“First message”)加到调用栈 console.log(“First message”)执行并输出“First message”到控制台 console.log(“First message”)从调用栈中移除 first()从调用栈中移除 setTimeout(second, 0)加到调用栈 setTimeout(second, 0)执行，0ms之后，second()被加到回调队列 setTimeout(second, 0)从调用栈中移除 third()加到调用栈 console.log(“Third message”)加到调用栈 console.log(“Third message”)执行并输出“Third message”到控制台 console.log(“Third message”)从调用栈中移除 third()从调用栈中移除 Event Loop 将second()从回调队列移到调用栈 console.log(“Second message”)加到调用栈 console.log(“Second message”)Second message”到控制台 console.log(“Second message”)从调用栈中移除 Second()从调用栈中移除 特别注意的是：second()函数在0ms之后并没有立即执行，你传入到setTimeout()函数的时间和second()延迟执行的时间并不一定直接相关。事件管理器等到setTimeout()设置的时间到期才会将其加入回调队列，而回调队列中它执行的时间和它在队列中的位置以及它前面的函数的执行时间有关。 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握JavaScript面试基础2]]></title>
    <url>%2F2018%2F02%2F21%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[闭包闭包由一个函数以及该函数定义式所在的环境组成。12345678910function sayHi(name)&#123; var message = `Hi $&#123;name&#125;`; function greeting() &#123; console.log(message); &#125; return greeting();&#125;var sayHiToJon = sayHi('Jon');console.log(sayHiToJon) // ƒ() &#123; console.log(message) &#125;console.log(sayHiToJon()) // 'Hi Jon!' 请理解var sayHiToJon=sayHi(&#39;Jon&#39;);这段代码的执行过程，sayHi函数执行，首先将message的值计算出来，然后定义了greeting函数，函数中引用了message变量，最后，返回greeting函数。如果按照C/Java语言的思路，sayHiToJon就等价于greeting函数，那么就会报错：message为定义。但是在JavaScript中不一样，这里的sayHiToJon函数等于greeting函数以及一个环境，该环境中包含了message。因此，当我们调用sayHiToJon函数，可以成功将message打印出来。因此，这里的闭包就是greeting函数和一个包含message变量的环境。 闭包的一个优势在于数据隔离，下面用一个例子说明：123456789101112131415function SpringfieldSchool() &#123; let staff = ['Seymour Skinner', 'Edna Krabappel']; return &#123; getStaff: function() &#123; console.log(staff) &#125;, addStaff: function(name) &#123; staff.push(name) &#125; &#125;&#125;let elementary = SpringfieldSchool()console.log(elementary) // &#123; getStaff: ƒ, addStaff: ƒ &#125;console.log(staff) // ReferenceError: staff is not defined/* Closure allows access to the staff variable */elementary.getStaff() // ["Seymour Skinner", "Edna Krabappel"]elementary.addStaff('Otto Mann')elementary.getStaff() // ["Seymour Skinner", "Edna Krabappel", "Otto Mann"] 在elementary被创建的时候，SpringfieldSchool已经返回。也就是说staff无法被外部访问。唯一可以访问的方式就是里面的闭包函数getStaff和addStaff。 我们来看一个面试题：下面的代码有什么问题，如何修复？123456const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; setTimeout(function() &#123; console.log(`The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;`); &#125;, (i+1) * 1000);&#125; 上面的代码输出的结果全部都一样：”The value undefined is at index: 4”。因为所有在setTimeout中定义的匿名函数都引用了同一个外部变量i。当匿名函数执行的时候，i的值为4。 这个问题可以改用IIFE(后面会介绍)方法来解决，通过对每一个匿名函数构建独立的外部作用域来实现。12345678const arr = [10, 12, 15, 21];for (var i = 0; i &lt; arr.length; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(`The value $&#123;arr[j]&#125; is at index: $&#123;j&#125;`); &#125;, j * 1000); &#125;)(i)&#125; 当然，还有一个方法，使用let来声明i。123456const arr = [10,20,30,40];for(let i = 0;i&lt;arr.length;i++) &#123; setTimeout(function()&#123; console.log('The value $&#123;arr[i]&#125; is at index: $&#123;i&#125;') &#125;,(i)*1000)&#125; 立即调用的函数表达式(Immediate Invoked Function Expression)(IIFE)一个IIFE是一个函数表达式在定义之后立即被调用。常用在你想对一个新声明的变量创建一个隔离的作用域。它的格式为:(function(){....})()。前面的大括号用于告诉编译器这里不仅仅是函数定义，后面的大括号用于执行该函数。123456789101112131415var result = [];for (var i=0; i &lt; 5; i++) &#123; result.push( function() &#123; return i &#125; );&#125;console.log( result[1]() ); // 5console.log( result[3]() ); // 5result = [];for (var i=0; i &lt; 5; i++) &#123; (function () &#123; var j = i; // copy current value of i result.push( function() &#123; return j &#125; ); &#125;)();&#125;console.log( result[1]() ); // 1console.log( result[3]() ); // 3 使用IIFE可以： 为函数绑定私有数据 创建一个新的环境 避免污染全局命名空间 环境（Context）我们往往容易将环境（Context）和作用域（Scope）搞混，解释一下： 环境（Context）：由函数如何被调用而决定，往往指this. 作用域（Scope）：可访问的变量。 函数调用：call, apply, bind这三个方法都是为了将this绑定到函数，区别在于调用的方式。 .call(a,b,c,d…)会理解执行函数，需要把参数按照顺序传入； .apply([a,b,c,d…])会理解执行函数，需要把参数组合成数组传入了； .call()和.apply()几乎相同。哪个传入参数方便，你就选择哪个。12345678910const Snow = &#123;surename: 'Snow'&#125;const char = &#123; surename: 'Stark', knows: function(arg, name) &#123; console.log(`You know $&#123;arg&#125;, $&#123;name&#125; $&#123;this.surename&#125;`); &#125;&#125;char.knows('something', 'Bran'); // You know something, Bran Starkchar.knows.call(Snow, 'nothing', 'Jon'); // You know nothing, Jon Snowchar.knows.apply(Snow, ['nothing', 'Jon']); // You know nothing, Jon Snow 注意：如果你将数组传入call函数，它会认为只有一个参数。 ES6允许使用新的操作符将数组变换为一个序列。1char.knows.call(Snow, ...["nothing", "Jon"]); // You know nothing, Jon Snow .bind()返回一个新的函数，以及相应的环境和参数。如果你想该函数稍后调用，那么推荐使用bind。.bind()函数的优点在于它可以记录一个执行环境，对于异步调用和事件驱动的编程很有用。 .bind()传参数的方式和call相同。12345678const Snow = &#123;surename: 'Snow'&#125;const char = &#123; surename: 'Stark', knows: function(arg, name) &#123; console.log(`You know $&#123;arg&#125;, $&#123;name&#125; $&#123;this.surename&#125;`);&#125; &#125;const whoKnowsNothing = char.knows.bind(Snow, 'nothing');whoKnowsNothing('Jon'); // You know nothing, Jon Snow this关键字要理解JavaScript中this关键字，特别是它指向谁，有时候相当地复杂。this的值通常由函数的执行环境决定。简单的说，执行环境指函数如何被调用的。this像是一个占位符(placeholder)，它指向当方法被调用时，调用对应的方法的对象。 下面有序地列出了判断this指向的规则。如果第一条匹配，那么就不用去检查第二条了。 new绑定当使用new关键字调用函数的时候，this指向新构建的对象(实例)。123456function Person(name,age)&#123; this.name = name; this.age = age; console.log(this);&#125;const = Rachel = new Person('Rachel',30); // &#123;name: 'Rachel',age: 30&#125; 显示绑定(Explicit binding)当使用call或则apply的时候，我们显示的传入一个对象参数，该参数会绑定到this。 注意：.bind()函数不一样。用bind定义一个新的函数，但是依然绑定到原来的对象。12345678function fn() &#123; console.log(this);&#125;var agent = &#123;id: '007'&#125;;fn.call(agent); // &#123; id: '007' &#125;fn.apply(agent); // &#123; id: '007' &#125;var boundFn = fn.bind(agent);boundFn(); // &#123; id: '007' &#125; 隐式绑定当一个函数在某个环境下调用(在某个对象里)，this指向该对象。也就是说该函数是对象的一个方法。1234567var building = &#123; floors: 5, printThis: function() &#123; console.log(this); &#125;&#125;building.printThis(); // &#123; floors: 5, printThis: function() &#123;…&#125; &#125; 默认绑定如果上面所有的规则都不满足，那么this指向全局对象(在浏览器中，就是window对象)。当函数没有绑定到某个对象，而单独定义的时候，该函数默认绑定到全局对象。1234function printWindow() &#123; console.log(this)&#125;printWindow(); // window object 注意：下面的情况中，inner函数中的this指向全局。12345678910function Dinosaur(name) &#123; this.name = name; var self = this; inner(); function inner() &#123; alert(this); // window object — the function has overwritten the 'this' context console.log(self); // &#123;name: 'Dino'&#125; — referencing the stored value from the outer context &#125;&#125;var myDinosaur = new Dinosaur('Dino'); 词法(Lexical) this当是使用=&gt;来定义函数时，this指向定义该函数时候外层的this。备注：大概是和定义的词法(=&gt;)有关，把它称作Lexical this。123456function Cat(name) &#123; this.name = name; console.log(this); // &#123; name: 'Garfield' &#125; ( () =&gt; console.log(this) )(); // &#123; name: 'Garfield' &#125;&#125;var myCat = new Cat('Garfield'); 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速掌握JavaScript面试基础1]]></title>
    <url>%2F2018%2F02%2F20%2F%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[类型和类型转换在JavaScript中有7个内置类型：null,undefined,boolean,number,string,object和symbol（ES6)。 除了object以外，其他都叫做基本类型。123456typeof 0 //numbertypeof true // booleantypeof 'abc' // stringtypeof null // objecttypeof undefined // undefinedtypeof Symbol('Hi') // symbol Null vs. Undefined Undefined表示未定义。对于没有初始化的变量，函数调用时未提供的函数参数，不存在的对象属性，它们的默认值就是undefined。如果一个函数没有返回语句，那么默认的返回值也是undefined。 Null表示值为空。一个变量我们可以将其赋值为null,表示当前没有值。 隐式转换 1234var name = 'Joey';if (name) &#123; console.log(name + " doesn't share food!") // Joey doesn’t share food!&#125; 在if语句的条件判断中，name从字符串转换为布尔型。在if的代码块中，在控制台将name原原本本打印出来。你知道在什么情况下字符串会转换为真，什么时候为假么？ &quot;&quot;，0， null，undefined, NaN, false 会自动转换为false。其它的都会转换为真：123456Boolean(null) // falseBoolean('hello') // true Boolean('0') // true Boolean(' ') // true Boolean([]) // true Boolean(function()&#123;&#125;) // true 空数组、对象、函数定义都会自动转换为真。 String &amp; Number之间的转换 第一个你要非常小心的是+操作符。因为它同时用于数字相加和字符串拼接。 *,/,-只用于数字运算，当这些操作符和字符串一起使用，那么字符串会被强制转换为数字。12345678910111 + "2" = "12""" + 1 + 0 = "10""" - 1 + 0 = -1"-9\n" + 5 = "-9\n5""-9\n" - 5 = -14"2" * "3" = 64 + 5 + "px" = "9px""$" + 4 + 5 = "$45""4" - 2 = 2"4px" - 2 = NaNnull + 1 = 1 == vs. === 一个广泛被接受的认知就是：==判断值是否相等，===同时判断值是否相等和类型是否相同。但是，这里有些误解。 实际上，==在验证相等性的时候，会对类型不同的值做一个类型转换。===对要判断的值不做类型转换。12342 == '2' // True2 === '2' // Falseundefined == null // Trueundefined === null // False 类型转换有很多取巧的地方，要注意：12345678let a = '0';console.log(Boolean(a)); // Truelet b = false;console.log(Boolean(b)); // False``` 你认为下面的相等判断会输出什么值呢?```jsconsole.log(a == b); 实际上会返回true。知道为什么吗？ 如果你将一个布尔类型的和非布尔类型的判断，JavaScript会将布尔类型的转换为数字然后再比对。执行过程如下：123'0' == false (1)'0' == 0 (2) 0 == 0 (3) 所以，最终变成了0==0，当然返回true啦。 一些比较容易掉坑的比较，我在这里列出来：123456789false == "" // truefalse == [] // truefalse == &#123;&#125; // false"" == 0 // true"" == [] // true"" == &#123;&#125; // false0 == [] // true0 == &#123;&#125; // false0 == null // false 值 vs. 引用对于基本类型的值，赋值是通过值拷贝的形式；比如：null，undefined，boolean，number，string和ES6的symbol。对于复杂类型的值，通过引用拷贝的形式赋值。比如：对象、对象包括数组和函数。1234567891011121314var a = 2; // 'a' hold a copy of the value 2.var b = a; // 'b' is always a copy of the value in 'a'b++;console.log(a); // 2console.log(b); // 3var c = [1,2,3];var d = c; // 'd' is a reference to the shared valued.push( 4 ); // Mutates the referenced value (object)console.log(c); // [1,2,3,4]console.log(d); // [1,2,3,4]/* Compound values are equal by reference */var e = [1,2,3,4];console.log(c === d); // trueconsole.log(c === e); // false 如果想对复杂类型的值进行值拷贝，你需要自己去对所有子元素进行拷贝。1234const copy = c.slice() // 'copy' 即使copy和c相同，但是copy指向新的值console.log(c); // [1,2,3,4]console.log(copy); // [1,2,3,4]console.log(c === copy); // false 作用域（Scope）作用域是程序的执行环境，它包含了在当前位置可访问的变量和函数。 全局作用域是最外层的作用域，在函数外面定义的变量属于全局作用域，可以被任何其他子作用域访问。在浏览器中，window对象就是全局作用域。 局部作用域是在函数内部的作用域。在局部作用域定义的变量只能在该作用域以及其子作用域被访问。123456789101112131415function outer() &#123; let a = 1; function inner() &#123; let b = 2; function innermost() &#123; let c = 3; console.log(a, b, c); // 1 2 3 &#125; innermost(); console.log(a, b); // 1 2 — 'c' is not defined &#125; inner(); console.log(a); // 1 — 'b' and 'c' are not defined&#125;outer(); 你可以将作用域想象成一系列不断变小的门。如果一个个子不高的人可以穿过最小的门(局部最小作用域)，那么必然可以穿过任何比它大的门(外部作用域)。 提升(Hoisting)在编译过程中，将var和function的定义移动到他们作用域最前面的行为叫做提升。 整个函数定义会被提升。所以，你可以在函数还未定义之前调用它，而不用担心找不到该函数。12345console.log(toSquare(3)); // 9function toSquare(n)&#123; return n*n;&#125; 变量只会被部分提升。而且只有变量的声明会被提升，赋值不会动。 let和const不会被提升。1234567891011121314151617181920212223&#123; /* Original code */ console.log(i); // undefined var i = 10 console.log(i); // 10&#125;&#123; /* Compilation phase */ var i; console.log(i); // undefined i = 10 console.log(i); // 10&#125;// ES6 let &amp; const&#123; console.log(i); // ReferenceError: i is not defined const i = 10 console.log(i); // 10&#125;&#123; console.log(i); // ReferenceError: i is not defined let i = 10 console.log(i); // 10&#125; 函数表达式和函数声明 函数表达式 一个函数表达式是在函数执行到函数表达式定义的位置才开始创建，并被使用。它不会被提升。123var sum = function(a, b) &#123; return a + b;&#125; 函数声明 函数声明的函数可以在文件中任意位置调用，因为它会被提升。123function sum(a, b) &#123; return a + b;&#125; 变量：var，let和const在ES6之前，只能使用var来声明变量。在一个函数体中声明的变量和函数，周围的作用域内无法访问。在块作用域if和for中声明的变量，可以在if和for的外部被访问。 注意：如果没有使用var,let或则const关键字声明的变量将会绑定到全局作用域上。1234567891011function greeting() &#123; console.log(s) // undefined if(true) &#123; var s = 'Hi'; undeclaredVar = 'I am automatically created in global scope'; &#125; console.log(s) // 'Hi'&#125;console.log(s); // Error — ReferenceError: s is not definedgreeting();console.log(undeclaredVar) // 'I am automatically created in global scope' ES6的let和const都是新引入的关键字。它们不会被提升，而且是块作用域。也就是说被大括号包围起来的区域声明的变量外部将不可访问。123456789101112let g1 = 'global 1'let g2 = 'global 2'&#123; /* Creating a new block scope */ g1 = 'new global 1' let g2 = 'local global 2' console.log(g1) // 'new global 1' console.log(g2) // 'local global 2' console.log(g3) // ReferenceError: g3 is not defined let g3 = 'I am not hoisted';&#125;console.log(g1) // 'new global 1'console.log(g2) // 'global 2' 一个常见的误解是：使用const声明的变量，其值不可更改。准确地说它不可以被重新赋值，但是可以更改。12345678910111213const tryMe = 'initial assignment';tryMe = 'this has been reassigned'; // TypeError: Assignment to constant variable.// You cannot reassign but you can change it…const array = ['Ted', 'is', 'awesome!'];array[0] = 'Barney';array[3] = 'Suit up!';console.log(array); // [“Barney”, “is”, “awesome!”, “Suit up!”]const airplane = &#123;&#125;;airplane.wings = 2;airplane.passengers = 200;console.log(airplane); // &#123;passengers: 200, wings: 2&#125; 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之原型和原型链]]></title>
    <url>%2F2018%2F02%2F08%2FJavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[构造函数创建对象我们先使用构造函数创建一个对象：123456function Person() &#123;&#125;var person = new Person();person.name = 'lili';console.log(person.name); // lili 在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。 prototype每一个函数都有一个prototype属性，就是我们经常在各种例子中看到那个prototype,比如：1234567891011function Person() &#123;&#125;/***虽然写在注释了，但是要注意：prototype是函数才会有的属性*/Person.prototype.name = 'Jay';var person1 = new Person();var person2 = new Person();console.log(person1.name); // jayconsole.log(person2.name); // jay 那这个函数的prototype属性到底指向的是什么呢？ 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的person1和person2的原型。 那什么是原型呢？可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。 让我们用一张图表示构造函数和实例原型之间的关系：在这张图中我们用的Object.prototype表示实例原型。 那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢？ __proto__这是每一个JavaScript对象（null除外）都具有的一个属性，叫__proto__，这个属性会指向该对象的原型，证明如下：12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 更新关系图：既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就是第三个属性: constructor，每个原型都有一个constructor属性指向关联的构造函数。1234function Person() &#123;&#125;console.log(Person === Object.prototype.constructor); 再更新关系图：综上所述:123456789function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // trueconsole.log(Person.prototype.constructor = Person); // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype); // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系。 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。举个例子：123456789101112function Person()&#123;&#125;Person.prototype.name = 'jay';var person = new Person();person.name = 'John';console.log(person.name); // Johndelete person.name;console.log(person.name); // jay 在这个例子中，我们给实例对象person添加了name属性，当我们打印person.name的时候，结果自然为John。 但是当我们删除了person的name属性时，读取person.name,从person对象中找不到name属性就会从person的原型也就是person.__proto__,也就是Person.prototype中查找，幸运的是我们找打name属性，结果为jay。 但是万一没找到呢，原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，那我们就可以用最原始的方式创建它：123var obj = new Object();obj.name = 'Kevin';console.log(obj.name); // Kevin 其实原型对象就是通过Object构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的prototype,所以载更新关系图： 原型链那Object.prototype的原型呢？null, 我们可以打印：1console.log(Object.prototype.__proto__ === null); // true 然而null究竟代表了什么呢？ null代表’没有对象’，即该处不该有值。 所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充constructor首先是constructor属性，例子：12345function Person () &#123;&#125;var person = new Person();console.log(person.constructor == Person); // true 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有这个属性，所以：1person.constructor = Person.prototype.constructor __proto__其次是__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性的说法， 引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建了一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和方法，所以与其叫继承，委托的说法反而更准确些。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域整理]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是跨域？ 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。 下面是具体的跨域情况详解：123456789101112131415161718192021222324URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 这里我们需要注意两点: 如果是协议和端口造成的跨域问题“前台”是无能为力的； 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。) 通过document.domain跨域 前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是www.damonare.cn/a.html ， 在这个页面里面有一个iframe，它的src是damonare.cn/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的： 123456789&lt;script type="text/javascript"&gt; function test()&#123; var iframe = document.getElementById('ifame'); var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt; 这个时候，document.domain就可以派上用场了，我们只要把www.damonare.cn/a.html和damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 在页面www.damonare.cn/a.html中设置document.domain:1234567&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//设置成主域 function test()&#123; alert(document.getElementById('iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 在页面damonare.cn/b.html中也设置document.domain:123&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 修改document.domain的方法只适用于不同子域的框架间的交互。 通过location.hash跨域 因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。 假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。1, a.html传送数据到b.html a.html下修改iframe的src为google.com/b.html#paco b.html监听到url发生变化，触发相应操作 2, b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”www.baidu.com/proxy.html#…” proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash） a.html监听到url发生变化，触发相应操作 b.html页面的关键代码如下:123456789try &#123; parent.location.hash = 'data'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = "http://www.baidu.com/proxy.html#data"; document.body.appendChild(ifrproxy); &#125; proxy.html页面的关键代码如下 :12//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值 parent.parent.location.hash = self.location.hash.substring(1); 通过HTML5的postMessage方法跨域 高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。 比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。 A页面通过postMessage方法发送消息：12345window.onload = function () &#123; var ifr = document.getElementById('ifr'); var targetOrigin = 'http://www.google.com'; ifr.contentWindow.postMessage('hello',targetOrigin);&#125; postMessage的使用方法： otherWindow.postMessage(message, targetOrigin); otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames属性的成员或者由window.open方法创建的窗口 message:是要发送的消息，类型为String、Object(IE8、9 不支持)targetOrigin:是限定消息接收范围，不限制请使用 ‘*’ B页面通过message事件监听并接受消息:12345678910111213var onmessage = function (ev)&#123; var data = ev.data; // 消息 var origin = ev.origin; // 消息来源地址 var source = ev.source; // 源window对象 if(origin == 'http://www.baidu.com') &#123; console.log(data); // hello &#125;&#125;if(window.addEventListener != 'undefined') &#123; window.addEventListener('message',onmessage,false);&#125;else if(window.attachEvent != 'undefined') &#123; // ie window.attachEvent('message',onmessage);&#125; 同理，也可以B页面发送消息，然后A页面监听并接受消息。 通过jsonp跨域 刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。 比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是damonare.cn/data.php, 那么a.html中的代码就可以这样：123456&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; 我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。 因为是当做一个js文件来引入的，所以damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦):12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; 最终，输出结果为：dosomething([‘a’,’b’,’c’]); 如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。12345&lt;script type="text/javascript"&gt; $.getJSON('http://example.com/data.php?callback=?,function(jsondata)')&#123; //处理获得的json数据 &#125;);&lt;/script&gt; jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 JSONP的优缺点： JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 通过CORS跨域 CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 平时的ajax请求可能是这样的：12345&lt;script type='text/javascript'&gt; var xhr = XMLHttpRequest(); xhr.open('GET','/getSomething',true); xhr.send();&lt;/script&gt; 以上getSomething部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：12345&lt;script type='text/javascript'&gt; var xhr = XMLHttpRequest(); xhr.open('GET','http://jaybein.site/getSomething',true); xhr.send();&lt;/script&gt; 代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：跨域资源共享CORS详解]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对缓存的一点理解]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。 缓存的种类很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。 缓存好处有很多： 缓解服务器压力(不用每次去请求资源)； 提升性能(打开本地资源速度当然比请求回来再打开要快得多)； 减少带宽消耗(我相信你可以理解)； 浏览器的缓存策略缓存的目标: 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应； 不变的重定向: 响应状态码：301； 可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox； 错误响应: 响应状态码：404 的一个页面； 不完全的响应: 响应状态码 206，只返回局部的信息； 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应； 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。例如：1234567Age:23146Cache-Control:max-age=2592000Date:Tue, 28 Nov 2017 12:26:41 GMTETag:W/&quot;5a1cf09a-63c6&quot;Expires:Thu, 28 Dec 2017 05:27:45 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 强缓存阶段以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，Expires是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。Cache-Control:max-age=2592000是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，max-age &gt; Expires。 这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️ Firefox浏览器表现为一个灰色的200状态码。 Chrome浏览器状态码表现为:1200 (from disk cache)或是200 OK (from memory cache) 多说一点：关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 协商缓存阶段那么当这个CSS文件过期了怎么办?ETag和Last-Modified就该闪亮登场了。 先说Last-Modified，这个字段是文件最后一次修改的时间； ETag呢？ETag是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑 具体两个字段携带的内容如下(分别和上面的Last-Modified、ETag携带的值对应)：12If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMTIf-None-Match: W/&quot;5a1cf09a-63c6&quot; 到这协商缓存结束。 启发式缓存阶段我们把上面的响应头改下：12345Age:23146Cache-Control: publicDate:Tue, 28 Nov 2017 12:26:41 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带If-Moified-Since呗，不是的，浏览器还有个启发式缓存阶段。 根据响应头中2个时间字段Date和Last-Modified之间的时间差值，取其值的10%作为缓存时间周期。 这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种默认缓存的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。下面用一张图，来解释浏览器整个缓存策略的过程：对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。 传送门]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript:彻底理解同步、异步和事件循环（Event Loop）]]></title>
    <url>%2F2018%2F02%2F06%2FJavaScript-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。 同步与异步在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？ 同步如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 如下所示：1234//在函数返回时，获得了预期值，即2的平方根Math.sqrt(2);//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'console.log('hello'); 上面两个函数就是同步的。如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。 异步如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 如下所示：123456789//读取文件fs.readFile('hello.txt', 'utf8', function(err, data) &#123; console.log(data);&#125;);//网络请求var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open('GET', url);xhr.send(); // 发起函数 上述示例中读取文件函数 readFile和网络请求的发起函数 send都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在JavaScript中通过回调函数function(err, data) { console.log(data); }和 onreadystatechange，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行JavaScript代码的线程执行回调。 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。 单线程与多线程在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？ JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。 浏览器目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。一个浏览器通常由以下几个常驻的线程： 渲染引擎线程：顾名思义，该线程负责页面的渲染 JS引擎线程：负责JS的解析和执行 定时触发器线程：处理定时事件，比如setTimeout, setInterval 事件触发线程：处理DOM事件 异步http请求线程：处理http请求 需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。 JS引擎通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。 JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤： 词法分析：将源代码分解为有意义的分词 语法分析：用语法分析器将分词解析成语法树 代码生成：生成机器能运行的代码 代码执行 不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。 之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。 所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。 消息队列与事件循环通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？ 这一切的解释就需要继续了解消息队列和事件循环。 如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。 右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。 JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。 JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。 上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。 从上文中我们也可以得到这样一个明显的结论，就是： 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 宏队列和微队列宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括： script setTimeout setInterval setImmediate (Node独有) requestAnimationFrame (浏览器独有) I/O UI rendering (浏览器独有) 微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括： process.nextTick (Node独有) Promise Object.observe MutationObserver （注：这里只针对浏览器和NodeJS） 浏览器的Event Loop 这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程： 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）； 全局Script代码执行完毕后，调用栈Stack会清空； 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1； 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空； 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行； 执行完毕后，调用栈Stack为空； 重复第3-7个步骤； 重复第3-7个步骤； …… 可以看到，这就是浏览器的事件循环Event Loop这里归纳3个重点： 宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务； 微任务队列中所有的任务都会被依次取出来执行，直到microtask queue为空； 图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。 示例引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。 执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？ 12345678910111213141516171819202122232425setTimeout(function()&#123; for(var i = 0; i &lt; 100000000; i++)&#123;&#125; console.log('timer a');&#125;, 0)for(var j = 0; j &lt; 5; j++)&#123; console.log(j);&#125;setTimeout(function()&#123; console.log('timer b');&#125;, 0)function waitFiveSeconds()&#123; var now = (new Date()).getTime(); while(((new Date()).getTime() - now) &lt; 5000)&#123;&#125; console.log('finished waiting');&#125;document.addEventListener('click', function()&#123; console.log('click');&#125;)console.log('click begin');waitFiveSeconds(); 要想了解上述代码的输出结果，首先介绍下定时器。 setTimeout的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，所以间隔的时间一般会大于等于指定的时间。 setTimeout(fn, 0)的意思是，将回调函数fn立刻插入消息队列，等待执行，而不是立即执行。看一个例子： 123456setTimeout(function() &#123; console.log("a")&#125;, 0)for(let i=0; i&lt;10000; i++) &#123;&#125;console.log("b") 1b a 打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。 理解了定时器的作用，那么对于输出结果就容易得出了。 首先，先执行同步任务。其中waitFiveSeconds是耗时操作，持续执行长达5s。123456701234click beginfinished waiting 然后，在JS引擎线程执行的时候，&#39;timer a&#39;对应的定时器产生的回调、 &#39;timer b&#39;对应的定时器产生的回调和两次click对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。1234clickclicktimer atimer b 最后，5s 后的两次click事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。12clickclick 异步与事件上文中说的“事件循环”，为什么里面有个事件呢？那是因为： 消息队列中的每条消息实际上都对应着一个事件。 上文中一直没有提到一类很重要的异步过程：DOM事件。举例说明：1234var button = document.getElement('#btn');button.addEventListener('click',function(e)&#123; console.log('lalla');&#125;) 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 总结一下最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。 这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些. 参考文章：JavaScript 运行机制详解：再谈Event Loop 传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之字符串的扩展]]></title>
    <url>%2F2017%2F09%2F01%2FES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[字符串的遍历器接口ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// "f"// "o"// "o" includes(),startsWith(),endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" 参数如果是小数，会被取整。1'na'.repeat(2.9) // "nana" 如果repeat的参数是负数或者Infinity，会报错。1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。1'na'.repeat(-0.9) // "" 参数NaN等同于0。如果repeat的参数是字符串，则会先转换成数字。12'na'.repeat('na') // ""'na'.repeat('3') // "nanana" padStart()，padEnd()ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串传统的JavaScript语言，输出模板通常是这样写的。123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串(template string)是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 模板字符串中嵌入变量，需要将变量名写在${}之中。123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// "3" 模板字符串之中还能调用函数。123456function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。123// 变量place没有声明let msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。12`Hello $&#123;'World'&#125;`// "Hello World" 模板字符串甚至还能嵌套。12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // "Hello Jack!"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // "Hello Jack!"]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之变量的解构赋值]]></title>
    <url>%2F2017%2F08%2F28%2FES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。以前，为变量赋值，只能直接指定值。123let a = 1;let b = 2;let c = 3; ES6允许写成下面这样。1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。1let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 与数组一样，解构也可以用于嵌套结构的对象。12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 对象的解构也可以指定默认值。123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。1let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 用途变量的解构赋值用途很多。 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据解构赋值对提取JSON对象中的数据，尤其有用。12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历Map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 原文地址]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之let和const]]></title>
    <url>%2F2017%2F08%2F25%2FES6%E5%85%A5%E9%97%A8%E4%B9%8Blet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为JavaScript新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。ES6 允许块级作用域的任意嵌套。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。const的作用域与let命令相同：只在声明所在的块级作用域内有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const声明的常量，也与let一样不可重复声明。 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常见的几种轮播]]></title>
    <url>%2F2017%2F08%2F15%2FJavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。首先奉上轮播图 无缝不停轮播body布局:123456789&lt;div class="container"&gt; &lt;!--将ul和li包住,起显示图片的作用--&gt; &lt;ul&gt; &lt;li&gt;![](img/img1.png)&lt;/li&gt; &lt;li&gt;![](img/img2.png)&lt;/li&gt; &lt;li&gt;![](img/img3.png)&lt;/li&gt; &lt;li&gt;![](img/img4.png)&lt;/li&gt; &lt;li&gt;![](img/img1.png)&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css样式：1234567891011121314151617181920212223242526*&#123; margin: 0; padding: 0;&#125;.container&#123; position: relative; /*给要动的元素也就是ul 它的父级加上相对定位*/ width: 600px; height: 400px; overflow: hidden; /*给要动的元素也就是ul 它的父级加上溢出隐藏*/&#125;.container &gt; ul&#123; position: absolute; /*给要动的元素也就是ul 加上绝对定位,才能保证用left和top;*/ width: 3000px; /*ul 的宽度为 li 的个数 * li 的宽度*/ height:100%; list-style: none;&#125;.container &gt; ul &gt;li&#123; float: left; width: 600px; height: 100%;&#125;.container &gt; ul &gt;li img&#123; width: 100%; height: 100%;&#125; JS代码:1234567891011var ul = document.querySelector(".container &gt; ul"); //获取ulsetTimeout(function step()&#123; //设置定时器 if(ul.offsetLeft&lt;=-2400)&#123; //判断:若ul走到倒数第二张图的时候,让left从0开始运行 ul.style.left=0+'px'; &#125;else&#123; var left = ul.offsetLeft -3; //给ul设置速度 ul.style.left=left+'px'; &#125; var time = 10; //设定一个时间,以控制其轮播的速度 setTimeout(step,time); //定时器内部调用定时器&#125;,0) 无缝停顿轮播 停顿轮播在不停轮播的基础上加以改进,判断当ul走到li宽度的倍数时,让定时器的时间加大,就可以起到停顿的效果 ​body布局以及css样式不变 js代码：12345678910111213141516var ul = document.querySelector(".container &gt; ul"); //获取ulsetTimeout(function step()&#123; //设置定时器 if(ul.offsetLeft&lt;=-2400)&#123; //判断:若ul走到倒数第二张图的时候,让left从0开始运行 ul.style.left = 0 +'px'; &#125;else&#123; speed = -3; //给ul设置速度 &#125; var time; if(ul.offsetLeft%600==0)&#123; //做判断:当ul走到li宽度的倍数时 time = 3000; //设定一个很大的时间,也就是很小的速度 &#125;else&#123; time = 10; &#125; ul.style.left=ul.offsetLeft+speed+'px'; setTimeout(step,time); //定时器内部调用定时器&#125;,0) 无缝停顿反向轮播 反向轮播在停顿轮播的基础上加以改进,判断当ul最左边和ul走到最右边,将速度反向;将最后一张重复的li去掉并修改ul的宽度 123456789101112131415var ul = document.querySelector(".container &gt; ul");var speed = 3;setTimeout(function step()&#123; if(ul.offsetLeft&lt;=-1800||ul.offsetLeft&gt;=0)&#123; //判断当ul最左边和ul走到最右边,将速度反向; speed*=-1; &#125; var time = 0; if(ul.offsetLeft%600==0)&#123; //做判断:当ul走到li宽度的倍数时 time = 3000; //设定一个很大的时间,也就是很小的速度 &#125;else&#123; time=10; &#125; ul.style.left=ul.offsetLeft+speed+'px'; setTimeout(step,time); //定时器内部调用定时器&#125;,0) 透明度普通轮播​1.body布局上一样;​2.css样式:将所有li 绝对定位,重叠在一起​3.JS:先获取到ul 和 li 并对 li的数组进行遍历 赋值每个的opacity​注:要在js中遍历li 再给它赋值opacity,而不是在css中直接设置属性是为了在js中好获取到opacity并给它进行修改设置123456789101112131415161718192021222324var ul = document.querySelector(".container &gt; ul"); //获取ulvar lis = document.querySelectorAll('.container &gt; ul &gt;li');var i = 0;for(var i=0;i&lt;lis.length;i++)&#123; if(i==0)&#123; //默认显示第一张图,让其透明度为1; lis[i].style.opacity=1; &#125;else&#123; //其他图片透明度为0; lis[i].style.opacity=0; &#125;&#125;var i=0; //重新赋值i var time = 50; //设置时间,控制图片转换的速度,时间越大,速度越慢setTimeout(function step()&#123; //设置定时器 lis[i%4].style.opacity-=0.05; lis[(i+1)%4].style.opacity=parseFloat(lis[(i+1)%4].style.opacity)+0.05; if(lis[i%4].style.opacity==0)&#123; i++; time = 1000; &#125;else&#123; time =50 &#125; setTimeout(step,time);&#125;,0) 透明度指示器轮播body布局:123456789101112131415161718192021222324&lt;div class="container"&gt; &lt;ul id="picture"&gt; &lt;!--轮播图片区--&gt; &lt;li&gt;![](img/img1.jpg)&lt;/li&gt; &lt;li&gt;![](img/img2.jpg)&lt;/li&gt; &lt;li&gt;![](img/img3.jpg)&lt;/li&gt; &lt;li&gt;![](img/img4.jpg)&lt;/li&gt; &lt;li&gt;![](img/img5.jpg)&lt;/li&gt; &lt;li&gt;![](img/img6.jpg)&lt;/li&gt; &lt;/ul&gt; &lt;ul class="arrow"&gt; &lt;!--左右切换--&gt; &lt;li class="arrowLeft"&gt;&lt;/li&gt; &lt;li class="arrowRight"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="bottom"&gt; &lt;!--指示器--&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li style="margin:0"&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; css样式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586* &#123; margin: 0; padding: 0;&#125;.container &#123; /*整体样式*/ position: relative; width: 600px; height: 400px; overflow: hidden; margin: 20px auto;&#125;.container &gt; .picture &#123; /*轮播图片区样式*/ position: absolute; width: 600px; height: 100%; list-style: none;&#125;.container &gt; .picture &gt; li &#123; position: absolute; width: 600px; height: 100%;&#125;.container &gt; .picture &gt; li img &#123; width: 100%; height: 100%;&#125;.container &gt; .arrow&#123; /*左右切换区样式*/ position: absolute; height: 70px; width: 100%; top: 40%; left: 0; list-style: none;&#125;.container &gt; .arrow &gt; li &#123; width: 40px; height: 70px; padding: 0; margin: 0; cursor: pointer;&#125;.container &gt; .arrow &gt; li:nth-child(1) &#123; float: left; background: url("img/arrow_left1.png");&#125;.container &gt; .arrow &gt; li:nth-child(2) &#123; float: right; background: url("img/arrow_right1.png");&#125;.container &gt; .arrow &gt; li:nth-child(1):hover &#123; background: url("img/arrow_left2.png");&#125;.container &gt; .arrow &gt; li:nth-child(2):hover &#123; background: url("img/arrow_right2.png");&#125;.container .bottom &#123; /*指示器样式*/ position: relative; margin: 0 auto; width: 215px; height: 40px; top: 350px; border-radius: 20px; background-color: grey;&#125;.container &gt; .bottom &gt; ul&#123; position: absolute; height: 30px; width: 205px; bottom: 20px; list-style: none; top: 5px; left: 5px;&#125;.container &gt; .bottom &gt; ul &gt; li&#123; float: left; height: 100%; width: 30px; margin: 0 5px 0 0; padding: 0; border-radius: 50%; background-color: white; font-size: 20px; line-height: 30px; text-align: center; cursor: pointer;&#125; js代码：​代码分析: 先进行准备工作, 利用for循环将初始化的图片透明度已经指示器的背景色设定好 给整个container添加事件,当鼠标上来的时候,让自动播放停止 给左,右”按钮” 点击事件,用以切换上一张下一张图片; 给指示器onmouseenter事件,使得图片与你的指示器同步,达到随意切换图片的效果; 定义 图片切换的函数 ,使得以上事件都可以调用它 定义自动播放的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var container = document.querySelector('.container');var pictureLis = document.querySelectorAll('.container &gt; .picture &gt; li');var optionLis = document.querySelectorAll('.container &gt; .bottom &gt;ul &gt; li');var arrowLeft = document.querySelector('.container .arrow &gt; .arrowLeft');var arrowRight = document.querySelector('.container .arrow &gt; .arrowRight');var showIndex = 0; //当前正在显示的图片的下标//初始化function init() &#123; for (var j = 0; j &lt; pictureLis.length; j++) &#123; if (j == 0) &#123; optionLis[j].style.backgroundColor='red'; pictureLis[j].style.opacity = 1; &#125; else &#123; pictureLis[j].style.opacity = 0; &#125; &#125; //给整个container添加事件,当鼠标上来的时候,让自动播放停止 container.onmouseenter = function () &#123; clearTimeout(autoPlayId); &#125;; container.onmouseleave = function () &#123; auto(); &#125;; //给左按钮和右按钮添加点击事件 arrowLeft.onclick=function()&#123; optionLis[showIndex % optionLis.length].style.backgroundColor='white'; var preIndex = showIndex-1+pictureLis.length; move(showIndex,preIndex); showIndex=preIndex; optionLis[showIndex%optionLis.length].style.backgroundColor='red'; &#125;; arrowRight.onclick=function()&#123; optionLis[showIndex % optionLis.length].style.backgroundColor='white'; move(showIndex,showIndex+1); showIndex++; optionLis[showIndex%optionLis.length].style.backgroundColor='red'; &#125;; //给指示器添加onmouseenter事件,使得图片与指示器同步 for(let i=0;i&lt;optionLis.length;i++)&#123; optionLis[i].onmouseenter=function()&#123; move(showIndex,i); optionLis[showIndex%optionLis.length].style.backgroundColor='white'; optionLis[i%optionLis.length].style.backgroundColor='red'; showIndex=i; &#125; &#125;&#125;init(); //调用初始化//图片移动function move(showIndex,nextIndex) &#123; setTimeout(function step() &#123; pictureLis[showIndex % pictureLis.length].style.opacity -= 0.05; pictureLis[nextIndex % pictureLis.length].style.opacity = +pictureLis[nextIndex % pictureLis.length].style.opacity + 0.05; if (pictureLis[showIndex % pictureLis.length].style.opacity &lt;= 0||pictureLis[nextIndex%pictureLis.length].style.opacity&gt;=1) return; setTimeout(step, 5) &#125;, 0)&#125;//自动播放var autoPlayId; //自动播放定时器idfunction auto() &#123; autoPlayId = setTimeout(function autoStep() &#123; optionLis[showIndex].style.backgroundColor = "white"; move(showIndex,showIndex+1); //切换下一张图片 showIndex++; if (showIndex == pictureLis.length) showIndex = 0; optionLis[showIndex%optionLis.length].style.backgroundColor = "red"; autoPlayId = setTimeout(autoStep,2000); &#125;, 2000)&#125;auto();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现圣杯布局和双飞翼布局]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%AE%9E%E7%8E%B0%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[背景利用浮动特性可以实现一些布局，比较经典的有个圣杯布局，后来经过改进又出现了双飞翼布局，下面就来介绍一下这两种布局。先看一下效果图：三栏式圣杯布局demo三栏式双飞翼布局demo两种布局基本原理是相似的，而且双飞翼布局是圣杯布局的基础上改进而来，所以先介绍圣杯布局。 圣杯布局1.总体上看上、中、下三个部分，一般写三组&lt;div&gt;&lt;/div&gt;标签，当然也可以采用html5的标签。2.所谓布局都是在中间部分做文章，有几个要求：第一最中间部分宽度是不定的；第二：俩侧边栏宽度是定的3.为达目的，我们肯定要采用浮动，但是有个诀窍：此处html结构中中间部分要先写，所以html结构是下面这样的1234567&lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="main"&gt; &lt;div class="content"&gt;三栏式圣杯布局&lt;/div&gt; &lt;div class="aside"&gt;定宽左侧边栏&lt;/div&gt; &lt;div class="extra"&gt;定宽右侧栏&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt; 4.此时的问题是用css控制各块到各自位置上。简单的办法是使用负margin，这个负margin的原理是盒子模型的算法，想一下：1内容+padding+border+margin 这个公式里如果有一个负值，总和会怎么变，占据宽度空间会怎么变。当我们给一个div加上左负margin自然这个区块就向左位移了。思考一下就知道如果我们给俩边栏设置的都是float:left属性，则需要左侧边栏向左位移一整个父容器的宽度，右侧边栏则向左位移一个自身宽度。1234567891011121314.aside &#123; float:left; margin-left:-100%; width: 200px; min-height: 40px; background-color: red;&#125;.extra &#123; float:right; margin-left:-100%; width:200px; min-height: 40px; background-color: yellow;&#125; 仔细看一下代码，会发现右边栏的处理和之前说的不一样，原因就不解释 了，其实只要合理设置css可以有不同方法达到目的。5.现在就剩下最后一步，俩侧边栏虽已经和中间主题内容处于同一行，但是肯定不能遮挡要平移到对应位置上。直接给父元素加个padding，俩侧边栏使用一个相对定位移到padding区域就搞定了。1234567891011#main &#123; padding: 0 200px; &#125;.aside &#123; position: relative; left: -200px;&#125;.extra &#123; position: relative; right: -200px;&#125; 至此，圣杯布局就完成了。 双飞翼布局双飞翼布局和圣杯布局的区别只是换一种思路解决中间元素被遮挡问题，主要想法就是在外侧加一个div占据位置，俩侧边栏占据margin位置。所以直接看代码。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .mid &#123; float: left; width: 100%; &#125; .mid .mid-content &#123; min-height: 80px; min-width: 20px; background-color: green; margin-left:200px; margin-right:200px; &#125; .aside &#123; float: left; width: 200px; min-height: 60px; background-color: yellow; margin-left: -100%; &#125; .extra &#123; float: left; width: 200px; min-height: 60px; background-color: blue; margin-left:-200px; &#125; &lt;/style&gt; &lt;head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div class="mid"&gt; &lt;div class="mid-content"&gt;三栏式双飞翼布局中间自适应&lt;/div&gt; &lt;/div&gt; &lt;div class="aside"&gt;侧边栏定宽&lt;/div&gt; &lt;div class="extra"&gt;右侧定宽&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上就是圣杯布局和双飞翼布局。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的10个重点及难点]]></title>
    <url>%2F2017%2F07%2F15%2FJavaScript%E7%9A%8410%E4%B8%AA%E9%87%8D%E7%82%B9%E5%8F%8A%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[立即执行函数立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：1234(function() &#123; // 代码 // ...&#125;)(); function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。 闭包对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。123456789101112131415function f1()&#123; var N = 0; // N是f1函数的局部变量 function f2()&#123; // f2是f1函数的内部函数，是闭包 N += 1; // 内部函数f2中使用了外部函数f1中的变量N console.log(N); &#125; return f2;&#125;var result = f1();result(); // 输出1result(); // 输出2result(); // 输出3 代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！ 使用闭包定义私有变量通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName("Fundebug");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出Fundebug 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 prototype每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。1234567891011121314151617function Rectangle(x, y)&#123; this._length = x; this._breadth = y;&#125;Rectangle.prototype.getDimensions = function()&#123; return &#123; length: this._length, breadth: this._breadth &#125;;&#125;;var x = new Rectangle(3, 4);var y = new Rectangle(4, 3);console.log(x.getDimensions()); // &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125; 代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。 模块化JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及Fundebug都是这样实现的。123456789101112131415161718192021var module = (function() &#123; var N = 5; function print(x) &#123; console.log("The result is: " + x); &#125; function add(a) &#123; var x = a + N; print(x); &#125; return &#123; description: "This is description", add: add &#125;;&#125;)();console.log(module.description); // 输出"this is description" module.add(5); // 输出“The result is: 10” 所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。 变量提升JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。 但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：123console.log(y); // 输出undefinedvar y = 2; // 初始化y 上面的代码等价于下面的代码：12345var y; // 声明yconsole.log(y); // 输出undefinedy = 2; // 初始化y 为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。 柯里化柯里化，即Currying，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。12345678910111213var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11 代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。 apply, call与bind方法JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。 三者之中，call方法是最简单的，它等价于指定this值调用函数：1234567891011121314var user = &#123; name: "Rahul Mhatre", whatIsYourName: function() &#123; console.log(this.name); &#125;&#125;;user.whatIsYourName(); // 输出"Rahul Mhatre",var user2 = &#123; name: "Neha Sampat"&#125;;user.whatIsYourName.call(user2); // 输出"Neha Sampat" apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定： apply(thisArg, [argsArray]) call(thisArg, arg1, arg2, …) 12345678910111213var user = &#123; greet: "Hello!", greetUser: function(userName) &#123; console.log(this.greet + " " + userName); &#125;&#125;;var greet1 = &#123; greet: "Hola"&#125;;user.greetUser.call(greet1, "Rahul"); // 输出"Hola Rahul"user.greetUser.apply(greet1, ["Rahul"]); // 输出"Hola Rahul" 使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：123456789101112var user = &#123; greet: "Hello!", greetUser: function(userName) &#123; console.log(this.greet + " " + userName); &#125;&#125;;var greetHola = user.greetUser.bind(&#123;greet: "Hola"&#125;);var greetBonjour = user.greetUser.bind(&#123;greet: "Bonjour"&#125;);greetHola("Rahul") // 输出"Hola Rahul"greetBonjour("Rahul") // 输出"Bonjour Rahul" MemoizationMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。1234567891011121314151617181920function memoizeFunction(func)&#123; var cache = &#123;&#125;; return function()&#123; var key = arguments[0]; if (cache[key])&#123; return cache[key]; &#125;else&#123; var val = func.apply(this, arguments); cache[key] = val; return val; &#125; &#125;;&#125;var fibonacci = memoizeFunction(function(n)&#123; return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;);console.log(fibonacci(100)); // 输出354224848179262000000console.log(fibonacci(100)); // 输出354224848179262000000 代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。 函数重载所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if...else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。 从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。 难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。 由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。 根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function addMethod(object, name, f)&#123; var old = object[name]; object[name] = function()&#123; // f.length为函数定义时的参数个数 // arguments.length为函数调用时的参数个数 if (f.length === arguments.length)&#123; return f.apply(this, arguments); &#125;else if (typeof old === "function")&#123; return old.apply(this, arguments); &#125; &#125;;&#125;// 不传参数时，返回所有namefunction find0()&#123; return this.names;&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++)&#123; if (this.names[i].indexOf(firstName) === 0)&#123; result.push(this.names[i]); &#125; &#125; return result;&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++)&#123; if (this.names[i] === (firstName + " " + lastName))&#123; result.push(this.names[i]); &#125; &#125; return result;&#125;var people = &#123; names: ["Dean Edwards", "Alex Russell", "Dean Tom"]&#125;;addMethod(people, "find", find0);addMethod(people, "find", find1);addMethod(people, "find", find2);console.log(people.find()); // 输出["Dean Edwards", "Alex Russell", "Dean Tom"]console.log(people.find("Dean")); // 输出["Dean Edwards", "Dean Tom"]console.log(people.find("Dean", "Edwards")); // 输出["Dean Edwards"] 传送门~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典前端面试题(JavaScript)]]></title>
    <url>%2F2017%2F07%2F12%2F%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript%2F</url>
    <content type="text"><![CDATA[写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉123var reg = /(&lt;\w+&gt;)|(&lt;\/\w+&gt;)/gi;var str = '&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;';alert(str.replace(reg,"")); 编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？123456789101112131415161718192021var str = 'asdfssaaasasasasaa';function findMaxAppearChar () &#123; var arr = str.split(''); var obj = &#123;&#125;; var maxKey = ''; var maxIndex = 0; for( var i = 0; i &lt; arr.length; i++ ) &#123; if( obj[ arr[i] ] )&#123; obj[ arr[i] ] += 1; &#125;else&#123; obj[ arr[i] ] = 1; &#125; &#125; for( key in obj ) &#123; if(obj[key] &gt; maxIndex) &#123; maxKey = key; maxIndex = obj[key]; &#125; &#125; return ('出现最多字符是' + maxKey + ',一共出现了' + maxIndex + "次");&#125; 闭包是什么? 有什么特性? 对页面有什么影响?(1)闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.(2)闭包有什么特性:通过闭包,可以提供私有作用域.函数执行完后,内部不会释放通过闭包,可以实现带有存储函数运行时变量的函数.(3)对页面有什么影响:大量使用闭包会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 写一个reverseStr函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’1234var str = '12345678';function reverseStr (str) &#123; return str.split('').reverse().join('');&#125; 将数字 12345678 转化成 RMB形式 如： 12,345,678123456789101112function formatNumberToRMB ( number ) &#123; var str = number + ''; var arr = str.split('').reverse(); //[8,7,6,5,4,3,2,1] var resultArr = []; for( var i = 0; i &lt; arr.length; i++ ) &#123; resultArr.push( arr[i] ); if( (i + 1) % 3 == 0 &amp;&amp; (i + 1) != arr.length )&#123; resultArr.push(','); &#125; &#125; return resultArr.reverse().join('');&#125; 请写一个阻止冒泡的兼容函数12345678function stopPropagation ( e ) &#123; e = window.event ? window.event : e; if( e.stopPropagation ) &#123; e.stopPropagation(); &#125;else&#123; e.cancelBubble = true; &#125;&#125; 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序123456789function getSortedRandomNumber () &#123; var arr = []; for( var i = 0; i &lt; 10; i++ ) &#123; arr.push( Math.floor( Math.random() * 90 ) + 10 ); &#125; return arr.sort(function ( a, b ) &#123; return a - b; &#125;)&#125;; 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}123456789101112131415function getQueryJson ( URLstr ) &#123; var queryIndex = URLstr.indexOf('?') + 1; var queryStr = URLstr.slice( queryIndex ); //a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e var arr = queryStr.split( '&amp;' ); //[ a=1, b=2, c=, d=xxx, e ] var obj = &#123;&#125;; var resultArr = []; for( var i = 0; i &lt; arr.length; i++ ) &#123; var tempArr = arr[ i ].split( '=' ); obj[ tempArr[0] ] = tempArr[1]; &#125; for( var key in obj )&#123; resultArr.push( '"' + key + '"' + ':' + '"' + obj[ key ] + '"' ); &#125; return '&#123;' + resultArr.join(',') + '&#125;'; //&#123;"a":"1","b":"2","c":"","d":"xxx","e":"undefined"&#125;&#125;; 写一个function，清除字符串前后的空格。（兼容所有浏览器）12345if( typeof String.prototype.trim !== 'function' ) &#123; String.prototype.trim = function( ) &#123; return this.replace ( /^\s*|\s*$/g, '' ); &#125;&#125; 获取页面所有的checkbox12345678var resultArr= [];var input = document.querySelectorAll('input');for( var i = 0; i &lt; input.length; i++ ) &#123; if( input[i].type == 'checkbox' ) &#123; resultArr.push( input[i] ); &#125;&#125;//resultArr即中获取到了页面中的所有checkbox 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”123456789101112function getCamelCase ( str ) &#123; var arr = str.split("-"); var resultArr = []; for( var i = 0; i &lt; arr.length; i++ )&#123; if( i === 0 ) &#123; resultArr.push( arr[i] ); &#125;else&#123; resultArr.push( arr[i].charAt( 0 ).toUpperCase() + arr[i].slice( 1 ) ); &#125; &#125; return resultArr.join('');&#125; 移动端边框1像素问题新项目中 -&gt; viewport + rem 实现 同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。在devicePixelRatio = 2 时，输出viewport： 1&lt;meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"&gt; 在devicePixelRatio = 3 时，输出viewport：1&lt;meta name="viewport" content="initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no"&gt; 在旧项目中 -&gt; 伪类 + transform 实现 原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。单条border样式设置： 12345678910111213141516.scale-1px&#123; position: relative; border:none;&#125;.scale-1px:after&#123; content: ''; position: absolute; bottom: 0; background: #000; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125; 四条boder样式设置: 1234567891011121314151617181920.scale-1px&#123; position: relative; margin-bottom: 20px; border:none;&#125;.scale-1px:after&#123; content: ''; position: absolute; top: 0; left: 0; border: 1px solid #000; -webkit-box-sizing: border-box; box-sizing: border-box; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top;&#125; 最好在使用前也判断一下，结合 JS 代码，判断是否 Retina 屏： 123if(window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2)&#123; document.querySelector('ul').className = 'scale-1px';&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你走进Gulp]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9BGulp%2F</url>
    <content type="text"><![CDATA[Gulp是一款前端自动化构建工具。通俗的来说，就是你本来需要很多条指令才可以完成的事情，通过Gulp你可能只需要一条指令。 Gulp是什么鬼首先，我很确定它不是鬼。对于之前接触过Webpack的人来说，很大的一个疑惑可能就是：这两者有什么区别？因为Webpack几乎能做全部我们需要做的事情，Gulp存在的意义是什么？我只能说：存在即合理。Gulp貌似是一款取代Grunt的工具，我没有去了解过Grunt，可能是因为没时间，而且好像也不是很有必要。Gulp的核心功能是自动化任务流程，简化操作。比如你需要做打包、编译、压缩、合并等一些乱七八糟的事情，不用Gulp，你可能需要一步一步的“自己”来，而有了Gulp，你预先将这些乱七八糟的事情定义好交给Gulp，然后在特定时刻，Gulp自动将这些事情全都做了。而Webpack的核心功能应该是集中在模块管理上，不过它同样可以通过各种插件，做很多事情。过于纠结这两者的区别也没什么必要。Gulp简单，学起来也就一两天的事。Webpack相对要复杂很多，而且对于新手也有很多坑，但不可忽略它确实很强大。这里的建议是，都学一下，毕竟这是现在最火的两款开发工具。 很重要的几个概念Gulp不算复杂，去官网也就那么一丁点儿的介绍，所以学习之前有必要先知道一些概念。 配置文件（gulpfile.js）Gulp既然是一款工具，就得做一些事情，具体要做些什么，还得由我们来指定。在哪里指定，就是在它的配置文件gulpfile.js中，该文件位于项目的根目录下。以后所有Gulp相关的配置语句都是写在gulpfile.js文件中。 任务（Task）Gulp把需要做的一些事情定义成一个个的任务，每一个任务都有一个名字，然后通过命令调用这个任务的名字，就可以执行该任务对应的代码。如下：12345678910111213// gulpfile.js 文件中var gulp = require('gulp');// style 任务gulp.task('style', function () &#123; // 一些要做的事情&#125;);// build 任务gulp.task('build', function () &#123; // 要做的事情 &#125;); 插件前面定义的都是一些空任务，啥也不会做。因为Gulp本身不会做任何“事情”，它只负责把那些要做的事情准备（分类、串联）好。具体谁来做，那就是插件。 Gulp有很多插件，几乎能满足你的各种需求。我想对于初学者来说有个疑问：我怎么知道我需要的插件叫什么？那么，我在这里先列出一些插件。我也不知道这些是不是常用的插件，不过看起来好像比较常用。*gulp-connect：可以跑一个本地服务器，貌似现在应该不会有人直接将index.html拖到浏览器来调试吧； gulp-concat：看清了，这是concat，用来合并文件的； gulp-clean：删除文件用的； gulp-rename：重命名文件； gulp-minify-html：压缩html用的； gulp-inject：可以将css样式和js脚本文件插入到html文件中； gulp-minify-css：压缩css； gulp-uglify：压缩js； gulp-imagemin：压缩图片； gulp-postcss：自动添加css中的前缀，很实用的家伙。 就这些吧，看清楚长啥样就好了。正如你看到的那样，Gulp所有的插件都是以gulp-开头。对于那些有点经验的人来说，要什么插件可能一般都是直接去npm或github上搜索。对于不知道怎么搜的（一般都是不知道关键词），就老老实实百度吧。一个很好的习惯就是平时多记录和总结，因为很多插件在不同的工具和平台中，叫法基本上都是一样的。另外，这里还给一个官方收录的插件列表。 具体使用方法Gulp的安装就不说了，需要的直接看看这里。先举一个栗子（玩玩）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 引入gulp，无需解释var gulp = require('gulp');// 引入插件var connect = require('gulp-connect')， sass = require('gulp-sass')， uglify = require('gulp-uglify');// 定义任务gulp.task('server', function () &#123; // 使用 connect 插件创建一个服务器 connect.server(&#123; // 这里是传入的一些配置项 root: 'dist', livereload: true &#125;)&#125;);gulp.task('style', function () &#123; // 匹配资源文件 gulp.src('./src/**/*.scss') // 对匹配到的 文件 传到一个插件中 .pipe(sass(&#123; // 用sass插件处理 匹配到的文件 // 插件的配置项 outputStyle: 'compressed' // 插件的功能 打印错误信息 &#125;).on('error', sass.logError)) // 串联 将sass处理后的文件 传送到下一个插件中 // 将文件 输出到指定目录下 .pipe(gulp.dest('dist')) // 重新加载 服务器 .pipe(connect.reload());&#125;);gulp.task('script', function () &#123; gulp.src('./src/**/*.js') .pipe(uglify()) .pipe(gulp.dest('dist')) .pipe(connect.reload());&#125;);// 默认任务 要等到数组中的任务执行完之后 才执行gulp.task('default', ['style', 'script', 'server'], function () &#123; // 监听 匹配到的文件是否改变 // 一旦变化就执行 数组 中的任务 gulp.watch('./src/js/*.js', ['script']); gulp.watch('./src/css/*.scss', ['style']);&#125;); Gulp的基本使用大概就这些，gulpfile.js文件大概就是这个样子的。对于该配置文件，命令行只需执行一条语句：1gulp 没错，就这样！该指令会自动执行默认的任务。如果要指定具体的任务，后面直接跟上任务名即可，比如：1gulp server 如何使用插件一般典型的用法就是直接将插件传入.pipe函数中，插件的配置项通过一个对象传入插件中：1.pipe(uglify()) 一般若没有特殊要求，可以省略配置项。gulp.src()和.pipe()都会返回一个叫Vinyl files的stream（我也不知道是个什么鬼），所以这些方法是可以串联起来的。 谈几个API这里列出一些比较常用的API接口，详细用法请参阅官方文档 gulp.src：匹配文件用的； gulp.dest：输出文件到指定目录； gulp.task：定义一个任务； gulp.watch：监听文件，改动触发。 好像就这四个？我也是刚发现，还说列几个常用的。所以学起来还是很容易的，不过要全部学通，可能也要花一点时间。反正我是没有认真把官网的文档看完，尽管它一点也不长。我的想法是，掌握基本的使用方法和思想，有实际需求的时候再去参考官方文档。（关键是我现在没这反面的需求啊） 文件匹配原则好像这家伙不是按照常规的正则去匹配的，官方给出了一个参考，有兴趣的自己看看，反正我没看。直接举几个栗子吧： *：能匹配abc.js，a.css，不能匹配a/bc.js； **：能匹配a.js，a/b/cd/d.css； *.*：能匹配aaa.js，b.css； a/**/*.js：能匹配a/b/c/d/ef.js，a/b/c.js。 还要说明一点，语句gulp.dest(&#39;dist&#39;)中的dist表示在项目根目录下生成dist目录。输出的文件路径是*号匹配到的文件名（未被修改的情况下），上面例子中输出的目录结构是这样的：12345678910111213// 假设原文件路径- src - css - a.scss - js - b.js// 输出的文件路径- dist - css - a.css - js - b.js 默认情况下，dist只会替换*号之前的路径，当然也可以自己修改，具体自行参阅官方文档 传送门]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印样式CSS的技巧和要点]]></title>
    <url>%2F2017%2F07%2F09%2F%E6%89%93%E5%8D%B0%E6%A0%B7%E5%BC%8FCSS%E7%9A%84%E6%8A%80%E5%B7%A7%E5%92%8C%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[不经过任何处理而直接打印网站上的页面会得到一个不理想的效果。 我们WEB开发人员可以简单采用几个要点来使之达到较为合适的效果： 使用响应式布局设置打印的效果 在合适的时候打印背景图片和颜色 添加显示的网址或页面链接，以供参考 使用css filter 提高打印的图形效果 针对打印的样式，而不是屏幕显示样式首先，我们需要使用媒体查询（media query）针对打印样式设置。123@media print &#123; // write some styles&#125; 重新针对打印写CSS样式是没有必要的，我们只需要针对差异设置打印的样式覆盖掉之前的默认样式。 大多数的浏览器会自动根据打印更改颜色，以节省打印原料，但是我们还是尽可能的手工设置一下。 为了达到最佳效果，使颜色清晰明了，我们至少需要包含一下基本的打印样式。1@media print &#123; body &#123; color: #000; background: #fff; &#125; &#125; 对于打印，大多数情况下我们不需要打印整个页面，只需要打印一个简洁的能够突出需要信息的页面，那么我们将不相关的部分隐藏掉（如：导航条、背景图片）。1234567891011121314151617/* Default styles */h1 &#123; color: #fff; background: url(banner.jpg);&#125;@media print &#123; h1 &#123; color: #000; background: none; &#125; nav, aside &#123; display: none; &#125;&#125; 在编写打印样式表的时候，你要注意要使用厘米(cm),英寸(inch)或者磅(pt)作为单位而不是屏幕像素单位，实际的单位对打印非常有用。 为了保证打印样式有用，写CSS样式使打印的内容距离纸张边缘，看起来更好，需要使用 @page 这个语法：1234567891011121314151617181920@media print &#123; h1 &#123; color: #000; background: none; &#125; nav, aside &#123; display: none; &#125; body, article &#123; width: 100%; margin: 0; padding: 0; &#125; @page &#123; margin: 2cm; &#125;&#125; 为了保证不被跨页打印，如一个标题和内容在页面底部被分开：1h2, h3 &#123; page-break-after: avoid; &#125; 另一种情况是要防止图片过宽而超出纸张边缘：123img &#123; max-width: 100% !important;&#125; 第三个要点是确保 articles 文章标签的内容，在新的一页开始：123article &#123; page-break-before: always;&#125; 最后，还要注意列表和图片不被分开在不同的页：123ul, img &#123; page-break-inside: avoid;&#125; 背景图片和颜色对于一些网站，颜色和背景图还是非常必要需要遵循的。如果用户是在 webkit 内核浏览器上打印的话，我们可以强制打印机打印屏幕上所看到的颜色（即强制在打印页面上出现任何的背景图和颜色），一般来说彩色打印机可以做到这点，我们需要一个单独的媒体查询：123456@media print and (color) &#123; * &#123; -webkit-print-color-adjust: exact; print-color-adjust: exact; &#125;&#125; 遗憾的是，这不能马上应用于firefox opera 和IE. 传送门~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你豁然开朗的AJAX和JSONP]]></title>
    <url>%2F2017%2F07%2F07%2F%E8%AE%A9%E4%BD%A0%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97%E7%9A%84AJAX%E5%92%8CJSONP%2F</url>
    <content type="text"><![CDATA[先说说JSONP是怎么产生的：1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有src这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）； 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP的客户端具体实现：1.我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。假设远程服务器上有一个remote.js文件，可以使用以下方式调用：12//remote.jsalert('我是远程文件'); 1234567891011//jsonp.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;addScript&lt;/title&gt; &lt;script src='remote.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行以后可以看到一个弹出框：我是远程文件，说明跨域调用成功。 2.现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。12345678910111213141516//jsonp.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;addScript&lt;/title&gt; &lt;script type="text/javascript"&gt; let localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;; &lt;/script&gt; &lt;script src='remote.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 12//remote.jslocalHandler(&#123;"result":"我是远程js带来的数据"&#125;); 运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。1234567891011121314151617181920//jsonp.html&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;html lang="en"&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 let flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 '+data.price + ' 元，'+'余票 ' + data.tickets + ' 张。'); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） let url = "flightResult.aspx?code=CA1998&amp;callback=flightHandler"; // 创建script标签，设置其属性 let script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.js的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：1flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "remote.js?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？ 补充： 这里针对ajax与jsonp的异同再做一些补充说明：1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ 传送门~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析let/const在for循环中的作用原理]]></title>
    <url>%2F2017%2F07%2F01%2F%E5%89%96%E6%9E%90let-const%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、先来看一个例子123456var a=[]; for(var i = 0;i&lt;3;i++)&#123; a[i]=function()&#123;console.log(i)&#125; &#125;a[1](); //3a[2](); //3 2、再来看一下For循环的过程1234567for (语句 1; 语句 2; 语句 3)&#123; 被执行的代码块&#125;// 语句 1 在循环（代码块）开始前执行// 语句 2 定义运行循环（代码块）的条件// 语句 3 在循环（代码块）已被执行之后执行 3、例子for循环执行过程伪代码如下：12345678910111213141516171819202122232425262728293031323334var a=[]var i = 0;if(i&lt;3) &#123; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; a[i]=function()&#123;console.log(i)&#125; &#125;i++;/* 数组a此时的状态a = [ function()&#123;console.log(i)&#125;, function()&#123;console.log(i)&#125;, function()&#123;console.log(i)&#125;]*/// a[1] = function()&#123;console.log(i)&#125;a[1](); // 打印3，因为i现在的值是3注：“i现在的值是3”这句话在某种意义上是不准确的，从作用域链的角度来说a[1]在它的if&#123;&#125;块作用域内没有找到i，要去上一级作用域局部作用域中找，这时候找到了i，而局部作用域中i现在的值是3。 4、如果把for循环的var换成let12345678910111213141516171819202122232425262728293031var a=[]; for(let i = 0;i&lt;3;i++)&#123; a[i]=function()&#123;console.log(i)&#125; &#125;a[1](); //1// 执行过程var a=[]let i = 0;if(i&lt;3) &#123; let i = i; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; let i = i; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; let i = i; a[i]=function()&#123;console.log(i)&#125; &#125;i++;// console.log(i)在其块级作用域内就找到了i，每次for循环把当前i值存入块级作用域。所以a[1]()会打印1；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性]]></title>
    <url>%2F2017%2F06%2F28%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ES6简介​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​由于ES6是在2015年发布的，所以也叫ES2015。​以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、…. 块级作用域 在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。 块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建： 函数内部 在代码块（即 { }）内部 let声明 使用let声明变量的语法和使用var声明的语法是一样的。但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。 1234567let a = 10;if(a &gt; 5)&#123; console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错） let b = 20; console.log(b);&#125;console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错） 注意：1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问2.用let声明的变量也没有声明提前这一特性。3.在同一个块中，let声明的变量也不能重复声明。4.在声明变量的时候尽量使用let，慢慢的抛弃var const声明(Constant Declarations) 在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。 123456var a = 20;if (true) &#123; const b = 20; b = 30; //错误! 常量不能重新赋值 const c; //错误！ 常量声明的同时必须赋值。&#125; 注意:1.const的特性除了声明的是常量为，其他与let一样。2.在let和const声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。3.使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。 循环中的块级绑定 使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。 1234for(let i = 0; i &lt; 3; i++)&#123; // 循环结束之后会立即销毁 i console.log(i);&#125;console.log(i); //此处无法访问到 i 。 循环中的函数 看下面的代码，是输出10个10，而不是0，1，2，… 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;funcs.forEach(function (func) &#123; func(); // 输出 "10" 共10次&#125;); 解决办法需要使用函数的自执行特性。 1234567891011var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push((function(value) &#123; return function() &#123; console.log(value); &#125; &#125;(i)));&#125;funcs.forEach(function(func) &#123; func(); // 输出 0，1，2 ... 9&#125;); 如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用123456789var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;funcs.forEach(function (func) &#123; func(); // 输出 0，1，2 ... 9&#125;) 说明：let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。 函数的新增特性带默认参数的函数 JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。 1234function makeRequest(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function() &#123;&#125;;&#125; 其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000. ES6从语言层面面上增加了默认值的支持。看下面的代码： 1234//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 其余代码&#125; 默认参数对 arguments 对象的影响 在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码： 12345678910function foo(a, b) &#123; //非严格模式 console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true&#125;foo(1, 2); 在ES5的严格模式下，arguments只反映参数的初始值，而不再反映命名参数的变化！ 1234567891011function foo(a, b) &#123; //严格模式 "use strict" console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 修改a的值不会影响到arguments[0]的值 console.log(arguments[1] === b); //false&#125;foo(1, 2); 当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码： 123456789function foo(a, b = 30) &#123; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。 console.log(arguments[1] === b); //false。 b使用了默认值，所以表现的和严格模式一样。&#125;foo(1, 2); 注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。 默认参数表达式 (Default Parameter Expressions) 参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码 12345678910function getValue() &#123; return 5;&#125;function add(first, second = getValue()) &#123; //表示使用getValue这个函数的返回值作为second的默认值。 return first + second;&#125;console.log(add(1, 1)); // 2. 调用add函数的时候，传入了第二个参数，则以传入的参数为准。console.log(add(1)); // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。 有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。 123function add(first, second = first) &#123; // 使用第一个参数作为第二个参数的默认值 return first + second; &#125; 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。 未命名参数问题 Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。 12345678910111213141516function foo(a) &#123; console.log(a); console.log(arguments[1]) //取得传入的多余的参数。&#125;foo(2, 3);``` &gt;ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数( Rest Parameters)**语法：function a(a, … b)&#123; &#125;剩余参数使用三个点( … )和变量名来表示。```jsfunction foo(a, ...b) &#123; console.log(a); console.log(b instanceof Array); //true .多余的参数都被放入了b中。b其实就是一个数组。&#125;foo(2, 3, 4, 6); 注意：1.函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。2.虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。3.剩余参数是在函数声明的时候出现的。 函数中的扩展运算符 例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用apply方法。 看下面的代码：12let values = [25, 50, 75, 100] console.log(Math.max.apply(Math, values)); // 100 上面这种方法虽然可行，但是总是不是那么直观使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。 123let values = [25, 50, 75, 100]console.log(Math.max(...values)); //使用扩展运算符。相当于拆解了数组了。console.log(Math.max(...values, 200)); //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。 注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。 全新的函数：箭头函数（=&gt;）箭头函数语法 基本语法如下： 123(形参列表)=&gt;&#123; //函数体&#125; 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。 123456789var sum = (num1, num2) =&gt;&#123; return num1 + num2;&#125;console.log(sum(3, 4));//前面的箭头函数等同于下面的传统函数var add = function (num1, num2) &#123; return num1 + num2;&#125;console.log(add(2, 4)) 如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。如果函数体内有多条语句，则 {} 不能省略。 1234567891011var sum = (num1, num2) =&gt; num1 + num2;console.log(sum(5, 4));//前面的箭头函数等同于下面的传统函数var add = function (num1, num2) &#123; return num1 + num2;&#125;console.log(add(2, 4));//如果这一行代码是没有返回值的，则方法的返回自也是undefinedvar foo = (num1, num2) =&gt; console.log("aaa");console.log(foo(3,4)); //这个地方的返回值就是undefined 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。当然如果不传入参数也不可以省略 12var foo = a=&gt; a+3; //因为只有一个参数，所以()可以省略console.log(foo(4)); // 7 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 () 123456789var foo = ()=&gt;(&#123;name:"lisi", age:30&#125;);console.log(foo());//等同于下面的；var foo1 = ()=&gt;&#123; return &#123; name:"lisi", age : 30 &#125;;&#125; 使用箭头函数实现函数自执行12345678var person = (name =&gt; &#123; return &#123; name: name, age: 30 &#125; &#125;)("zs");console.log(person); 箭头函数中无this绑定(No this Binding) 在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。 123456789101112var PageHandler = &#123; id: "123456", init: function () &#123; document.addEventListener("click", event =&gt; this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。 &#125;, doSomething: function (type) &#123; console.log("Handling " + type + " for " + this.id); &#125;&#125;;PageHandler.init(); 看下面的一段代码：12345var p = &#123; foo:()=&gt;console.log(this) //此处this为window&#125;p.foo(); //输出为 window对象。 并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。 说明：1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。2.由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。 无arguments绑定 虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。 123456function foo() &#123; //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。 return ()=&gt;arguments[0]; //箭头函数的返回值是foo函数的第一个参数&#125;var arrow = foo(4, 5);console.log(arrow()); // 4 对象功能的扩展 在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。 对象类别 ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括： 普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。 特异对象（exotic object）的某些内部行为和默认的有所差异。 标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。 内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。 对象字面量的语法扩展简写的属性初始化12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name:name, age:age &#125;&#125;console.log(createPerson("lisi", 30)); // &#123;name:"lisi", age:30&#125; ES6中，上面的写法可以简化成如下形式： 12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name, //当对象属性名和本地变量名相同时，可以省略冒号和值 age &#125;&#125;console.log(createPerson("lisi", 30)); // &#123;name:"lisi", age:30&#125; 当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。 简写的方法声明1234567var person = &#123; name:'lisi', sayHell:function () &#123; console.log("我的名字是：" + this.name); &#125;&#125;person.sayHell() 在ES6中，上面的写法可以简化成如下的形式： 1234567var person = &#123; name:'李四', sayHell() &#123; console.log("我的名字是：" + this.name); &#125;&#125;person.sayHell() 在字面量中动态计算属性名 在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。123456var p = &#123; name : '李四', age : 20&#125;var attName = 'name';console.log(p[attName]) //这里 attName表示的是一个变量名。 而下面的方式使用时没有办法访问到attName这个变量的。 123456var attName = 'name';var p = &#123; attName : '李四', // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。 age : 20&#125;console.log(p[attName]) // undefined 在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。123456var attName = 'name';var p = &#123; [attName] : '李四', // 引用了变量attName。相当于添加了一个属性名为name的属性 age : 20&#125;console.log(p[attName]) // 李四 新增的方法 ECMAScript从第五版开始避免在Object.prototype上添加新的全局函数或方法，转而去考虑具体的对象类型（如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。ES6 在全局Object上添加了几个新的方法来轻松地完成一些特定任务。 Object.is()在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示： 123456789101112console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == "5"); // trueconsole.log(5 === "5"); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, "5")); // false 很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。 Object.assign() 使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。 123456789101112var p = &#123; name : "lisi", age : 20, friends : ['张三', '李四']&#125;var p1 = &#123;&#125;;Object.assign(p1, p); //则p1中就有了与p相同的属性和方法. p1是接受者，p是提供者console.log(p1);//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）console.log(p1.friends == p.friends); //true p1和p的friends同事指向了同一个数组。p.friends.push("王五");console.log(p1.friends); //['张三', '李四', '王五'] assign方法可以接受任意多的提供者。意味着后面提供者的同名属性会覆盖前面提供者的属性值。 1234567891011var p = &#123; name : "lisi", age : 20, friends : ['张三', '李四']&#125;var p1 = &#123; name : 'zs',&#125;var p2 = &#123;&#125;;Object.assign(p2, p, p1); //p和p1都是提供者console.log(p2.name); // zs 字符串功能的增强查找子字符串 在以前在字符串中查找字符串的时候，都是使用indexOf方法。ES6新增了三个方法来查找字符串。 includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。 startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。 endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。 每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示： 12345678910111213var msg = "Hello world!";console.log(msg.startsWith("Hello")); // trueconsole.log(msg.endsWith("!")); // trueconsole.log(msg.includes("o")); // trueconsole.log(msg.startsWith("o")); // falseconsole.log(msg.endsWith("world!")); // trueconsole.log(msg.includes("x")); // falseconsole.log(msg.startsWith("o", 4)); // trueconsole.log(msg.endsWith("o", 8)); // trueconsole.log(msg.includes("o", 8)); // false repeat方法 ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如： 123console.log("x".repeat(3)); // "xxx"console.log("hello".repeat(2)); // "hellohello"console.log("abc".repeat(4)); // "abcabcabcabc" 字符串模板字面量 模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应： 多行字符串 针对多行字符串的形式概念（formal concept）。 基本的字符串格式化 将字符串中的变量置换为值的能力。 转义 HTML 能将字符串进行转义并使其安全地插入到 HTML 的能力。 模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。 基本语法 使用一对反引号 ``(tab正上方的按键)来表示模板字面量。 12345let message = `Hello world!`; //使用模板字面量创建了一个字符串console.log(message); // "Hello world!"console.log(typeof message); // "string"console.log(message.length); // 12 多行字符串 在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \） 123var s = "abc \aaaaaa";console.log(s); //但是输出的结果中不包括换行 但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法. 12345var s = `abcaaaaadsalfjadfadfja`;console.log(s); 但是要注意： 反引号中的所有空格和缩进都是有效字符。 字符串置换 置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。语法：${变量名、表达式、任意运算、方法调用等}可以嵌入任何有效的JavaScript代码 123var name = "李四";var msg = `欢迎你$&#123;name&#125;同学`;console.log(msg) 模板标签什么是模板标签 模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示： 1let message = myTag`Hello world`; 在上面的代码中，myTag就是模板标签。myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。 定义模板标签 一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：12345678910111213141516171819let name = '张三', age = 20, message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`;/* 应该定义一个函数show： 参数1：一个字符串数组。在本例中包含三个元素。 0:"我来给大家介绍" 1:"的年龄是" 2:"." 参数2和参数3：表示需要置换的字符串的值。 */function show(stringArr, value1, value2) &#123; console.log(stringArr); // console.log(value1); // 张三 console.log(value2); // 20 return "abc";&#125;console.log(message); //abc 为了简化书写，一般把Value1和Value2写成剩余字符串的形式 123function show(stringArr, ...values)&#123; // blabla...&#125; 解构解构的实用性 在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如： 123456789let options = &#123; repeat: true, save: false &#125;;// 从对象中提取数据let repeat = options.repeat, save = options.save; 这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。 这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。 对象解构对象解构的基本形式 对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。 123456789let node = &#123; type: "Identifier", name: "foo" &#125;;//这里就相当于声明了两个变量： type = node.type; name:node.namelet &#123; type, name &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo" 在上面的结构中必须要初始化。否则会出现语法错误。 12345678// 语法错误！var &#123; type, name &#125;;// 语法错误！let &#123; type, name &#125;;// 语法错误！const &#123; type, name &#125;; 解构赋值表达式 如果声明的变量想改变他们的值，也可以使用解构表达式。 123456789101112let node = &#123; type: "Identifier", name: "foo"&#125;,type = "Literal",name = 5;//注意：此处必须要在圆括号内才能使用解构表达式(&#123;type, name&#125; = node);console.log(type); // "Identifier"console.log(name); // "foo"" 对象解构时的默认值 如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined 12345678910let node = &#123; type: "Identifier", name: "foo" &#125;;//因为node中没有叫value的属性，所以valued的值将会是undefinedlet &#123; type, name, value &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // undefined 不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像） 12345678910let node = &#123; type: "Identifier", name: "foo"&#125;;//手动添加value的默认值为3let &#123; type, name, value = 3&#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // 3 赋值给不同的变量名 在前面的操作中，都是把对象的属性值，赋值给同名变量。其实也可以赋值给不同名的变量。 123456789let node = &#123; type: "Identifier", name: "foo"&#125;;// localType才是要定义的新的变量。 type是node的属性let &#123;type: localType, name: localName&#125; = node;console.log(localType); // "Identifier"console.log(localName); // "foo" 数组解构数组解构基本语法 数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如： 12345let colors = [ "red", "green", "blue" ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 如果只想取数组中的某一项，则可以不用命名。 12345let colors = [ "red", "green", "blue" ];//只取数组中的第三项。let [ , , thirdColor ] = colors;console.log(thirdColor); // "blue" 解构表达式 你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如： 12345678let colors = [ "red", "green", "blue" ], firstColor = "black", secondColor = "purple";[ firstColor, secondColor ] = colors; //可以不用加括号。当然添加也不犯法console.log(firstColor); // "red"console.log(secondColor); // "green" 数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码： 12345678let a = 3, b = 4, temp;temp = a;a = b;b = temp;console.log(a);console.log(b) 那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式 123456let a = 3, b = 4;//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。[a, b] = [b, a];console.log(a);console.log(b); 新的基本类型：Symbol 以前我们有5种基本数据类型：Number、String、Boolean、Null、UndefinedES6新增了一种新的数据类型：Symbol在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。 创建SymbolSymbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。我们可以使用symbol全局函数来创建Symbol。 12345let firstName = Symbol(); //创建一个Symbollet person = &#123;&#125;;person[firstName] = "张三";console.log(person[firstName]); // "张三" 说明：上面的代码中，firstName作为symbol类型被创建并赋值给 person对象以作其属性。每次访问这个属性时必须使用该 symbol。 在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。 123var s1 = Symbol("abc");var s2 = Symbol("abc");console.log(s1 == s2); //false 注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。 识别Symbol 既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如： 12let symbol = Symbol();console.log(typeof symbol); // "symbol" Symbol作为属性名​由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。12345678var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125; 注意：1,symbol作为对象的属性的时候，只能使用[ ]去访问，不能使用点去访问。2,symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。 Symbol属性名的遍历​ Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol属性名。123456789var obj = &#123;&#125;;var a = Symbol('a');var b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';// 返回obj对象所有Symbol类型的属性名组成的数组。var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols) //[Symbol(a), Symbol(b)] 看下面代码 12345678var obj = &#123;&#125;;var foo = Symbol("foo");obj[foo] = "lisi";for (var i in obj) &#123; console.log(i); // 无输出 。 因为遍历不到Symbol型的属性 &#125;Object.getOwnPropertyNames(obj);// [] 只能拿到非Symbol类型的属性Object.getOwnPropertySymbols(obj) //[Symbol(foo)] 还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。Reflect.ownKeys() 123456let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj);// ["enum", "nonEnum", Symbol(my_key)] 说明：由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for(字符串)和Symbol.keyFor(symbol类型的值) Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个symbol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。 12345//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册var a = Symbol.for("foo");//第二次搜到上次创建的var b = Symbol.for("foo");console.log(a === b); //因为两次搜到的是同一个Symbol，所以此处是true Symbol.for()和Symbol()都可以创建Symbol类型的数据。二者区别：1，Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。2，Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。123var a = Symbol("foo");var b = Symbol.for("foo");console.log(a == b); //false Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。 1234var a = Symbol("foo");var b = Symbol.for("foo");console.log(Symbol.keyFor(a)); // undefined. 因为a没有想全局环境中登记，所以是undefindedconsole.log(Symbol.keyFor(b)); // foo Set数据结构​JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。 ​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。 Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set中的元素不能重复，而数组中的元素可以重复。 一句话总结：Set类型是一个包含无重复元素的有序列表 创建Set和并添加元素 Set本身是一个构造函数。 12345678//创建Set数据结构对象。var s = new Set();//调用set对象的add方法，向set中添加元素s.add("a");s.add("c");s.add("b");//set的size属性可以获取set中元素的个数console.log(s.size) Set中不能添加重复元素123456var s = new Set();s.add("a");s.add("c");s.add("b");s.add("a"); //重复，所以添加失败。注意这个地方并不会保存。console.log(s.size); // 长度是3 看下面代码： 1234var s = new Set();s.add(5);s.add("5");console.log(s.size); // 长度是2 在上面的代码中，数字5和字符串5都会添加成功。为什么呢？ Set是使用什么机制来判断两个元素是否相等的呢？是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。回忆一下：这个方法除了 +0和-0、NaN和NaN认为相等，其余和三个 === 是完全一样的。 12345678910var s = new Set();s.add(+0);s.add(-0); //重复添加不进去s.add(NaN);s.add(NaN); //重复添加不进去s.add([]);s.add([]); //两个空数组不相等，所以可以添加进去s.add(&#123;&#125;);s.add(&#123;&#125;); // 两个空对象也不重复，所以也可以添加进去console.log(s.size); // 长度是6 使用数组初始化Set123//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。var s = new Set([2, 3, 2, 2, 4]);console.log(s.size); 判断一个值是否在Set中 使用Set的 has() 方法可以判断一个值是否在这个set中。 123456let set = new Set();set.add(5);set.add("5");console.log(set.has(5)); // trueconsole.log(set.has(6)); // false 移除Set中的元素 delete(要删除的值) ：删除单个值clear()：清空所有的值 123456789101112131415let set = new Set();set.add(5);set.add("5");console.log(set.has(5)); // trueset.delete(5);console.log(set.has(5)); // falseconsole.log(set.size); // 1set.clear();console.log(set.has("5")); // falseconsole.log(set.size); // 0 遍历Set 数组有个方法forEach可以遍历数组。Set也有forEach可以遍历Set。使用Set的forEach遍历时的回调函数有三个参数：function (value, key, ownerSet){ }参数1：遍历到的元素的值参数2：对set集合来说，参数2的值和参数1的值是完全一样的。参数3：这个set自己 1234let set = new Set(["a", "c", "b", 9]);set.forEach(function (v, k, s) &#123; console.log(v + " " + (v === k) + " " + (s === set)); // 永远是true&#125;) 将Set转换为数组 将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。把Set转换为数组使用前面讲到的扩展运算符也很容易 123let set = new Set([1, 2, 3, 3, 3, 4, 5]), arr = [...set]; //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响console.log(arr); // [1,2,3,4,5] 这种情况在需要去数组中重复元素的时候非常好用。 1234567function eliminateDuplicates(items) &#123; return [...new Set(items)];&#125;let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1], //返回的是新的没有重复元素的数组。 noDuplicates = eliminateDuplicates(numbers);console.log(noDuplicates); // [1,2,3,4,5] Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map. Map数据结构​ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。 ​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。 ​这和使用对象属性做为值的方法大相径庭，因为 对象的属性会被强制转换为字符串类型。 创建Map对象和Map的基本的存取操作 Map创建也是使用Map构造函数向Map存储键值对使用set(key, value);方法可以使用get(key),来获取指定key对应的value 12345678var map = new Map();map.set("a", "lisi");map.set("b", "zhangsan");map.set("b", "zhangsan222"); // 第二次添加，新的value会替换掉旧的console.log(map.get("a"));console.log(map.get("b")); //zhangsan222console.log(map.get("c")); //undefined.如果key不存在，则返回undefinedconsole.log(map.size); //2 Map与Set类似的3个方法 has(key) - 判断给定的 key 是否在 map 中存在 delete(key) - 移除 map 中的 key 及对应的值 clear() - 移除 map 中所有的键值对 初始化Map 创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。也就是传入的实际是一个二维数组！ 123456789//map接受一个二维数组var map = new Map([ //每一个数组中，第一个是map的key，第二个是map的value。如果只有第一个，则值是undefined ["name", "lisi"], ["age", 20], ["sex", "nan"]]);console.log(map.size);console.log(map.get("name")); Map的forEach方法123456789101112131415var map = new Map([ ["name", "李四"], ["age", 20], ["sex", "nan"]]);/* 回调函数有三个参数： 参数1：键值对的value 参数2：键值对的key 参数3：map对象本身 */map.forEach(function (value, key, ownMap) &#123; console.log(`key=$&#123;key&#125; ,vlue=$&#123;value&#125;`); console.log(this);&#125;) 迭代器和for…of循环循环问题12345var colors = ["red", "green", "blue"];for (var i = 0, len = colors.length; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。迭代器就是为了解决这个问题的。 什么是迭代器​ 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。 ​ 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。 我们可以使用ES5知识创建一个迭代器 123456789101112131415161718192021222324function createIterator(items) &#123; var i = 0; return &#123; next: function() &#123; var done = (i &gt;= items.length); var value = !done ? items[i++] : undefined; return &#123; done: done, value: value &#125;; &#125; &#125;;&#125;//创建一个可以在指定数组上面迭代的迭代器对象。var iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// for all further callsconsole.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。 生成器函数 生成器函数就是返回迭代器的函数！生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。看下面代码： 123456789101112//生成器函数。 注意中间的 * 不能丢function * createIterator() &#123; //每个yield的后面的值表示我们迭代到的值。 yield也定义了我们迭代的顺序。 yield 3; yield 4; yield 2;&#125;var it = createIterator();console.log(it.next().value); // 3console.log(it.next().value); // 4console.log(it.next().value); // 2console.log(it.next().value); //undefined 迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。每调用一次迭代器的next方法，如果碰到yield都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用next方法，会从上次停止的地方继续执行。 1234567891011121314151617//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。function * createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125; yield items[i]; &#125;&#125;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// 进一步调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 注意：yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。 生成器函数表达式 你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如： 123456789101112131415let createIterator = function *(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// 进一步调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 注意：无法使用箭头函数来创建生成器。 可迭代类型和for-of迭代循环 迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。 ​与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。​该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。​换句话说，默认情况下只有 数组、set、Map和字符串才可以使用迭代器去迭代。 (也就可以使用for…of了)​for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！ 使用 for…of 迭代数组： 1234var arr = ["a", "c", "b", "d"];for(var item of arr)&#123; console.log(item)&#125; 使用 for…of 迭代Set: 1234var set = new Set(["a", "c", "b", "d"]);for(var item of set)&#123; console.log(item)&#125; 使用 for…of 迭代Map： 12345var map = new Map([["name", "lisi"],["sex", "男"],["age", 20]]);map.set("aaa", "bbb")for(var item of map)&#123; console.log(item); //注意：这里迭代到的是由key和value组成的数组。&#125; 使用for … of迭代字符串 1234var s = "abcd";for(let c of s)&#123; console.log(c)&#125; 注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常。 说明：以数组为例。 ​ for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。 ​ 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。 访问可迭代类型的默认迭代器 Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。 123let s = "abcd";let it = s[Symbol.iterator](); //调用字符串的Symbol.iterator方法console.log(it.next()); //返回迭代器迭代到的第一个对象 因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代 123456789function isIterable(object) &#123; return typeof object[Symbol.iterator] === "function";&#125;console.log(isIterable([1, 2, 3])); // trueconsole.log(isIterable("Hello")); // trueconsole.log(isIterable(new Map())); // trueconsole.log(isIterable(new Set())); // trueconsole.log(isIterable(&#123;"name":"李四"&#125;)); // false。普通对象不可迭代 自定义可迭代类型 开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如： 1234567891011121314151617let collection = &#123; items: [], *[Symbol.iterator]() &#123; for (let item of this.items) &#123; yield item; &#125; &#125;&#125;;collection.items.push(1);collection.items.push(2);collection.items.push(3);for (let x of collection) &#123; console.log(x);&#125; 类 和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。 ES5之前的模拟的类​在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：12345678910111213function PersonType(name) &#123; this.name = name;&#125;PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person = new PersonType("Nicholas");person.sayName(); // 输出 "Nicholas"console.log(person instanceof PersonType); // trueconsole.log(person instanceof Object); // true 说明：前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。 ES6中基本的类声明 在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。 12345678910111213141516171819//class关键字必须是小写。 后面就是跟的类名class PersonClass &#123; // 等效于 PersonType 构造函数。 constructor(name) &#123; //这个表示类的构造函数。constuctor也是关键字必须小写。 this.name = name; //创建属性。 也叫当前类型的自有属性。 &#125; // 等效于 PersonType.prototype.sayName. 这里的sayName使用了我们前面的简写的方式。 sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass("Nicholas");person.sayName(); // 输出 "Nicholas"console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // "function"console.log(typeof PersonClass.prototype.sayName); // "function" 说明：1，自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。2，类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。 虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记:1，类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。2，类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。3，所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。4，所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。5，不使用 new 来调用类构造函数会抛出错误。也就是 必须使用new 类() 的方式使用6，试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的） 匿名类表达式 函数有函数表达式，类也有类表达式。类表达式的功能和前面的类的声明是一样的。 123456789101112let PersonClass = class &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;;let person = new PersonClass("Nicholas");person.sayName(); // 输出 "Nicholas" 具名类表达式123456789101112let PersonClass = class PersonClass2&#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;; 注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的. 作为一等公民的类型 在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。类也是一等公民。 类可以作为参数传递1234567891011function createObject(classDef) &#123; return new classDef();&#125;let obj = createObject(class &#123; sayHi() &#123; console.log("Hi!"); &#125;&#125;);obj.sayHi(); // "Hi!" 立即调用类构造函数，创建单例12345678910111213let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;("Nicholas");person.sayName(); // "Nicholas" 动态计算类成员的命名 类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算) 123456789101112let methodName = "sayName";class PersonClass &#123; constructor(name) &#123; this.name = name; &#125; [methodName]() &#123; console.log(this.name); &#125;&#125;let me = new PersonClass("Nicholas");me.sayName(); // "Nicholas" 静态成员 在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。 123456789101112function PersonType(name) &#123; this.name = name;&#125;// 静态方法。 直接添加到构造方法上。 (其实是把构造函数当做一个普通的对象来用。)PersonType.create = function(name) &#123; return new PersonType(name);&#125;;// 实例方法PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person = PersonType.create("Nicholas"); 在上面的create方法在其他语言中一般都是作为静态方法来使用的。ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的： 12345678910111213141516171819class PersonClass &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125; // 等效于 PersonType.create。 static create(name) &#123; return new PersonClass(name); &#125;&#125;let person = PersonClass.create("Nicholas"); 注意：静态成员通过实例对象不能访问，只能通过类名访问！！！ ES6中的继承 在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子： 1234567891011121314151617181920function Father(name) &#123; this.name = name;&#125;Father.prototype.sayName = function () &#123; console.log(this.name);&#125;function Son(name,age) &#123; Father.call(this, name); this.age = age;&#125;Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function () &#123; console.log(this.age);&#125;var son1 = new Son("儿子", 20);son1.sayAge(); //20son1.sayName(); //儿子 继承的基本写法 如果在ES6通过类的方式完成继承就简单了很多。需要用到一个新的关键字：extends 123456789101112131415161718192021222324class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125;&#125;class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125;&#125;var son1 = new Son("李四", 30);son1.sayAge();son1.sayName();console.log(son1 instanceof Son); // trueconsole.log(son1 instanceof Father); //true 这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。关于super的使用，有几点需要注意：1，你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。2，你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。3，在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。 在子类中屏蔽父类的方法 如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 ) 123456789101112131415161718192021222324252627class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125;&#125;class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125; //子类中的方法会屏蔽到父类中的同名方法。 sayName()&#123; super.syaName(); //调用被覆盖的父类中的方法。 console.log("我是子类的方法，我屏蔽了父类：" + name); &#125;&#125;var son1 = new Son("李四", 30);son1.sayAge();son1.sayName(); 如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。注意：1，如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法2，普通方法调用需要使用super.父类的方法() 来调用。 静态方法也可以继承123456789class Father&#123; static foo()&#123; console.log("我是父类的静态方法"); &#125;&#125;class Son extends Father&#123;&#125;Son.foo(); //子类也继承了父类的静态方法。 这种方式调用和直接通过父类名调用时一样的。 Moudle JavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。 什么是模块​ 模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义： 模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。 模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。 模块顶级作用域中的 this 为 undefined 。 模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。 模块必须输出可被模块外部代码使用的相关内容。 一个模块可以引入另外的模块。 导出模块​ 可以使用 export 关键字来对外暴露模块中的部分代码。​ 一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们123456789101112131415161718192021222324252627282930// 输出变量export var color = "red";export let name = "Nicholas";export const magicNumber = 7;// 输出函数export function sum(num1, num2) &#123; return num1 + num1;&#125;// 输出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;// 该函数没有使用export关键字 所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到function subtract(num1, num2) &#123; return num1 - num2;&#125;// 定义一个函数...function multiply(num1, num2) &#123; return num1 * num2;&#125;// 可以把这个函数的引用导出。 和导出函数是一样的。export &#123; multiply &#125;; 引入模块 一旦有了导出内容的模块，则可以在另一个模块中使用import关键字来获取他们。 1import &#123; identifier1, identifier2 &#125; from "./a.js"; ​ import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）。浏览器中的 &lt;script&gt;元素也使用了这个路径形式，意味着它必须包含文件扩展名。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript特效三大系列总结]]></title>
    <url>%2F2017%2F06%2F20%2FJavaScript%E7%89%B9%E6%95%88%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天主要是讲js的DOM元素的位置关系的三大系列：offset系列，scroll系列，client系列。希望你看完之后能更加了解，熟练应用。let’s go~ offset系列offset系列的5个属性123456789101112131415161. offsetLeft : 用于获取元素到最近的定位父盒子的左侧距离 * 计算方式: 当前元素的左边框的左侧到定位父盒子的左边框右侧 * 如果父级盒子没有定位, 那么会接着往上找有定位的盒子 * 如果上级元素都没有定位,那么最后距离是与body的left值2. offsetTop : 用于获取元素到最近定位父盒子的顶部距离 * 计算方式:当前元素的上边框的上侧到定位父盒子的上边框下侧 * 如果父级盒子没有定位,那么会接着往上找有定位的盒子 * 如果上级元素都没有定位,那么最后距离是与body的top值3. offsetWidth :用于获取元素的真实宽度(除了margin以外的宽度)4. offsetHeight : 用于获取元素的真实高度(除了margin以外的高度)5. offsetParent :用于获取该元素中有定位的最近父级元素 * 如果当前元素的父级元素都没有进行定位,那么offsetParent为body 与style.(left/top/width/height)的区别:1231. offset系列的是只读属性,而通过style的方式可以读写2. offset系列返回的数值类型(结果四舍五入),style返回的是字符串3. offsetLeft 和 offsetTop 可以返回没有定位的元素的left值和top值,而style不可以 scroll系列scroll系列的4个属性1234567891. scrollHeight :元素中内容的实际高度(没有边框) * 如果内容不足,就是元素的高度2. scrollWidth: 元素中内容的实际宽度(没有边框) * 如果内容不足,就是元素的宽度3. scrollTop: onscroll事件发生时,元素向上卷曲出去的距离4. scrollLeft : onscroll事件发生时,元素向左卷曲出去的距离 兼容问题123456789101112131415161718192021222324* 未声明 DTD: 谷歌,火狐,IE9+支持 document.body.scrollTop/scrollLeft* 已经声明DTD:IE8以下支持 document.documentElement.scrollTop/scrollLeft * 火狐/谷歌/ie9+以上支持的 window.pageYOffest/pageXOffest// 兼容处理的代码function getScroll() &#123; return &#123; left: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0, top: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0 &#125;;&#125;// 使用方法:1. 取得scrollLeft值: getScroll().left2. 取得scrollTop值: getScroll().top client系列client系列的4个常用属性12345671. clientWidth : 获取网页可视区域的宽度2. clientHeight: 获取网页可视区域的高度3. clientX :获取鼠标事件发生时的应用客户端区域的水平坐标4. clientY :获取鼠标事件发生时的应用客户端区域的垂直坐标 兼容问题clientWidth 和 clientHeight的兼容问题123456789101112131415161718192021222324252627282930313233343536//由浏览器对象不同导致* 未声明 DTD: 谷歌,火狐,IE9+支持document.body.clientWidth/clientHeight* 已经声明DTD:IE8以下支持document.documentElement.clientWidth/clientHeight* 火狐/谷歌/ie9+以上支持的 window.innerWidth/innerHeight// 兼容处理的代码function client()&#123; if(window.innerWidth)&#123; return &#123; "width":window.innerWidth, "height":window.innerHeight &#125;; &#125;else if(document.compatMode === "CSS1Compat")&#123; return &#123; "width":document.documentElement.clientWidth, "height":document.documentElement.clientHeight &#125;; &#125;else&#123; return &#123; "width":document.body.clientWidth, "height":document.body.clientHeight &#125;; &#125;&#125;// 使用方法:1. 取得clientWidth的值: client().width2. 取得clientHeight的值: client().height clientX 和 clientY的兼容问题1234567891011121314151617181920212223242526272829//由事件参数对象的兼容性问题导致1. 谷歌,火狐,IE9+: 事件参数对象随着事件处理函数的参数传入2. IE8以下: event对象必须作为window对象的一个属性(window.event)// 兼容处理的代码//将client和scroll的兼容问题进行对象的封装var evtTools=&#123; //获取兼容的事件参数对象 getEvt:function (e) &#123; return window.event?window.event:e; &#125;, //获取的是可视区域的横坐标 getClientX:function (e) &#123; return this.getEvt(e).clientX; &#125;, //获取的是可视区域的纵坐标 getClientY:function (e) &#123; return this.getEvt(e).clientY; &#125;, //获取向左卷曲出去的距离的横坐标 getScrollLeft:function () &#123; return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0; &#125;, //获取向上卷曲出去的距离的纵坐标 getScrollTop:function () &#123; return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0; &#125;&#125;; 总结1234567891011121314网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js图片懒加载及优化]]></title>
    <url>%2F2017%2F06%2F18%2Fjs%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为啥要用图片懒加载对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。 原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求（指向默认的一张图那就只需请求一次）。可以指向loading的地址。 当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 注：图片要指定宽高。关于窗口各种宽度，可以看下面两篇文章：scrollWidth,clientWidth,offsetWidth的区别JS中关于clientWidth offsetWidth scrollWidth 等的含义 图片懒加载的实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t" alt=""&gt; &lt;img src="" data-src="http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg" alt=""&gt; &lt;img src="" data-src="http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg" alt=""&gt; &lt;img src="" data-src="http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt;&lt;script&gt; (function()&#123; let num = document.getElementsByTagName('img').length; let img = document.getElementsByTagName("img"); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125; &#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用节流函数进行优化如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。 同时还有以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。1.window对象的resize、scroll事件2.拖拽时的mousemove事件3.射击游戏中的mousedown、keydown事件4.文字输入、自动完成的keyup事件解决这个问题的方法有去抖动和节流的方法 去抖动原理： 当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 不足:当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了 节流原理：预设一个执行周期，如果这个周期结束了都还没触发函数，那就会执行一次函数；如果这个周期还没结束就触发了函数，那定时器将重置，开始新周期。 达到了想要的效果，既没有频繁的执行也没有延迟执行 运用节流函数的图片懒加载代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t" alt=""&gt; &lt;img src="" data-src="http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg" alt=""&gt; &lt;img src="" data-src="http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg" alt=""&gt; &lt;img src="" data-src="http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt;&lt;script&gt; (function()&#123; let num = document.getElementsByTagName('img').length; let img = document.getElementsByTagName("img"); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125; // 采用了节流函数 function throttle(fun, delay, time) &#123; let timeout, startTime = new Date(); return function() &#123; let context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) &#123; fun.apply(context, args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125; else &#123; timeout = setTimeout(fun, delay); &#125; &#125;; &#125;; window.addEventListener('scroll',throttle(lazyload,500,1000));&#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>image-lazyload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂HCJ讲义（一）]]></title>
    <url>%2F2017%2F06%2F15%2F%E7%96%AF%E7%8B%82HCJ%E8%AE%B2%E4%B9%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTML5的常用元素与属性HTML5新增通用属性contentEditable属性HTML5为大部分元素都增加了contentEditable属性,如果将该属性设置为true，浏览器会允许开发者直接在页面编辑该元素。contentEditable属性具有可继承的特点，如果一个HTML元素的父元素是“可编辑”状态，那么它也是默认可编辑的。123&lt;div contentEditable="true" style="width:500px;height:300px;border:1px solid #000"&gt;&lt;/div&gt;&lt;p ondbclick="this.contentEditable=true"&gt;双击编辑内容&lt;/p&gt; designMode属性designMode属性相当于全局的contentEditable属性，如果把整个页面的designMode属性设置为on时，该页面所有支持contentEditable属性的元素都变成可编辑状态。在JavaScript代码中只能修改整个HTML页面的designMode属性。1document.designMode = "on"; hidden属性HTML5所有元素提供了hidden属性，这个hidden属性支持true,false属性，如果把某一元素的hidden设置成true，就意味着浏览器不显示该组件，也不会保留该组件所占用的空间。提示：hidden属性可以代替CSS样式的display=none。12345&lt;body&gt;&lt;div id="target" hidden="true"&gt;这是文字&lt;/div&gt;&lt;button onclick="var target=document.getElementById('target');target.hidden=!target.hidden;"&gt;显示隐藏&lt;/button&gt; spellcheck属性HTML为input,textarea等元素增加了spellcheck属性，支持true,false属性，如果设置spellcheck=”true”,浏览器会负责对用户输入的文本内容执行输入检查，如果检查不通过，浏览器会对拼错的单词进行提示。1&lt;textarea spellcheck="true" rows="3" cols="40" &gt;&lt;/textarea&gt; 注：目前支持spellcheck属性的浏览器有chrome,Safari,Opera.Internet Explorer和Firefox暂不支持。 HTML5新增常用元素&lt;article&gt;侧重于表达一篇独立的，完整的文章；&lt;section&gt;侧重于对页面内容进行分块；&lt;nav&gt;专门用于定义页面上的导航栏&lt;aside&gt;主要用来渲染成侧边栏&lt;footer&gt;主要用于为元素定义‘脚注’部分，包括该文章的版权信息，作者的授权信息等。&lt;figure&gt;用于表示一块独立的图片区域，可包含多个元素所代表的图片，还可包含一个&lt;figcaption&gt;作为定义图片区域的标题。 HTML5头部和元信息&lt;base/&gt;必须是空元素，可以使用id作为其唯一标识，还有以下两个属性：href：指定所有链接的基准链接target：指定超链接默认在哪个窗口打开链接，属性值只能是_blank,_self,_parent,_top。1234567&lt;head&gt; ... &lt;base target="_blank" href="http://www.baidu.com"/&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="index.php"&gt;啦啦啦啦&lt;/a&gt;&lt;/body&gt; &lt;meta/&gt;用于定义页面元信息，也就是一些name-content对，该元素除了可以指定id属性外，还有以下三个属性：http-equiv: 指定元信息的名称，该属性指定的名称具有特殊意义，它可以向浏览器传回一些有用的信息，帮助浏览器正确的处理网页内容。它支持的几个值有以下：Refresh: 指浏览器多长时间自动刷新页面，如：12&lt;!--设置2秒后自动刷新指定网站--&gt;&lt;meta http-equiv="Refresh" content="2,URL=http://www.baidu.com"/&gt; Expires: 指定网页的过期时间，一旦网页过期，必须重新从服务器下载，如：1&lt;meta http-equiv="Expires" content="Sat Sep 27 16:12:33 CST 2008"&gt; name: 指定元信息的名称，该名称可以随意指定content: 指定元信息值 HTML5表单相关元素和属性HTML原有的表单及表单控件表单元素&lt;form.../&gt;元素用于生成输入表单，该元素不会生成可视化部分，在HTML5以前表单控件都必须放在&lt;form.../&gt;之内。其特有属性有：action:指定当点击确定提交表单时，该表单被提交到那个地址。method:指定提交表单时的请求类型。可以是get/post,默认是get.target: 指定使用哪种方式打开目标URL.name: 指定表单的唯一名称，建议和id属性值保持一致。enctype: 指定对表单内容进行编码所使用的字符集。有三个值:application/x-www-form-urlencoded:默认的编码方式。只处理表单控件的value值，采用这种编码方式的表单会将value值处理成URL编码方式。multipart/for-data:这种编码方式会以二进制流的形式处理表单数据，用于上传文件text/plain:主要适用于直接通过表单发送邮件的方式 使用input元素1.单行文本框：指定&lt;input.../&gt;type属性为text2.密码输入框：指定&lt;input.../&gt;type属性为password3.隐藏域：指定&lt;input.../&gt;type属性为hidden4.单选框：指定&lt;input.../&gt;type属性为radio5.复选框：指定&lt;input.../&gt;type属性为checkbox6.图像域：指定&lt;input.../&gt;type属性为image,可以指定width和height属性7.文本上传域：指定&lt;input.../&gt;type属性为file input元素有以下属性：checked:设置单选框和复选框初始状态是否处于选中状态，disabled:设置首次加载时禁用此元素。该元素无法获得输入，无法选中及响应状态。maxlength: 该属性值是一个数字，指定文本框中允许输入的最大字符数。readonly: 指定文本框内的值不允许用户修改src: 指定图像域所显示的图像URL.只有type=image时可指定该属性 HTML5新增的属性和元素HTML5为表单控件新增的属性 form属性：用于定义该表单控件所属的表单，该属性值应该是它所属表单的id。通过为表单控件添加指定的form属性，可以让表单控件定义在&lt;form.../&gt;外，从而提高灵活性。 1234567&lt;body&gt; &lt;form id="addForm" action="add"&gt; 物品名：&lt;input type="text" name="name"&gt; &lt;input type="submit" value="添加"&gt; &lt;/form&gt; 物品描述：&lt;textarea name="desc" form="addForm"&gt;&lt;/textarea&gt;&lt;/body&gt; 当提交该表单时，该多行文本域也会生成对应的请求参数。 formaction属性当页面中的一个表单，包含两个以上的提交按钮，但是程序需要提交到不同的action，这是可以为不同的提交按钮指定对应的formaction,可以动态的让表单提交到不同的URL,省去用js来实现。 123456&lt;form method="post"&gt; 用户名：&lt;input type="text" name="name"&gt;&lt;br/&gt; 密码：&lt;input type="password" name="name"&gt;&lt;br/&gt; &lt;input type="submit" value="注册" formaction="regist"&gt; &lt;input type="submit" value="登录" formaction="login"&gt;&lt;/form&gt; autofocus属性当为某个表单控件添加该属性后，浏览器打开该页面时该组件会自动获得焦点。整个页面最多只能有一个表单控件可以获得该属性。 list属性相当于文本框和下拉菜单组合的组件，既允许用户输入，也允许用户通过下拉菜单进行选择。list属性的值应该是一个&lt;datalist.../&gt;组建的id。意思是list属性必须和&lt;datalist.../&gt;元素一起使用。&lt;datalist.../&gt;元素相当于一个看不见得&lt;select.../&gt;元素，用于生成一个隐藏的下拉菜单。当双击指定了list属性的文本框时，该文本框会显示&lt;datalist.../&gt;生成的下拉菜单。 12345678&lt;form&gt; 请输入图书：&lt;input type="text" name="name" list="books"&gt; &lt;input type="submit" value="购买"&gt;&lt;/form&gt;&lt;datalist id="books"&gt; &lt;option value="java"&gt;疯狂java讲义&lt;/option&gt; &lt;option value="Android"&gt;疯狂Android讲义&lt;/option&gt; &lt;/datalist&gt; 注：目前只有Firefox ,Opera最新版支持该属性。 功能丰富的input元素HTML5为&lt;input.../&gt;元素的tyoe属性新增了如下几种类型color： 让&lt;input.../&gt;元素生成一个元素选择器。date：让&lt;input.../&gt;元素生成一个日期选择器。time：让&lt;input.../&gt;元素生成一个时间选择器。datetime：让&lt;input.../&gt;元素生成一个UTC日期，时间选择器。week：让&lt;input.../&gt;元素生成一个用户选择第几周的文本框。month：让&lt;input.../&gt;元素生成一个月份选择器。email：让&lt;input.../&gt;元素生成一个元素选择器,可指定multiple属性tel：让&lt;input.../&gt;元素生成一个只允许输入手机号文本框。number：让&lt;input.../&gt;元素生成一个只能输入数字的文本框。range：让&lt;input.../&gt;元素生成一个拖动条。可指定min,max,step属性。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JavaScript之DOM操作]]></title>
    <url>%2F2017%2F06%2F11%2F%E5%8E%9F%E7%94%9FJavaScript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[直接获取元素1234document.getElementById(selector); // 获取指定id的元素document.getElementsByClassName(selector);// 获取指定class的元素的集合document.getElementsByTagName(selector); // 获取指定标签名的元素集合document.getElementsByName(selector); // 获取带有指定名称（name属性）的元素集合 获取父子兄弟元素123456789101112el.parentNode; // 获取直接父元素el.offsetParent; // 用于计算定位的父元素(position属性为relative、absolute或fixed的最近的父元素),若不存在这样的父元素，则为body，但是在低版本IE中可能为htmlel.childNodes; // 所有子节点的集合，包含文本节点(换行或空白)el.children; // 所有子元素的集合，不包含文本节点el.firstChild;el.lastChild;el.nextSibling;el.previousSibling; // 以上四个获取的节点，都包含文本节点el.firstElementChild;el.lastElementChild;el.nextElementSibling;el.previousElementSibling; // 以上四个获取的节点，不包含文本节点，但是在低版本IE里不兼容 增删改元素12345678let element = document.createElement(TagName); // 根据标签名创建标签let textnode = document.createTextNode(content); // 根据内容创建文本节点el.appendChild(element); // 将element标签添加为el的子节点，并且位于最后el.insertBefore(element, child); // 将element标签添加为el的子节点，并且位于child之前，child参数为空则与appendChild方法效果一致el.removeChild(element); // 删除el的子节点el.replaceChild(new, old); // 用new替换old，new可以为新创建的节点也可以为已存在的节点el.hasChildNode(); // 判断节点是否包含子节点，包含返回true，不包含返回false.el.cloneChild(true/false); // 默认为false，只复制当前节点，为true时它的所有子节点也一起复制。它也是存在内存中，也需要向页面里添加。 操作元素属性12345678let attr = document.createAttribute(name); // 创建一个属性节点attr.value = "value"; // 为属性节点添加属性值el.setAttributeNode(attr); // 将一个属性节点添加到el上el.setAttribute(name, value); // 设置el上的属性，若此属性不存在则添加el.getAttribute(name); // 获取el上的属性el.removeAttribute(name); // 删除el上的属性el.id; // 元素的id名el.className; // 元素的class名 获取元素的高宽123456el.style.width/height; // 获取元素content的宽高，但是若未设置style会得到空，这个留待后面再说el.clientWidth/clientHeight; // 获取元素可视区的宽高，即为content+padding 元素相对于视窗可见部分的left和top，el.offsetWidth/offsetHeight; // 获取元素占位宽高，即为content+padding+border 相当于绝对定位的位置left和topel.scrollWidth/scrollHeight; // 与clientWidth类似，不过如果有滚轮会包括滚轮的宽度 // 滚轮的left和top// 注意，margin与以上都无关let W = document.body.clientWidth || window.innerWidth || document.documentElement.clientWidth; // 获取整个浏览器的可视区宽度，由于IE与firefox的实现有差异，所以需要兼容性写法 文档碎片化处理js操作dom是一个很耗性能的过程，在某些情况下，不得不进行dom循环操作，我们每次对dom的操作都会触发”重排”，这严重影响到能耗，一般通常采取的做法是尽可能的减少dom操作来减少”重排”。面对循环操作dom的过程，我们选择使用文档碎片（creatDocumentFragment），将需要添加到dom中的内容都添加到文档碎片中，然后一次性的将文档碎片添加到dom树，这样就可以有效的减少操作dom的次数，减少重排的发生。1234567891011121314&lt;ul id="list"&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function()&#123; var oFragment = document.createDocumentFragment(); var ul = document.getElementById("list"); var oLi = null; for(var i= 0;i&lt;10;i++)&#123; oLi = document.createElement("li"); oLi.appendChild(document.createTextNode('item'+(i))); oFragment.appendChild(oLi); &#125; ul.appendChild(oFragment); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome控制台console用法]]></title>
    <url>%2F2017%2F06%2F07%2FChrome%E4%B8%ADconsole%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面我们来看看console里面具体提供了哪些方法可以供我们平时调试时使用。console.dir(console);可以看到有很多方法，下面主要介绍常用的几种方法。 ## 输出信息的四种方法1234console.log();// 用于输出普通信息console.info();// 用于输出提示性信息（蓝色叹号）console.error();// 用于输出错误信息（红色X号）console.warn();// 用于输出警告信息（黄色叹号） console.count() 统计1234567function fn()&#123; // blah blah.... console.count("fn执行次数：");&#125;fn(); // fn执行次数：1fn(); // fn执行次数：2fn(); // fn执行次数：3 console.dir() 输出DOM树 查看对象方法123456789var myObject = &#123; a:"1", b:2, c:true, myFunc: function()&#123; alert("Hello world"); &#125;&#125;;console.dir(myObject); console.time 计时12345678// console.time()搭配console.timeEnd()一起使用;// 使用console.time统计实例化10000个对象所用时间console.time("Array initalize");var arr = new Array(10000);for(var i = arr.length -1;i&gt;= 0;i--)&#123; arr[i] = new Object();&#125;console.timeEnd("Array initalize"); keys和valueskeys和values 前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。123var myObj = &#123;"name": "xiaoming","age": 24,"sex":"male"&#125;;keys(myObj); //["name","age","sex"]values(myObj); //["xiaoming",24,"male"] 支持类jQuery选择器Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节。如输入$(‘body’)查看对应DOM树。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之非构造函数的继承]]></title>
    <url>%2F2017%2F06%2F01%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是”非构造函数”的继承？比如，现在有一个对象，叫做”中国人”。123var Chinese = &#123; nation:'中国'&#125;; 还有一个对象，叫做”医生”。123var Doctor =&#123; career:'医生'&#125; 请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。 object()方法json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。使用的时候，第一步先在父对象的基础上，生成子对象：1var Doctor = object(Chinese); 然后，再加上子对象本身的属性：1Doctor.career = '医生'; 这时，子对象已经继承了父对象的属性了。1alert(Doctor.nation); //中国 深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写：1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：12Chinese.birthPlaces = ['北京','上海','香港'];Doctor.birthPlaces.push('厦门'); 这时，父对象就不会受到影响了。12alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 目前，jQuery库使用的就是这种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之构造函数的继承]]></title>
    <url>%2F2017%2F05%2F27%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[前言今天要介绍的是，对象之间的”继承”的五种方法。比如，现在有一个”动物”对象的构造函数。123function Animal()&#123; this.species = "动物";&#125; 还有一个”猫”对象的构造函数。1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 怎样才能使”猫”继承”动物”呢？ 构造函数绑定第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 prototype模式第二种方法更常见，使用prototype属性。如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。1Cat.prototype = new Animal(); 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？1Cat.prototype.constructor = Cat; 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。1alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。1alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！1alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。1o.prototype.constructor = o; 直接继承prototype第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。现在，我们先将Animal对象改写：12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。所以，上面这一段代码其实是有问题的。请看第二行1Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！1alert(Animal.prototype.constructor); // Cat 利用空对象作为中介由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。1alert(Animal.prototype.constructor); // Animal 我们将上面的方法，封装成一个函数，便于使用。12345678function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 使用的时候，方法如下123extend(Cat,Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 这个extend函数，就是YUI库如何实现继承的方法。另外，说明一点，函数体最后一行1Child.uber = Parent.prototype; 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 拷贝继承上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。首先，还是把Animal的所有不变属性，都放到它的prototype对象上。12function Animal()&#123;&#125;Animal.prototype.species = "动物"; 然后，再写一个函数，实现属性拷贝的目的。12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。使用的时候，这样写：123extend2(Cat, Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之封装]]></title>
    <url>%2F2017%2F05%2F24%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？ 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。1234var Cat = &#123; name : '', color : ''&#125; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。123456var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = "大毛"; // 按照原型对象的属性赋值cat1.color = "黄色";var cat2 = &#123;&#125;;cat2.name = "二毛";cat2.color = "黑色"; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 原始模式的改进我们可以写一个函数，解决代码重复的问题。123456function Cat(name,color) &#123; return &#123; name:name, color:color &#125;&#125; 然后生成实例对象，就等于是在调用函数：12var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。比如，猫的原型对象现在可以这样写:1234function Cat(name,color)&#123; this.name=name; this.color=color;&#125; 我们现在就可以生成实例对象了。1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：123456function Cat(name,color)&#123; this.name = name; this.color = color; this.type = "猫科动物"; this.eat = function()&#123;alert("吃老鼠");&#125;;&#125; 还是采用同样的方法，生成实例：1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat ("二毛","黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。123456function Cat(name,color)&#123; this.name = name; this.color = color;&#125;Cat.prototype.type = "猫科动物";Cat.prototype.eat = function()&#123;alert("吃老鼠")&#125;; 然后，生成实例。1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。1alert(cat1.eat == cat2.eat); //true Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。12alert(Cat.prototype.isPrototypeOf(cat1)); //truealert(Cat.prototype.isPrototypeOf(cat2)); //true hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。12alert(cat1.hasOwnProperty("name")); // truealert(cat1.hasOwnProperty("type")); // false in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。12alert("name" in cat1); // truealert("type" in cat1); // true in运算符还可以用来遍历某个对象的所有属性。``js for(var prop in cat1){ alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想]]></title>
    <url>%2F2017%2F05%2F22%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[jQuery是目前使用最广泛的javascript函数库。 选择网页元素jQuery的基本设计思想和主要用法，就是 “选择某个网页元素，然后对其进行某种操作”。这是它区别于其他Javascript库的根本特点。使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。选择表达式可以是CSS选择器：1234$(document) //选择整个文档对象$('#myId') //选择ID为myId的网页元素$('div.myClass') // 选择class为myClass的div元素$('input[name=first]') // 选择name属性等于first的input元素 也可以是jQuery特有的表达式：123456$('a:first') //选择网页中第一个a元素$('tr:odd') //选择表格的奇数行$('#myForm :input') // 选择表单中的input元素$('div:visible') //选择可见的div元素$('div:gt(2)') // 选择所有的div元素，除了前三个$('div:animated') // 选择当前处于动画状态的div元素 改变结果集jQuery设计思想之二，就是提供各种强大的过滤器，对结果集进行筛选，缩小选择结果。12345$('div').has('p'); // 选择包含p元素的div元素$('div').not('.myClass'); //选择class不等于myClass的div元素$('div').filter('.myClass'); //选择class等于myClass的div元素$('div').first(); //选择第1个div元素$('div').eq(5); //选择第6个div元素 有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery也提供了在DOM树上的移动方法：12345$('div').next('p'); //选择div元素后面的第一个p元素$('div').parent(); //选择div元素的父元素$('div').closest('form'); //选择离div最近的那个form父元素$('div').children(); //选择div的所有子元素$('div').siblings(); //选择div的同级元素 链式操作jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如：1$('div').find('h3').eq(2).html('Hello'); 分解开来，就是下面这样：1234$('div') //找到div元素 .find('h3') //选择其中的h3元素 .eq(2) //选择第3个h3元素 .html('Hello'); //将它的内容改为Hello 这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。jQuery还提供了.end()方法，使得结果集可以后退一步：1234567$('div') .find('h3') .eq(2) .html('Hello') .end() //退回到选中所有的h3元素的那一步 .eq(0) //选中第一个h3元素 .html('World'); //将它的内容改为World 元素的操作：取值和赋值操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。jQuery设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即”取值器”与”赋值器”合一。到底是取值还是赋值，由函数的参数决定。12$('h1').html(); //html()没有参数，表示取出h1的值$('h1').html('Hello'); //html()有参数Hello，表示对h1进行赋值 常见的取值和赋值函数如下：123456.html() //取出或设置html内容.text() //取出或设置text内容.attr() //取出或设置HTML某个我们自定义DOM属性的值.prop() 取出或设置HTML某个本身固有属性的值.width() //取出或设置某个元素的宽度.height() //取出或设置某个元素的高度.val() //取出某个表单元素的值 需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。 元素的操作：移动jQuery设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。假定我们选中了一个div元素，需要把它移动到p元素后面。第一种方法是使用.insertAfter()，把div元素移动p元素后面：1$('div').insertAfter($('p')); 第二种方法是使用.after()，把p元素加到div元素前面：1$('p').after($('div')); 表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。使用这种模式的操作方法，一共有四对：1234.insertAfter()和.after()：//在现存元素的外部，从后面插入元素.insertBefore()和.before()：//在现存元素的外部，从前面插入元素.appendTo()和.append()：//在现存元素的内部，从后面插入元素.prependTo()和.prepend()：//在现存元素的内部，从前面插入元素 元素的操作：复制、删除和创建除了元素的位置移动之外，jQuery还提供其他几种操作元素的重要方法。复制元素使用.clone()。删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。清空元素内容（但是不删除该元素）使用.empty()。创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：123$('&lt;p&gt;Hello&lt;/p&gt;');$('&lt;li class="new"&gt;new list item&lt;/li&gt;');$('ul').append('&lt;li&gt;list item&lt;/li&gt;'); 工具方法jQuery设计思想之六：除了对选中的元素进行操作以外，还提供一些与元素无关的工具方法（utility）。不必选中元素，就可以直接使用这些方法。如果你懂得Javascript语言的继承原理，那么就能理解工具方法的实质。它是定义在jQuery构造函数上的方法，即jQuery.method()，所以可以直接使用。而那些操作元素的方法，是定义在构造函数的prototype对象上的方法，即jQuery.prototype.method()，所以必须生成实例（即选中元素）后使用。如果不理解这种区别，问题也不大，只要把工具方法理解成，是像javascript原生函数那样，可以直接使用的方法就行了。常用的工具方法有以下几种：123456789101112$.trim() //去除字符串两端的空格。$.each() //遍历一个数组或对象。$.inArray() //返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。$.grep() //返回数组中符合某种标准的元素。$.extend() //将多个对象，合并到第一个对象。$.makeArray() //将对象转化为数组。$.type() //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。$.isArray() //判断某个参数是否为数组。$.isEmptyObject() //判断某个对象是否为空（不含有任何属性）。$.isFunction() //判断某个参数是否为函数。$.isPlainObject() //判断某个参数是否为用"&#123;&#125;"或"new Object"建立的对象。$.support() //判断浏览器是否支持某个特性。 事件操作jQuery设计思想之七，就是把事件直接绑定在网页元素之上。123$('p').click(function()&#123; alert('Hello');&#125;); 目前，jQuery主要支持以下事件：1234567891011121314151617181920212223242526.blur() //表单元素失去焦点。.change() //表单元素的值发生变化.click() //鼠标单击.dblclick() //鼠标双击.focus() //表单元素获得焦点.focusin() //子元素获得焦点.focusout() //子元素失去焦点.hover() //同时为mouseenter和mouseleave事件指定处理函数.keydown() //按下键盘（长时间按键，只返回一个事件）.keypress() //按下键盘（长时间按键，将返回多个事件）.keyup() //松开键盘.load() //元素加载完毕.mousedown() //按下鼠标.mouseenter() //鼠标进入（进入子元素不触发）.mouseleave() //鼠标离开（离开子元素不触发）.mousemove() //鼠标在元素内部移动.mouseout() //鼠标离开（离开子元素也触发）.mouseover() //鼠标进入（进入子元素也触发）.mouseup()//松开鼠标.ready() //DOM加载完成.resize() //浏览器窗口的大小发生改变.scroll() //滚动条的位置发生变化.select() //用户选中文本框中的内容.submit() //用户递交表单.toggle() //根据鼠标点击的次数，依次运行多个函数.unload() //用户离开页面 以上这些事件在jQuery内部，都是.bind()的便捷方式。使用.bind()可以更灵活地控制事件，比如为多个事件绑定同一个函数：123456$('input').bind( 'click change', //同时绑定click和change事件 function() &#123; alert('Hello'); &#125;); 现在应该是使用on代替bind了。。有时，你只想让事件运行一次，这时可以使用.one()方法。123$("p").one("click", function() &#123; alert("Hello"); //只运行一次，以后的点击不会运行&#125;); .unbind()用来解除事件绑定。1$('p').unbind('click'); 所有的事件处理函数，都可以接受一个事件对象（event object）作为参数，比如下面例子中的e：123$("p").click(function(e) &#123; alert(e.type); // "click"&#125;); 这个事件对象有一些很有用的属性和方法：12345678event.pageX //事件发生时，鼠标距离网页左上角的水平距离event.pageY //事件发生时，鼠标距离网页左上角的垂直距离event.type //事件的类型（比如click）event.which //按下了哪一个键event.data //在事件对象上绑定数据，然后传入事件处理函数event.target //事件针对的网页元素event.preventDefault() //阻止事件的默认行为（比如点击链接，会自动打开新页面）event.stopPropagation() //停止事件向上层元素冒泡 在事件处理函数中，可以用this关键字，返回事件针对的DOM元素：123456$('a').click(function(e) &#123; if ($(this).attr('href').match('evil')) &#123; //如果确认为有害链接 e.preventDefault(); //阻止打开 $(this).addClass('evil'); //加上表示有害的class &#125;&#125;); 有两种方法，可以自动触发一个事件。一种是直接使用事件函数，另一种是使用.trigger()或.triggerHandler()。12$('a').click();$('a').trigger('click'); 特殊效果最后，jQuery允许对象呈现某些特殊效果。常用的特殊效果如下：123456789.fadeIn() //淡入.fadeOut() //淡出.fadeTo() //调整透明度.hide() //隐藏元素.show() //显示元素.slideDown() //向下展开.slideUp() //向上卷起.slideToggle() //依次展开或卷起某个元素.toggle() //依次展示或隐藏某个元素 除了.show()和.hide()，所有其他特效的默认执行时间都是400ms（毫秒），但是你可以改变这个设置。12$('h1').fadeIn(300); // 300毫秒内淡入$('h1').fadeOut('slow'); // 缓慢地淡出 在特效结束后，可以指定执行某个函数。1$('p').fadeOut(300, function() &#123; $(this).remove(); &#125;); 更复杂的特效，可以用.animate()自定义。12345678$('div').animate( &#123; left : "+=50", //不断右移 opacity : 0.25 //指定透明度 &#125;, 300, // 持续时间 function() &#123; alert('done!'); &#125; //回调函数); .stop()和.delay()用来停止或延缓特效的执行。$.fx.off如果设置为true，则关闭所有网页特效。原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的this用法]]></title>
    <url>%2F2017%2F05%2F21%2FJavaScript%E7%9A%84this%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如:123function test()&#123; this.x = 1;&#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。下面分四种情况，详细讨论this的用法。 纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。请看下面这段代码，它的运行结果是1。12345function test()&#123; this.x = 1; alert(this.x);&#125;test(); // 1 为了证明this就是全局对象，我对代码做一些改变：12345var x = 1;function test()&#123; alert(this.x);&#125;test(); // 1 运行结果还是1。再变一下：123456var x = 1;function test()&#123; this.x = 0;&#125;test();alert(x); //0 作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function test()&#123; this.x = 1;&#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：123456var x = 2;function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为1o.m.apply(o); // 1 运行结果就变成了1，证明了这时this代表的是对象o。 原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用缓存解决js递归调用性能问题]]></title>
    <url>%2F2017%2F05%2F20%2F%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3js%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述斐波那契序列通常是用来解释递归调用。12345function fibonacci(n) &#123; if(n==0 || n == 1) return n; return fibonacci(n-1) + fibonacci(n-2);&#125; 这个算法以教学为目的,但非常低效的,不仅因为递归,而且两次调用fibonacci函数,在函数里面右侧调用的fibonacci(n-2) 在表达式左侧调用fibonacci(n-1)时就已完全计算过一遍。 这个算法效率是如此之低,斐波纳契数超过50的实在太多了。你可以去喝杯咖啡或去睡午觉时等待答案。但如果你就用这个代码在codewars上很可能得到一个超时错误。 对于这个特定卡塔(类似打怪升级里面的级数)，我们想实现缓存的解决方案。这是特别酷的,因为它将让我们继续使用递归算法,同时仍然保持足够迅速的得到一个答案。 memoize的版本的诀窍是,保持一个缓存数据结构(最有可能的关联数组),将斐波纳契数列的值缓存。当获取一个斐波那契数列值时,首先在缓存中查找，如果有则直接返回值,如果没有,再计算并把它放进缓存。 使用memoize的数据结构重构函数的递归Fibonacci以避免递归调用的缺陷。 分析斐波那契数列里面不断的递归调用自身，列入输入的是 70，那么需要计算69和68的值。在计算69的过程中又计算了 68、67、、、、、1。 计算 68的过程又计算了 67、66、、、、、、、1的值，如此重复计算的值太多了，花费的时间也就比较多。 缓存思想恰好可以减少不必要的重复计算。当第一遍计算69的值时就递归计算了 68、67、66、、、1的值，之后的每次都先查看是否有缓存，有就直接返回缓存值，避免了重复计算。 代码12345678910let cache = &#123;&#125;;let fibonacci = function(n) &#123; if(n==0 || n == 1) return n; if(cache[n])&#123; return cache[n]; &#125; return cache[n] = fibonacci(n-1) + fibonacci(n-2);&#125; 性能测试1234567891011121314151617181920212223242526272829//没有缓存时let tesetNum = 40;console.time('NoCache');function fibonacci1(n) &#123; if(n==0 || n == 1) return n; return fibonacci1(n-1) + fibonacci1(n-2);&#125;fibonacci1(tesetNum);console.timeEnd('NoCache');// 使用缓存时console.time("HasCache");let cache = &#123;&#125;;let fibonacci = function(n) &#123; if(n==0 || n == 1) return n; if(cache[n])&#123; return cache[n]; &#125; return cache[n] = fibonacci(n-1) + fibonacci(n-2);&#125;fibonacci(tesetNum);console.timeEnd('HasCache');// 输出// NoCache: 1717.834ms// HasCache: 0.159ms 通过性能测试可以看到，当测试数是40时不适用缓存消耗的时间就是使用缓存的1700多倍(好可怕的数据)，我试了下当测试数据是300时，，，，，，，，我就等不急它的执行了。 使用场景当递归调用里有大量重复计算的情景，或者组件、数据等重复加载的情况下，使用缓存是个不错的选择(典型的以空间换时间)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组去重的6中方法]]></title>
    <url>%2F2017%2F05%2F17%2FJavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%846%E4%B8%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目说明:题目123声明一个数组,将数组中的相同元素过滤掉,然后存入到一个新数组resultArr = []中;var arr = [1, 2, 3, 1, 3, 4, 5, 5];var resultArr = []//该数组的结果应该为1,2,3,4,5 基本思路:1.采用循环嵌套2.外层循环将数组中的值赋给新的数组3.内层循环通过if语句判断新数组中是否有该值,如果有,则在外层循环中通过if语句判断,让元素不赋给新数组. 方法解析比较内层循环变量的值.12345678910111213141516var arr = [1, 2, 3, 1, 3, 4, 5, 5];var resultArr = [];//外层循环进行赋值for (i = 0; i &lt; arr.length; i++) &#123; //内层循环进行重复判断 for (j = 0; j &lt; resultArr.length; j++) &#123; if (resultArr[j] == arr[i]) &#123; break;//一旦有重复arr[i],跳出循环 &#125; &#125; //如果resultArr这个数组中没有arr[i],那么j经过内层循环后没有break,值应为resultArr.length if (j == resultArr.length) &#123; resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr); //1,2,3,4,5 计数法.1234567891011121314151617var arr = [1, 2, 3, 1, 3, 4, 5, 5];var count; //声明一个变量,用来计数var resultArr = [];for (i = 0; i &lt; arr.length; i++) &#123; count = 0; //每次初始化计数变量 for (j = 0; j &lt; resultArr.length; j++) &#123; if (resultArr[j] == arr[i]) &#123; count++; //一旦进入该if语句,则计数变量自加 break; &#125; &#125; //如果count等于0 ,那么说明内层循环中没有进入if语句,则resultArr中没有和arr[i]重复的元素 if (count == 0) &#123; resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr); //1,2,3,4,5 flag标志法(也叫假设成立法)1234567891011121314151617var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr = []; //[1,2,3]var flag; //声明一个变量,用来当做假设变量for (var i = 0; i &lt; arr.length; i++) &#123; flag = true; //每次初始化假设变量,假设result中没有和arr[i]重复的元素,赋值true, for (j = 0; j &lt; resultArr.length; j++) &#123; if (resultArr[j] == arr[i]) &#123; flag = false; //一旦进入该if语句,则表示resultArr中有重复的的arr[i],则假设不成立,赋值false break; &#125; &#125; //如果flag为ture,赋值给resultArr这个数组 if (flag) &#123; resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr);//1,2,3,4,5 使用sort()方法排序后比较12345678910111213141516var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr = [];//使用数组的sort()方法对arr进行排序,也可以使用冒泡排序arr.sort(function (a, b) &#123; return a - b;&#125;);//排序后,arr变成了[1, 1, 2, 2, 3, 3, 4, 5, 5]//使用for循环,从上面的数组可以看出,如果数组元素arr[i]和arr[i+1]不相等,则表示arr[i]之后不再有与arr[i]相等的重复元素for (i = 0; i &lt; arr.length; i++) &#123; if (arr[i] != arr[i + 1]) &#123; //将arr[i]赋值给resultArr数组. resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr); //1,2,3,4,5 使用filter()方法比较123456789var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr;//采用filter()方法过滤掉数组中重复的元素,filter()方法中传入一个过滤函数作为参数.resultArr = arr.filter(function (item, index, self) &#123; //indexOf返回的是arr中的第一个元素的索引值,所以下面语句过滤掉了arr中重复的元素. return self.indexOf(item) == index;&#125;);console.log(resultArr); //1,2,3,4,5 使用缓存对象方法比较12345678910var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr = [];var cache = &#123;&#125;; //声明一个缓存对象for(var i = 0 ; i &lt; arr.length; i ++)&#123;//循环数组arr if(!cache[arr[i]])&#123;//进行判断,如果缓存对象中没有这个属性名的话,我们就把该数组赋值给resultArr,并把该属性名赋值为true cache[arr[i]] = true; resultArr.push(arr[i]); &#125;&#125;console.log(resultArr);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async详解之流程控制]]></title>
    <url>%2F2017%2F05%2F02%2Fasync%E8%AF%A6%E8%A7%A3(1)%2F</url>
    <content type="text"><![CDATA[“流程控制”本来是件比较简单的事，但是由于Nodejs的异步架构的实现方法，对于需要同步的业务逻辑，实现起来就比较麻烦。嵌套3-4层，代码就会变得的支离破碎了！ Async介绍Async是一个流程控制工具包，提供了直接而强大的异步功能。基于Javascript为Node.js设计，同时也可以直接在浏览器中使用。Async提供了大约20个函数，包括常用的 map, reduce, filter, forEach 等，异步流程控制模式包括，串行(series)，并行(parallel)，瀑布(waterfall)等。 安装与调用 安装1npm install --save async 调用123var async = require("async");// 或者var waterfall = require("async/waterfall"); 使用由于nodejs是异步编程模型，有一些在同步编程中很容易做到的事情，现在却变得很麻烦。Async的流程控制就是为了简化这些操作。 series(tasks, [callback]) （多个函数依次执行，之间没有数据交换）有多个异步函数需要依次调用，一个完成之后才能执行下一个。各函数之间没有数据的交换，仅仅需要保证其执行顺序。这时可使用series。纯js代码：1234567step1(function(err, v1) &#123; step2(function(err, v2) &#123; step3(function(err, v3) &#123; // do somethig with the err or values v1/v2/v3 &#125; &#125;&#125;); 从中可以看到这嵌套还是比较多深的，如果再多几步，会更深。在代码中忽略对了每一层err的处理，否则还都等加上 if(err) return callback(err)，那就更麻烦了。对于这种情况，使用async来处理，就是这样的：12345678910111213141516171819202122232425262728293031// 数组形式async.series([ function(callback) &#123; // do some stuff ... callback(null, 'one'); &#125;, function(callback) &#123; // do some more stuff ... callback(null, 'two'); &#125;],// optional callbackfunction(err, results) &#123; // results is now equal to ['one', 'two']&#125;);// json形式（可读性更高）async.series(&#123; one: function(callback) &#123; setTimeout(function() &#123; callback(null, 1); &#125;, 200); &#125;, two: function(callback)&#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;&#125;, function(err, results) &#123; // results is now equal to: &#123;one: 1, two: 2&#125;&#125;); 该函数的详细解释为： 依次执行一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。 如果任何一个函数向它的回调函数中传了一个error，则后面的函数都不会被执行，并且将会立刻会将该error以及已经执行了的函数的结果，传给series中最后那个callback。 当所有的函数执行完后（没有出错），则会把每个函数传给其回调函数的结果合并为一个数组，传给series最后的那个callback。 还可以json的形式来提供tasks。每一个属性都会被当作函数来执行，并且结果也会以json形式传给series最后的那个callback。这种方式可读性更高一些。另外还需要注意的是：多个series调用之间是不分先后的，因为series本身也是异步调用。详细示例 parallel(tasks, [callback]) （多个函数并行执行）并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。如果某个函数出错，则立刻将err和已经执行完的函数的结果值传给parallel最终的callback。其它未执行完的函数的值不会传到最终数据，但要占个位置。同时支持json形式的tasks，其最终callback的结果也为json形式。示例代码：12345678910111213141516171819202122232425262728293031323334// 数组形式async.parallel([ function(callback) &#123; setTimeout(function() &#123; callback(null, 'one'); &#125;, 200); &#125;, function(callback) &#123; setTimeout(function() &#123; callback(null, 'two'); &#125;, 100); &#125;],// optional callbackfunction(err, results) &#123; // the results array will equal ['one','two'] even though // the second function had a shorter timeout.&#125;);// an example using an object instead of an arrayasync.parallel(&#123; one: function(callback) &#123; setTimeout(function() &#123; callback(null, 1); &#125;, 200); &#125;, two: function(callback) &#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;&#125;, function(err, results) &#123; // results is now equals to: &#123;one: 1, two: 2&#125;&#125;); 详细示例 waterfall(tasks, [callback]) （多个函数依次执行，且前一个的输出为后一个的输入）与seires相似，按顺序依次执行多个函数。不同之处，每一个函数产生的值，都将传给下一个函数。如果中途出错，后面的函数将不会被执行。错误信息以及之前产生的结果，将传给waterfall最终的callback。这个函数名为waterfall(瀑布)，可以想像瀑布从上到下，中途冲过一层层突起的石头。注意，该函数不支持json格式的tasks。123456789101112131415161718192021222324252627282930313233343536async.waterfall([ function(callback) &#123; callback(null, 'one', 'two'); &#125;, function(arg1, arg2, callback) &#123; // arg1 now equals 'one' and arg2 now equals 'two' callback(null, 'three'); &#125;, function(arg1, callback) &#123; // arg1 now equals 'three' callback(null, 'done'); &#125;], function (err, result) &#123; // result now equals 'done'&#125;);// Or, with named functions:async.waterfall([ myFirstFunction, mySecondFunction, myLastFunction,], function (err, result) &#123; // result now equals 'done'&#125;);function myFirstFunction(callback) &#123; callback(null, 'one', 'two');&#125;function mySecondFunction(arg1, arg2, callback) &#123; // arg1 now equals 'one' and arg2 now equals 'two' callback(null, 'three');&#125;function myLastFunction(arg1, callback) &#123; // arg1 now equals 'three' callback(null, 'done');&#125; 详细示例 auto(tasks, [callback]) （多个函数有依赖关系，有的并行执行，有的依次执行）用来处理有依赖关系的多个任务的执行。比如某些任务之间彼此独立，可以并行执行；但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。虽然我们可以使用async.parallel和async.series结合起来实现该功能，但如果任务之间关系复杂，则代码会相当复杂，以后如果想添加一个新任务，也会很麻烦。这时使用async.auto，则会事半功倍。如果有任务中途出错，则会把该错误传给最终callback，所有任务（包括已经执行完的）产生的数据将被忽略。这里假设我要写一个程序，它要完成以下几件事：(1) 从某处取得数据(2) 在硬盘上建立一个新的目录(3) 将数据写入到目录下某文件(4) 发送邮件，将文件以附件形式发送给其它人。分析该任务，可以知道1与2可以并行执行，3需要等1和2完成，4要等3完成。12345678910111213141516171819202122232425262728293031async.auto(&#123; get_data: function(callback) &#123; console.log('in get_data'); // async code to get some data callback(null, 'data', 'converted to array'); &#125;, make_folder: function(callback) &#123; console.log('in make_folder'); // async code to create a directory to store a file in // this is run at the same time as getting the data callback(null, 'folder'); &#125;, write_file: ['get_data', 'make_folder', function(results, callback) &#123; console.log('in write_file', JSON.stringify(results)); // once there is some data and the directory exists, // write the data to a file in the directory callback(null, 'filename'); &#125;], email_link: ['write_file', function(results, callback) &#123; console.log('in email_link', JSON.stringify(results)); // once the file is written let's email a link to it... // results.write_file contains the filename returned by write_file. callback(null, &#123;'file':results.write_file, 'email':'user@example.com'&#125;); &#125;]&#125;, function(err, results) &#123; console.log('err = ', err); console.log('results = ', results); // -&gt; &#123; makeFolder: undefined, // getData: undefined, // writeFile: 'myfile', // emailFiles: 'myfile' &#125;&#125;); 详细示例]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组操作总结]]></title>
    <url>%2F2017%2F04%2F30%2FJavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数组的创建数组的创建有两种方法，一种是通过字面量，另一种是通过Array构造函数。 字面量1var num1 = [1,2,3]; 值得注意的是，利用字面量创建数组时，不可在最后一个数组元素添加“,”，因为在老版本的浏览器中，会出现bug。 Array构造函数1var num2 = new Array();//空数组 Array()可接收包含项作为参数，这时，会创建包含传入项的数组，如num3。也可接收一个类型为number的数字作为参数，这时，会创建数组长度为该数字的数组，如num5。 123var num3 = new Array("1","2","3");//相当于["1","2","3"]var num4 = new Array(3);//length为3，元素均为undefined的数组var num5 = new Array(3).fill("1",0,2); //["1","1","1",undefined] 数组的转换关于数组的转换，这里只提数组转换成字符串的两种方法。分别是toString()和join()。 toString()该方法会返回数组各个项以逗号隔开的字符串。在使用alert(array)方法打印数组时，会隐性调用toString()方法。 123var num6 = [1,2,3];var num6Str = num6.toString();//"1,2,3"alert(num6);//"1,2,3" join()join()只接收一个参数，该参数为数组中各项拼接的字符串，若不传参，默认为用“,”作为分隔符，效果相当于toString()方法。 123var num7 = [1,2,3];num7.join("$");//"1$2$3"num7.join();//"1,2,3" 栈方法栈是一种先进先出的数据结构，而数组提供的push()和pop()方法类似栈的行为，所以叫栈方法。 push()push()方法可以接收多个参数，把它们依次添加至数组末尾，并返回修改后数组长度。 1234var num8 = [1,2,3];var num8Length = num8.push(4,5);alert(num8);//1,2,3,4,5alert(num8Length);//5 pop()pop()方法是将数组的最后一项移除，并返回移除项。 12var num9 = [1,2,3];var last = num9.pop();//3 队列方法shift()shift()方法是将数组的第一项移除，并返回移除项。 12var num10 = [1,2,3];var first = num10.shift();//1 unshift()unshift()方法与shift()方法用途相反，该方法可以接收多个参数，将参数依次加入数组的前端，并返回修改后数组的长度。 12var num11 = [1,2,3];var addArray = num11.unshift("-1","0");//5 重排序方法reverse()reverse()方法是使数组中的项进行反转，并返回经过排序后的数组。 12var num12 = [1,2,3];num12.reverse();//[3,2,1] sort()sort()方法是默认为按照ASCII码进行顺序排序。在使用sort()方法时，会先隐性调用toString()方法将数组中的每一项进行字符串转化，实际上是进行字符串ASCII进行排序，并返回排序后的数组。 对于数组项中均为number类型的数据，我们可以在sort()中传入一个比较函数，该比较函数接收两个参数，第一个参数为前一项，第二个参数为后一项。将两个参数进行对比，若return的值&gt;0,则将两个对比项进行调换位置，调换位置的项，再与较前的一项进行对比，依次类推，直到return值返回为0或者&lt;0为止。 在比较函数中，return值&gt;0，数组项调换位置；return值&lt;0，数组项不调换位置；return值=0，意味着两项相等，数组项不调换位置。 12345var num13 = [3,2,7,14,111,0];num13.sort(function(value1,value2)&#123; return value1-value2;&#125;);alert(num13);//0,2,3,7,14,111 操作方法concat()concat()方法是将数组与数组进行连结或者将数组项添加至数组末尾。 concat()会创建当前数组的一个副本，然后将接收到的参数依次添加到这个副本的末尾。如果没有传入参数，则返回的是当前数组的副本，相当于数组的复制；如果传入一个或多个数组参数，则会在副本的末尾依次添加数组参数中的每一个项；如果传入的是一个或多个非数组类型的数据，则这些值会依次被添加至副本的末尾。 注：可利用concat()方法返回一个新数组的特性用于数组的复制。 12345var num14 = [1,2,3];var num15 = num14.concat([4,5],[6,7]);alert("参数为多个数组时："+num15);//1,2,3,4,5,6,7var num16 = num14.concat(4,5);alert("参数为非数组时："+num16);//1,2,3,4,5 slice()slice()可以基于当前数组中的一个或多个项创建一个新的数组，并返回新的数组。 slice()可以接收一个或两个参数，即要返回项的起始位置和结束位置。当只有一个参数时，会返回从该参数指定的位置开始到数组的末尾位置；传入两个参数时，会返回从起始位置到结束位置前一项的数组项。 注：可利用slice(0)方法返回一个新数组的特性用于数组的复制。 123var num17 = [1,2,3];num17.slice(1);//[2,3]num17.slice(1,2);//[2] splice()splice()方法是比较强大的数组操作方法。因为可以利用该方法对数组进行删除，插入和替换操作。删除：splice(index,number)，只需要传入两个参数，index为删除的第一项位置，number为删除的项数。插入：splice(index,0,value1,value2,…)，需要至少传入三个参数，index为从位置index处插入value1,value2…。替换：splice(index,number,value1,value2…)，需要至少传入三个参数，index为开始替换的位置，number为替换的项数，value1，value2等是替换的项。返回值：splice()方法返回的始终是一个数组，若有删除项，则返回含有所有被删除项的数组，若没有删除项，这返回空数组。 1234567var num18 = [1,2,3];//删除操作num18.splice(0,2);//返回[1,2]，此时num18 = [3]//插入操作num18.splice(1,0,4,5,6);//返回[]，此时num18 =[3,4,5,6]//替换操作num18.splice(2,2,3,3);//返回[5,6]，此时num18 = [3,4,3,3] 位置方法位置方法包含了两种方法，分别为indexOf()和lastIndexOf()，两个方法都接收两个参数，第一个参数为查找项，第二个参数（可选）为查找的起始位置，都返回查找项所出现的第一个位置，没有找到则返回-1。查找项和数组中的每一项进行比较时，使用使用的是全等操作符===，故需要值和数据类型一致。 indexOf()indexOf(value)该方法是从数组的开头开始查找值为value的项。indexOf(value,index)该方法是从下标为index的项开始查找值为value的项。 123var num19 = [1,2,3];num19.indexOf(1);//返回0num19.indexOf(3,1);//返回2 lastIndexOf()lastIndexOf(value)该方法是从数组的末尾开始查找值为value的项。lastIndexOf(value,index)该方法是从数组末尾开始往前（从0开始）index的项开始向数组开头查找值为value的项。 123var num20 = [1,2,3];num20.lastIndexOf(1);//返回0num20.lastIndexOf(1,1);//返回0 迭代方法every()every(function(item,index,array){reutrn…;})对数组的每一项都传入给定函数，如该函数对每一项都返回true，则返回true，否则为false。（类似且操作符） 1234567var num21 = [1,2,3];var every = num21.every(function(item,index,array)&#123; return (item&gt;0);&#125;);//truevar every1 = num21.every(function(item,index,array)&#123; return (item&gt;2)&#125;);//false some()some(function(item,index,array){return…})对数组的每一项都传入给定函数，如函数对某一项返回true，则返回true，否则为false。（类似或操作符） 1234567var num22 = [1,2,3];var some= num21.some(function(item,index,array)&#123; return (item&gt;2);&#125;);//truevar some1= num22.some(function(item,index,array)&#123; return (item&gt;6)&#125;);//false forEach()forEach(function(item,index,array){})对数组的每一项都传入给定函数，没有返回值。（类似for循环） 1234var num23 = [1,2,3];num23.forEach(function(item,index,array)&#123; console.log(item);&#125;); map()map(function(item,index,array){})对数组的每一项都传入给定函数，返回值为对数组操作后的数组。 1234var num24 = [1,2,3];num24.map(function(item,index,array)&#123; return item+2;&#125;);//[3,4,5] filter()filter(function(item,index,array){})对数组的每一项都传入给定函数，返回值为给定函数返回为true的项组成的数组。 1234var num25 = [1,2,3];num25.filter(function(item,index,array)&#123; return (item&gt;2);&#125;);//[3] 归并方法归并方法有两个，分别为reduce()和reduceRight()。该两个方法接收两个参数，分别为给定函数和pre初始值（可选）。均迭代数组的每一项传入给定函数，并构造一个最终返回值。 reduce()reduce(function(pre,cur,index,array){return…})从第一项开始，迭代时，会将给定函数返回的值作为pre参数给到下一次迭代，直到最后。cur指当前项，index为当前项下标，array为调用的数组。 123456789var num26 = [1,2,3];//只传给定函数num26.reduce(function(pre,cur,index,array)&#123; return pre+cur;&#125;);//6//传入给定函数和pre初始值num26.reduce(function(pre,cur,index,array)&#123; return pre+cur;&#125;,4);//10 reduceRight()reduceRight()和reduce()方法除了从数组的末尾还是开始开始遍历不同外，其他都一致。reduceRight()是从数组末尾开始遍历。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mygitbook]]></title>
    <url>%2F2017%2F04%2F23%2Fmygitbook%2F</url>
    <content type="text"><![CDATA[我的gitbook JavaScript半知半解]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2017%2F04%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[第一次写博客还是挺有感觉的，建立github pages, 使用hexo+next搭建博客，然后再把代码同步到github分支上，最后熬夜学习使用markdown写第一篇博客，本文末注有原文章地址，如有侵犯，请联系我，即刻纠错。下面一起来学习markdown语法吧。 目录区块元素 标题 列表 区块引用 代码区块 分隔线 段落和换行 首行缩进区段元素 链接 强调 代码 图片 转义 内容标题 分为两种形式：类Setext 和 atx形式 类Setext示例： 1234This is an H1===This is an H2--- atx形式示例: 12# This is an H1## This is an H2 列表 有序列表有序列表使用数字接着一个英文句点，以第一个数字为开始，依次增加，和你所写无关。示例： 123. Bird2. McHale 效果： Bird McHale 无序列表无序列表是使用, + , - , * 中任意一种来表示示例： 123+ red- green* blue 效果： red red1 green blue 引用 区块引用是使用类似email中用&gt;来表示示例：1234567891011121314&gt; 简单引用1&gt; 简单引用2&gt; &gt; 多行引用&gt;&gt; 嵌套引用&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec("echo $input | $markdown_script"); 效果： 简单引用1简单引用2 多行引用 嵌套引用 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $input | $markdown_script”); 代码区块建立代码区块,只需要简单地缩进4个空格或是1个制表符就可以代码块一直持续到没有缩进的那一行(或是文件的结尾)也可以使用 ` 来表示 代码块缩进 这是使用表示 的1在代码前后分别使用```表示 代码块1与原来使用缩进来添加代码块的语法不同，这里使用``` ```来包含多行代码： 1&lt;p&gt;hello world&lt;/p&gt; 代码高亮1在上面的代码块语法基础上，在第一组```之后添加代码的语言，如 &apos;javascript&apos; 或 &apos;js&apos;，即可将代码标记为 JavaScript： 123window.addEventListener('load', function() &#123; console.log('window loaded');&#125;); 分割线一行中用三个以上的星号、减号、底线来建立一个分隔线,行内不能有其他东西,也可以在星号或是减号中间插入空格。*** - - - * * * ___ 段落和换行 段落段落是由一个或多个连续的文本行组成，它的上下要一个以上的空行(显示上看起来像是空的) 换行Mardown允许段落内的强迫换行(插入换行符)要依赖Markdown来插入&lt;br/&gt;标签的话,在&lt;br/&gt;插入处要先按入两个以上的空格然后回车 链接支持两种形式的连接语法: 行内式和参考式 链接字符不区分大小写 行内式(推荐)This is baidu 1This is [baidu](http://www.baidu.com/) 参考式 12345This is [baidu example][id] reference-style link.标记: [id]: https://www.baidu.com/ &quot;度娘&quot;或者: [id]: https://www.baidu.com/ &apos;度娘&apos; (简书不支持)或者 [id]: https://www.baidu.com/ (度娘)(简书不支持使用对文本描述使用单引号) 隐式链接标记功能 12[Baidu][]标记可以这样写:[Baidu]: http://baidu.com 参考式链接范例 1234567891011--I get 10 times more traffic from [Google] [1] than from --[Yahoo] [2] or [MSN] [3]. --[1]: http://google.com/ &quot;Google&quot;--[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;--[3]: http://search.msn.com/ &quot;MSN Search&quot;--I get 10 times more traffic from [Google][] than from--[Yahoo][] or [MSN][].--[google]: http://google.com/ &quot;Google&quot;--[yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot;--[msn]: http://search.msn.com/ &quot;MSN Search&quot;(备注: 上述代码在使用时需删掉前面的--) 自动链接 1&lt;http:\\www.baidu.com&gt; 强调Markdown使用性星号(*)和底线()作为标记强调字词的符号 两端被一个或_包围的单词会被转换成斜体 两端被两个或包围的单词会被转换成粗体 *或的两端不能有空白 用什么符号就以什么符号结尾。_1234*斜体*_斜体_**粗体**__粗体__ 图片Markdown使用一种和链接很相似的语法来标记图片 允许两种样式:行内式和参考式 行内式（推荐） 12![Overload 仓助](http://img4.duitang.com/uploads/item/201508/19/20150819131018_vYPyR.thumb.224_0.png) ![Overload 仓助](http://img4.duitang.com/uploads/item/201508/19/20150819131018_vYPyR.thumb.224_0.png &quot;森林贤王&quot;) 自定义图片位置大小 1234// 直接在md文件中嵌入HTML代码&lt;div align='center'&gt; &lt;img src="./xx.jpg" width = "400" height = "300" alt="图片名称" /&gt;&lt;/div&gt; 参考式 123--![Overload 仓助][xd]--[xd]:http://img4.duitang.com/uploads/item/201508/19/20150819131018_vYPyR.thumb.224_0.png &quot;森林贤王&quot;(备注: 上述代码在使用时需删掉前面的--) 转义使用反斜杠来插入一些在语法中有其它意义的符号,如* 需要转义的字符:123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 首行缩进&emsp;&emsp;写文章时，我们常常希望能够首行缩进，这时可以在段首加入&amp;ensp;来输入一个空格.加入&amp;emsp;来输入两个空格。 本文参考自http://www.jianshu.com/p/075d7cac8fef 删除线这就是~~删除线~~ 这就是删除线 表格单元格和表头使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：1234name | age---- | ---LearnShare | 12Mike | 32 name age LearnShare 12 Mike 32 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界：1234| name | age || ---------- | --- || LearnShare | 12 || Mike | 32 | name age LearnShare 12 Mike 32 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 对齐在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： :— 代表左对齐 :–: 代表居中对齐 —: 代表右对齐 1234| left | center | right || :--- | :----: | ----: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。 插入其他内容表格中可以插入其他 Markdown 中的行内标记：1234| name | age | blog || ------------ | --- | ------------------------------- || _LearnShare_ | 12 | [LearnShare](http://xianbai.me) || __Mike__ | 32 | [Mike](http://mike.me) | name age blog LearnShare 12 LearnShare Mike 32 Mike]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + hexo + next]]></title>
    <url>%2F2017%2F04%2F19%2FgithubPages%2F</url>
    <content type="text"><![CDATA[如何配置hexo + github page,请点击Github Pages + Hexo 搭建博客如何搭建一个独立博客——简明Github Pages与Hexo教程Markdown语法教程使用hexo，如果换了电脑怎么更新博客？ let’s go!]]></content>
      <categories>
        <category>GitHub Pages</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F02%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" #新建文件 More info: Writing Generate static files1$ hexo generate #生成静态页面至public目录 More info: Generating Run server1$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） More info: Server Deploy to remote sites1$ hexo deploy #将.deploy目录部署到GitHub More info: Deployment by my self1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo的简写形式1234hexo n "我的博客" == hexo new "我的博客"hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
  </entry>
</search>