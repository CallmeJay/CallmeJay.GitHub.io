<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript之原型和原型链]]></title>
    <url>%2F2018%2F02%2F08%2FJavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[构造函数创建对象我们先使用构造函数创建一个对象：123456function Person() &#123;&#125;var person = new Person();person.name = 'lili';console.log(person.name); // lili 在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。 prototype每一个函数都有一个prototype属性，就是我们经常在各种例子中看到那个prototype,比如：1234567891011function Person() &#123;&#125;/***虽然写在注释了，但是要注意：prototype是函数才会有的属性*/Person.prototype.name = 'Jay';var person1 = new Person();var person2 = new Person();console.log(person1.name); // jayconsole.log(person2.name); // jay 那这个函数的prototype属性到底指向的是什么呢？ 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的person1和person2的原型。 那什么是原型呢？可以这样理解：每一个JavaScript对象（null除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型‘继承’属性。 让我们用一张图表示构造函数和实例原型之间的关系：在这张图中我们用的Object.prototype表示实例原型。 那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢？ __proto__这是每一个JavaScript对象（null除外）都具有的一个属性，叫__proto__，这个属性会指向该对象的原型，证明如下：12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 更新关系图：既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就是第三个属性: constructor，每个原型都有一个constructor属性指向关联的构造函数。1234function Person() &#123;&#125;console.log(Person === Object.prototype.constructor); 再更新关系图：综上所述:123456789function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // trueconsole.log(Person.prototype.constructor = Person); // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype); // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系。 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。举个例子：123456789101112function Person()&#123;&#125;Person.prototype.name = 'jay';var person = new Person();person.name = 'John';console.log(person.name); // Johndelete person.name;console.log(person.name); // jay 在这个例子中，我们给实例对象person添加了name属性，当我们打印person.name的时候，结果自然为John。 但是当我们删除了person的name属性时，读取person.name,从person对象中找不到name属性就会从person的原型也就是person.__proto__,也就是Person.prototype中查找，幸运的是我们找打name属性，结果为jay。 但是万一没找到呢，原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，那我们就可以用最原始的方式创建它：123var obj = new Object();obj.name = 'Kevin';console.log(obj.name); // Kevin 其实原型对象就是通过Object构造函数生成的，结合之前所讲，实例的__proto__指向构造函数的prototype,所以载更新关系图： 原型链那Object.prototype的原型呢？null, 我们可以打印：1console.log(Object.prototype.__proto__ === null); // true 然而null究竟代表了什么呢？ null代表’没有对象’，即该处不该有值。 所以 Object.prototype.__proto__的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充constructor首先是constructor属性，例子：12345function Person () &#123;&#125;var person = new Person();console.log(person.constructor == Person); // true 当获取person.constructor时，其实person中并没有constructor属性，当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有这个属性，所以：1person.constructor = Person.prototype.constructor __proto__其次是__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型’继承’属性”，实际上，继承是一个十分具有迷惑性的说法， 引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建了一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和方法，所以与其叫继承，委托的说法反而更准确些。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域整理]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是跨域？ 跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。 下面是具体的跨域情况详解：123456789101112131415161718192021222324URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 这里我们需要注意两点: 如果是协议和端口造成的跨域问题“前台”是无能为力的； 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。) 通过document.domain跨域 前面说过了，浏览器有一个同源策略，其限制之一是不能通过ajax的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是www.damonare.cn/a.html ， 在这个页面里面有一个iframe，它的src是damonare.cn/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的： 123456789&lt;script type="text/javascript"&gt; function test()&#123; var iframe = document.getElementById('ifame'); var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt; 这个时候，document.domain就可以派上用场了，我们只要把www.damonare.cn/a.html和damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 在页面www.damonare.cn/a.html中设置document.domain:1234567&lt;iframe id = "iframe" src="http://damonare.cn/b.html" onload = "test()"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//设置成主域 function test()&#123; alert(document.getElementById('iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 在页面damonare.cn/b.html中也设置document.domain:123&lt;script type="text/javascript"&gt; document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 修改document.domain的方法只适用于不同子域的框架间的交互。 通过location.hash跨域 因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。 假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。1, a.html传送数据到b.html a.html下修改iframe的src为google.com/b.html#paco b.html监听到url发生变化，触发相应操作 2, b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”www.baidu.com/proxy.html#…” proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash） a.html监听到url发生变化，触发相应操作 b.html页面的关键代码如下:123456789try &#123; parent.location.hash = 'data'; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， var ifrproxy = document.createElement('iframe'); ifrproxy.style.display = 'none'; ifrproxy.src = "http://www.baidu.com/proxy.html#data"; document.body.appendChild(ifrproxy); &#125; proxy.html页面的关键代码如下 :12//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值 parent.parent.location.hash = self.location.hash.substring(1); 通过HTML5的postMessage方法跨域 高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。 比如damonare.cn域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信。 A页面通过postMessage方法发送消息：12345window.onload = function () &#123; var ifr = document.getElementById('ifr'); var targetOrigin = 'http://www.google.com'; ifr.contentWindow.postMessage('hello',targetOrigin);&#125; postMessage的使用方法： otherWindow.postMessage(message, targetOrigin); otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames属性的成员或者由window.open方法创建的窗口 message:是要发送的消息，类型为String、Object(IE8、9 不支持)targetOrigin:是限定消息接收范围，不限制请使用 ‘*’ B页面通过message事件监听并接受消息:12345678910111213var onmessage = function (ev)&#123; var data = ev.data; // 消息 var origin = ev.origin; // 消息来源地址 var source = ev.source; // 源window对象 if(origin == 'http://www.baidu.com') &#123; console.log(data); // hello &#125;&#125;if(window.addEventListener != 'undefined') &#123; window.addEventListener('message',onmessage,false);&#125;else if(window.attachEvent != 'undefined') &#123; // ie window.attachEvent('message',onmessage);&#125; 同理，也可以B页面发送消息，然后A页面监听并接受消息。 通过jsonp跨域 刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。 比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是damonare.cn/data.php, 那么a.html中的代码就可以这样：123456&lt;script type="text/javascript"&gt; function dosomething(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src="http://example.com/data.php?callback=dosomething"&gt;&lt;/script&gt; 我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。 因为是当做一个js文件来引入的，所以damonare.cn/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的(一定要和后端约定好哦):12345&lt;?php$callback = $_GET['callback'];//得到回调函数名$data = array('a','b','c');//要返回的数据echo $callback.'('.json_encode($data).')';//输出?&gt; 最终，输出结果为：dosomething([‘a’,’b’,’c’]); 如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。12345&lt;script type="text/javascript"&gt; $.getJSON('http://example.com/data.php?callback=?,function(jsondata)')&#123; //处理获得的json数据 &#125;);&lt;/script&gt; jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 JSONP的优缺点： JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 通过CORS跨域 CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 平时的ajax请求可能是这样的：12345&lt;script type='text/javascript'&gt; var xhr = XMLHttpRequest(); xhr.open('GET','/getSomething',true); xhr.send();&lt;/script&gt; 以上getSomething部分是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：12345&lt;script type='text/javascript'&gt; var xhr = XMLHttpRequest(); xhr.open('GET','http://jaybein.site/getSomething',true); xhr.send();&lt;/script&gt; 代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。关于CORS更多了解可以看下阮一峰老师的这一篇文章：跨域资源共享CORS详解]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对缓存的一点理解]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%AF%B9%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。 缓存的种类很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。 缓存好处有很多： 缓解服务器压力(不用每次去请求资源)； 提升性能(打开本地资源速度当然比请求回来再打开要快得多)； 减少带宽消耗(我相信你可以理解)； 浏览器的缓存策略缓存的目标: 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应； 不变的重定向: 响应状态码：301； 可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox； 错误响应: 响应状态码：404 的一个页面； 不完全的响应: 响应状态码 206，只返回局部的信息； 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应； 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。例如：1234567Age:23146Cache-Control:max-age=2592000Date:Tue, 28 Nov 2017 12:26:41 GMTETag:W/&quot;5a1cf09a-63c6&quot;Expires:Thu, 28 Dec 2017 05:27:45 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 强缓存阶段以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，Expires是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。Cache-Control:max-age=2592000是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，max-age &gt; Expires。 这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️ Firefox浏览器表现为一个灰色的200状态码。 Chrome浏览器状态码表现为:1200 (from disk cache)或是200 OK (from memory cache) 多说一点：关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 协商缓存阶段那么当这个CSS文件过期了怎么办?ETag和Last-Modified就该闪亮登场了。 先说Last-Modified，这个字段是文件最后一次修改的时间； ETag呢？ETag是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑 具体两个字段携带的内容如下(分别和上面的Last-Modified、ETag携带的值对应)：12If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMTIf-None-Match: W/&quot;5a1cf09a-63c6&quot; 到这协商缓存结束。 启发式缓存阶段我们把上面的响应头改下：12345Age:23146Cache-Control: publicDate:Tue, 28 Nov 2017 12:26:41 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带If-Moified-Since呗，不是的，浏览器还有个启发式缓存阶段。 根据响应头中2个时间字段Date和Last-Modified之间的时间差值，取其值的10%作为缓存时间周期。 这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种默认缓存的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。下面用一张图，来解释浏览器整个缓存策略的过程：对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。 传送门]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript:彻底理解同步、异步和事件循环（Event Loop）]]></title>
    <url>%2F2018%2F02%2F06%2FJavaScript-%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。 同步与异步在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？ 同步如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。 如下所示：1234//在函数返回时，获得了预期值，即2的平方根Math.sqrt(2);//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'console.log('hello'); 上面两个函数就是同步的。如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。 异步如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。 如下所示：123456789//读取文件fs.readFile('hello.txt', 'utf8', function(err, data) &#123; console.log(data);&#125;);//网络请求var xhr = new XMLHttpRequest();xhr.onreadystatechange = xxx; // 添加回调函数xhr.open('GET', url);xhr.send(); // 发起函数 上述示例中读取文件函数 readFile和网络请求的发起函数 send都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在JavaScript中通过回调函数function(err, data) { console.log(data); }和 onreadystatechange，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行JavaScript代码的线程执行回调。 如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。 单线程与多线程在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？ JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。 浏览器目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。一个浏览器通常由以下几个常驻的线程： 渲染引擎线程：顾名思义，该线程负责页面的渲染 JS引擎线程：负责JS的解析和执行 定时触发器线程：处理定时事件，比如setTimeout, setInterval 事件触发线程：处理DOM事件 异步http请求线程：处理http请求 需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。 JS引擎通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。 JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤： 词法分析：将源代码分解为有意义的分词 语法分析：用语法分析器将分词解析成语法树 代码生成：生成机器能运行的代码 代码执行 不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。 之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。 所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。 消息队列与事件循环通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？ 这一切的解释就需要继续了解消息队列和事件循环。 如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。 右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。 JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。 JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。 上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。 从上文中我们也可以得到这样一个明显的结论，就是： 异步过程的回调函数，一定不在当前这一轮事件循环中执行。 示例引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。 执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？ 12345678910111213141516171819202122232425setTimeout(function()&#123; for(var i = 0; i &lt; 100000000; i++)&#123;&#125; console.log('timer a');&#125;, 0)for(var j = 0; j &lt; 5; j++)&#123; console.log(j);&#125;setTimeout(function()&#123; console.log('timer b');&#125;, 0)function waitFiveSeconds()&#123; var now = (new Date()).getTime(); while(((new Date()).getTime() - now) &lt; 5000)&#123;&#125; console.log('finished waiting');&#125;document.addEventListener('click', function()&#123; console.log('click');&#125;)console.log('click begin');waitFiveSeconds(); 要想了解上述代码的输出结果，首先介绍下定时器。 setTimeout的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，所以间隔的时间一般会大于等于指定的时间。 setTimeout(fn, 0)的意思是，将回调函数fn立刻插入消息队列，等待执行，而不是立即执行。看一个例子： 123456setTimeout(function() &#123; console.log("a")&#125;, 0)for(let i=0; i&lt;10000; i++) &#123;&#125;console.log("b") 1b a 打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。 理解了定时器的作用，那么对于输出结果就容易得出了。 首先，先执行同步任务。其中waitFiveSeconds是耗时操作，持续执行长达5s。123456701234click beginfinished waiting 然后，在JS引擎线程执行的时候，&#39;timer a&#39;对应的定时器产生的回调、 &#39;timer b&#39;对应的定时器产生的回调和两次click对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务。因此会产生 下面的输出顺序。1234clickclicktimer atimer b 最后，5s 后的两次click事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。12clickclick 异步与事件上文中说的“事件循环”，为什么里面有个事件呢？那是因为： 消息队列中的每条消息实际上都对应着一个事件。 上文中一直没有提到一类很重要的异步过程：DOM事件。举例说明：1234var button = document.getElement('#btn');button.addEventListener('click',function(e)&#123; console.log('lalla');&#125;) 从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。 从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。 总结一下最后再用一个生活中的例子总结一下同步和异步：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。 这就是同步和异步的区别。同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性。改变顺序性其实也没有什么大不了的，只不过让程序变得稍微难理解了一些. 参考文章：JavaScript 运行机制详解：再谈Event Loop 传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之字符串的扩展]]></title>
    <url>%2F2017%2F09%2F01%2FES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[字符串的遍历器接口ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// "f"// "o"// "o" includes(),startsWith(),endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" 参数如果是小数，会被取整。1'na'.repeat(2.9) // "nana" 如果repeat的参数是负数或者Infinity，会报错。1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。1'na'.repeat(-0.9) // "" 参数NaN等同于0。如果repeat的参数是字符串，则会先转换成数字。12'na'.repeat('na') // ""'na'.repeat('3') // "nanana" padStart()，padEnd()ES2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 模板字符串传统的JavaScript语言，输出模板通常是这样写的。123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串(template string)是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 模板字符串中嵌入变量，需要将变量名写在${}之中。123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// "3" 模板字符串之中还能调用函数。123456function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。123// 变量place没有声明let msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。12`Hello $&#123;'World'&#125;`// "Hello World" 模板字符串甚至还能嵌套。12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // "Hello Jack!"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // "Hello Jack!"]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之变量的结构赋值]]></title>
    <url>%2F2017%2F08%2F28%2FES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。以前，为变量赋值，只能直接指定值。123let a = 1;let b = 2;let c = 3; ES6允许写成下面这样。1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。1let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 与数组一样，解构也可以用于嵌套结构的对象。12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 对象的解构也可以指定默认值。123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。1let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 用途变量的解构赋值用途很多。 交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据解构赋值对提取JSON对象中的数据，尤其有用。12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历Map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6入门之let和const]]></title>
    <url>%2F2017%2F08%2F25%2FES6%E5%85%A5%E9%97%A8%E4%B9%8Blet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为JavaScript新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。ES6 允许块级作用域的任意嵌套。1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。const的作用域与let命令相同：只在声明所在的块级作用域内有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const声明的常量，也与let一样不可重复声明。 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中常见的几种轮播]]></title>
    <url>%2F2017%2F08%2F15%2FJavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[项目中经常用到轮播图，今天就来一起探讨不同模式轮播图的实现方法，与君共勉。首先奉上轮播图 无缝不停轮播body布局:123456789&lt;div class="container"&gt; &lt;!--将ul和li包住,起显示图片的作用--&gt; &lt;ul&gt; &lt;li&gt;![](img/img1.png)&lt;/li&gt; &lt;li&gt;![](img/img2.png)&lt;/li&gt; &lt;li&gt;![](img/img3.png)&lt;/li&gt; &lt;li&gt;![](img/img4.png)&lt;/li&gt; &lt;li&gt;![](img/img1.png)&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css样式：1234567891011121314151617181920212223242526*&#123; margin: 0; padding: 0;&#125;.container&#123; position: relative; /*给要动的元素也就是ul 它的父级加上相对定位*/ width: 600px; height: 400px; overflow: hidden; /*给要动的元素也就是ul 它的父级加上溢出隐藏*/&#125;.container &gt; ul&#123; position: absolute; /*给要动的元素也就是ul 加上绝对定位,才能保证用left和top;*/ width: 3000px; /*ul 的宽度为 li 的个数 * li 的宽度*/ height:100%; list-style: none;&#125;.container &gt; ul &gt;li&#123; float: left; width: 600px; height: 100%;&#125;.container &gt; ul &gt;li img&#123; width: 100%; height: 100%;&#125; JS代码:1234567891011var ul = document.querySelector(".container &gt; ul"); //获取ulsetTimeout(function step()&#123; //设置定时器 if(ul.offsetLeft&lt;=-2400)&#123; //判断:若ul走到倒数第二张图的时候,让left从0开始运行 ul.style.left=0+'px'; &#125;else&#123; var left = ul.offsetLeft -3; //给ul设置速度 ul.style.left=left+'px'; &#125; var time = 10; //设定一个时间,以控制其轮播的速度 setTimeout(step,time); //定时器内部调用定时器&#125;,0) 无缝停顿轮播 停顿轮播在不停轮播的基础上加以改进,判断当ul走到li宽度的倍数时,让定时器的时间加大,就可以起到停顿的效果 ​body布局以及css样式不变 js代码：12345678910111213141516var ul = document.querySelector(".container &gt; ul"); //获取ulsetTimeout(function step()&#123; //设置定时器 if(ul.offsetLeft&lt;=-2400)&#123; //判断:若ul走到倒数第二张图的时候,让left从0开始运行 ul.style.left = 0 +'px'; &#125;else&#123; speed = -3; //给ul设置速度 &#125; var time; if(ul.offsetLeft%600==0)&#123; //做判断:当ul走到li宽度的倍数时 time = 3000; //设定一个很大的时间,也就是很小的速度 &#125;else&#123; time = 10; &#125; ul.style.left=ul.offsetLeft+speed+'px'; setTimeout(step,time); //定时器内部调用定时器&#125;,0) 无缝停顿反向轮播 反向轮播在停顿轮播的基础上加以改进,判断当ul最左边和ul走到最右边,将速度反向;将最后一张重复的li去掉并修改ul的宽度 123456789101112131415var ul = document.querySelector(".container &gt; ul");var speed = 3;setTimeout(function step()&#123; if(ul.offsetLeft&lt;=-1800||ul.offsetLeft&gt;=0)&#123; //判断当ul最左边和ul走到最右边,将速度反向; speed*=-1; &#125; var time = 0; if(ul.offsetLeft%600==0)&#123; //做判断:当ul走到li宽度的倍数时 time = 3000; //设定一个很大的时间,也就是很小的速度 &#125;else&#123; time=10; &#125; ul.style.left=ul.offsetLeft+speed+'px'; setTimeout(step,time); //定时器内部调用定时器&#125;,0) 透明度普通轮播​1.body布局上一样;​2.css样式:将所有li 绝对定位,重叠在一起​3.JS:先获取到ul 和 li 并对 li的数组进行遍历 赋值每个的opacity​注:要在js中遍历li 再给它赋值opacity,而不是在css中直接设置属性是为了在js中好获取到opacity并给它进行修改设置123456789101112131415161718192021222324var ul = document.querySelector(".container &gt; ul"); //获取ulvar lis = document.querySelectorAll('.container &gt; ul &gt;li');var i = 0;for(var i=0;i&lt;lis.length;i++)&#123; if(i==0)&#123; //默认显示第一张图,让其透明度为1; lis[i].style.opacity=1; &#125;else&#123; //其他图片透明度为0; lis[i].style.opacity=0; &#125;&#125;var i=0; //重新赋值i var time = 50; //设置时间,控制图片转换的速度,时间越大,速度越慢setTimeout(function step()&#123; //设置定时器 lis[i%4].style.opacity-=0.05; lis[(i+1)%4].style.opacity=parseFloat(lis[(i+1)%4].style.opacity)+0.05; if(lis[i%4].style.opacity==0)&#123; i++; time = 1000; &#125;else&#123; time =50 &#125; setTimeout(step,time);&#125;,0) 透明度指示器轮播body布局:123456789101112131415161718192021222324&lt;div class="container"&gt; &lt;ul id="picture"&gt; &lt;!--轮播图片区--&gt; &lt;li&gt;![](img/img1.jpg)&lt;/li&gt; &lt;li&gt;![](img/img2.jpg)&lt;/li&gt; &lt;li&gt;![](img/img3.jpg)&lt;/li&gt; &lt;li&gt;![](img/img4.jpg)&lt;/li&gt; &lt;li&gt;![](img/img5.jpg)&lt;/li&gt; &lt;li&gt;![](img/img6.jpg)&lt;/li&gt; &lt;/ul&gt; &lt;ul class="arrow"&gt; &lt;!--左右切换--&gt; &lt;li class="arrowLeft"&gt;&lt;/li&gt; &lt;li class="arrowRight"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="bottom"&gt; &lt;!--指示器--&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li style="margin:0"&gt;6&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; css样式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586* &#123; margin: 0; padding: 0;&#125;.container &#123; /*整体样式*/ position: relative; width: 600px; height: 400px; overflow: hidden; margin: 20px auto;&#125;.container &gt; .picture &#123; /*轮播图片区样式*/ position: absolute; width: 600px; height: 100%; list-style: none;&#125;.container &gt; .picture &gt; li &#123; position: absolute; width: 600px; height: 100%;&#125;.container &gt; .picture &gt; li img &#123; width: 100%; height: 100%;&#125;.container &gt; .arrow&#123; /*左右切换区样式*/ position: absolute; height: 70px; width: 100%; top: 40%; left: 0; list-style: none;&#125;.container &gt; .arrow &gt; li &#123; width: 40px; height: 70px; padding: 0; margin: 0; cursor: pointer;&#125;.container &gt; .arrow &gt; li:nth-child(1) &#123; float: left; background: url("img/arrow_left1.png");&#125;.container &gt; .arrow &gt; li:nth-child(2) &#123; float: right; background: url("img/arrow_right1.png");&#125;.container &gt; .arrow &gt; li:nth-child(1):hover &#123; background: url("img/arrow_left2.png");&#125;.container &gt; .arrow &gt; li:nth-child(2):hover &#123; background: url("img/arrow_right2.png");&#125;.container .bottom &#123; /*指示器样式*/ position: relative; margin: 0 auto; width: 215px; height: 40px; top: 350px; border-radius: 20px; background-color: grey;&#125;.container &gt; .bottom &gt; ul&#123; position: absolute; height: 30px; width: 205px; bottom: 20px; list-style: none; top: 5px; left: 5px;&#125;.container &gt; .bottom &gt; ul &gt; li&#123; float: left; height: 100%; width: 30px; margin: 0 5px 0 0; padding: 0; border-radius: 50%; background-color: white; font-size: 20px; line-height: 30px; text-align: center; cursor: pointer;&#125; js代码：​代码分析: 先进行准备工作, 利用for循环将初始化的图片透明度已经指示器的背景色设定好 给整个container添加事件,当鼠标上来的时候,让自动播放停止 给左,右”按钮” 点击事件,用以切换上一张下一张图片; 给指示器onmouseenter事件,使得图片与你的指示器同步,达到随意切换图片的效果; 定义 图片切换的函数 ,使得以上事件都可以调用它 定义自动播放的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var container = document.querySelector('.container');var pictureLis = document.querySelectorAll('.container &gt; .picture &gt; li');var optionLis = document.querySelectorAll('.container &gt; .bottom &gt;ul &gt; li');var arrowLeft = document.querySelector('.container .arrow &gt; .arrowLeft');var arrowRight = document.querySelector('.container .arrow &gt; .arrowRight');var showIndex = 0; //当前正在显示的图片的下标//初始化function init() &#123; for (var j = 0; j &lt; pictureLis.length; j++) &#123; if (j == 0) &#123; optionLis[j].style.backgroundColor='red'; pictureLis[j].style.opacity = 1; &#125; else &#123; pictureLis[j].style.opacity = 0; &#125; &#125; //给整个container添加事件,当鼠标上来的时候,让自动播放停止 container.onmouseenter = function () &#123; clearTimeout(autoPlayId); &#125;; container.onmouseleave = function () &#123; auto(); &#125;; //给左按钮和右按钮添加点击事件 arrowLeft.onclick=function()&#123; optionLis[showIndex % optionLis.length].style.backgroundColor='white'; var preIndex = showIndex-1+pictureLis.length; move(showIndex,preIndex); showIndex=preIndex; optionLis[showIndex%optionLis.length].style.backgroundColor='red'; &#125;; arrowRight.onclick=function()&#123; optionLis[showIndex % optionLis.length].style.backgroundColor='white'; move(showIndex,showIndex+1); showIndex++; optionLis[showIndex%optionLis.length].style.backgroundColor='red'; &#125;; //给指示器添加onmouseenter事件,使得图片与指示器同步 for(let i=0;i&lt;optionLis.length;i++)&#123; optionLis[i].onmouseenter=function()&#123; move(showIndex,i); optionLis[showIndex%optionLis.length].style.backgroundColor='white'; optionLis[i%optionLis.length].style.backgroundColor='red'; showIndex=i; &#125; &#125;&#125;init(); //调用初始化//图片移动function move(showIndex,nextIndex) &#123; setTimeout(function step() &#123; pictureLis[showIndex % pictureLis.length].style.opacity -= 0.05; pictureLis[nextIndex % pictureLis.length].style.opacity = +pictureLis[nextIndex % pictureLis.length].style.opacity + 0.05; if (pictureLis[showIndex % pictureLis.length].style.opacity &lt;= 0||pictureLis[nextIndex%pictureLis.length].style.opacity&gt;=1) return; setTimeout(step, 5) &#125;, 0)&#125;//自动播放var autoPlayId; //自动播放定时器idfunction auto() &#123; autoPlayId = setTimeout(function autoStep() &#123; optionLis[showIndex].style.backgroundColor = "white"; move(showIndex,showIndex+1); //切换下一张图片 showIndex++; if (showIndex == pictureLis.length) showIndex = 0; optionLis[showIndex%optionLis.length].style.backgroundColor = "red"; autoPlayId = setTimeout(autoStep,2000); &#125;, 2000)&#125;auto();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现圣杯布局和双飞翼布局]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%AE%9E%E7%8E%B0%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[背景利用浮动特性可以实现一些布局，比较经典的有个圣杯布局，后来经过改进又出现了双飞翼布局，下面就来介绍一下这两种布局。先看一下效果图：三栏式圣杯布局demo三栏式双飞翼布局demo两种布局基本原理是相似的，而且双飞翼布局是圣杯布局的基础上改进而来，所以先介绍圣杯布局。 圣杯布局1.总体上看上、中、下三个部分，一般写三组&lt;div&gt;&lt;/div&gt;标签，当然也可以采用html5的标签。2.所谓布局都是在中间部分做文章，有几个要求：第一最中间部分宽度是不定的；第二：俩侧边栏宽度是定的3.为达目的，我们肯定要采用浮动，但是有个诀窍：此处html结构中中间部分要先写，所以html结构是下面这样的1234567&lt;div id="header"&gt;header&lt;/div&gt; &lt;div id="main"&gt; &lt;div class="content"&gt;三栏式圣杯布局&lt;/div&gt; &lt;div class="aside"&gt;定宽左侧边栏&lt;/div&gt; &lt;div class="extra"&gt;定宽右侧栏&lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer&lt;/div&gt; 4.此时的问题是用css控制各块到各自位置上。简单的办法是使用负margin，这个负margin的原理是盒子模型的算法，想一下：1内容+padding+border+margin 这个公式里如果有一个负值，总和会怎么变，占据宽度空间会怎么变。当我们给一个div加上左负margin自然这个区块就向左位移了。思考一下就知道如果我们给俩边栏设置的都是float:left属性，则需要左侧边栏向左位移一整个父容器的宽度，右侧边栏则向左位移一个自身宽度。1234567891011121314.aside &#123; float:left; margin-left:-100%; width: 200px; min-height: 40px; background-color: red;&#125;.extra &#123; float:right; margin-left:-100%; width:200px; min-height: 40px; background-color: yellow;&#125; 仔细看一下代码，会发现右边栏的处理和之前说的不一样，原因就不解释 了，其实只要合理设置css可以有不同方法达到目的。5.现在就剩下最后一步，俩侧边栏虽已经和中间主题内容处于同一行，但是肯定不能遮挡要平移到对应位置上。直接给父元素加个padding，俩侧边栏使用一个相对定位移到padding区域就搞定了。1234567891011#main &#123; padding: 0 200px; &#125;.aside &#123; position: relative; left: -200px;&#125;.extra &#123; position: relative; right: -200px;&#125; 至此，圣杯布局就完成了。 双飞翼布局双飞翼布局和圣杯布局的区别只是换一种思路解决中间元素被遮挡问题，主要想法就是在外侧加一个div占据位置，俩侧边栏占据margin位置。所以直接看代码。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .mid &#123; float: left; width: 100%; &#125; .mid .mid-content &#123; min-height: 80px; min-width: 20px; background-color: green; margin-left:200px; margin-right:200px; &#125; .aside &#123; float: left; width: 200px; min-height: 60px; background-color: yellow; margin-left: -100%; &#125; .extra &#123; float: left; width: 200px; min-height: 60px; background-color: blue; margin-left:-200px; &#125; &lt;/style&gt; &lt;head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div class="mid"&gt; &lt;div class="mid-content"&gt;三栏式双飞翼布局中间自适应&lt;/div&gt; &lt;/div&gt; &lt;div class="aside"&gt;侧边栏定宽&lt;/div&gt; &lt;div class="extra"&gt;右侧定宽&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 以上就是圣杯布局和双飞翼布局。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue配置移动端rem布局]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%9F%BA%E4%BA%8Evue%E9%85%8D%E7%BD%AE%E7%A7%BB%E5%8A%A8%E7%AB%AFrem%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[今天来聊一聊基于vue-cli配置的移动端屏幕适配问题。 配方还是一样：手淘的lib-flexible + rem 配置 flexible安装 lib-flexible在命令行中运行如下安装：1npm i lib-flexible --save 引入 lib-flexible在项目入口文件 main.js 里 引入 lib-flexible12// main.jsimport 'lib-flexible' 添加 meta 标签在项目根目录的 index.html 中添加如下 meta1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; px 转 rem实际开发中，我们通过设计稿得到的值单位是 px，所以要将 px 转换成 rem 再写进样式中。将 px 转换成 rem 我们将使用 px2rem 这个工具，它有 webpack 的 loader：px2rem-loader 安装 px2rem-loader在命令行中运行如下安装：1npm i px2rem-loade --save-dev 配置 px2rem-loade在 vue-cli 生成的 webpack 配置中，vue-loader 的 options 和其他样式文件 loader 最终是都是由 build/utils.js 里的一个方法生成的。 我们只需在 cssLoader 后再加上一个 px2remLoader 即可，px2rem-loader 的 remUnit 选项意思是 1rem=多少像素，结合 lib-flexible 的方案，我们将 px2remLoader 的 options.remUnit 设置成设计稿宽度的 1/10，这里我们假设设计稿宽为 750px。123456789101112131415// utils.jsvar cssLoader = &#123; loader: 'css-loader', options: &#123; minimize: process.env.NODE_ENV === 'production', sourceMap: options.sourceMap &#125;&#125;var px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUnit: 75 &#125;&#125;// ... 并放进 loaders 数组中1234// utils.jsfunction generateLoaders(loader, loaderOptions) &#123; var loaders = [cssLoader, px2remLoader] // ... 修改配置后需要重启，然后我们在组件中写单位直接写 px，设计稿量多少就可以写多少了，舒服多了。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的10个重点及难点]]></title>
    <url>%2F2017%2F07%2F15%2FJavaScript%E7%9A%8410%E4%B8%AA%E9%87%8D%E7%82%B9%E5%8F%8A%E9%9A%BE%E7%82%B9%2F</url>
    <content type="text"><![CDATA[立即执行函数立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：1234(function() &#123; // 代码 // ...&#125;)(); function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。 闭包对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。123456789101112131415function f1()&#123; var N = 0; // N是f1函数的局部变量 function f2()&#123; // f2是f1函数的内部函数，是闭包 N += 1; // 内部函数f2中使用了外部函数f1中的变量N console.log(N); &#125; return f2;&#125;var result = f1();result(); // 输出1result(); // 输出2result(); // 输出3 代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！ 使用闭包定义私有变量通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：123456789101112131415161718function Product() &#123; var name; this.setName = function(value) &#123; name = value; &#125;; this.getName = function() &#123; return name; &#125;;&#125;var p = new Product();p.setName("Fundebug");console.log(p.name); // 输出undefinedconsole.log(p.getName()); // 输出Fundebug 代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。 prototype每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。1234567891011121314151617function Rectangle(x, y)&#123; this._length = x; this._breadth = y;&#125;Rectangle.prototype.getDimensions = function()&#123; return &#123; length: this._length, breadth: this._breadth &#125;;&#125;;var x = new Rectangle(3, 4);var y = new Rectangle(4, 3);console.log(x.getDimensions()); // &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125; 代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。 模块化JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及Fundebug都是这样实现的。123456789101112131415161718192021var module = (function() &#123; var N = 5; function print(x) &#123; console.log("The result is: " + x); &#125; function add(a) &#123; var x = a + N; print(x); &#125; return &#123; description: "This is description", add: add &#125;;&#125;)();console.log(module.description); // 输出"this is description" module.add(5); // 输出“The result is: 10” 所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。 变量提升JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。 但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：123console.log(y); // 输出undefinedvar y = 2; // 初始化y 上面的代码等价于下面的代码：12345var y; // 声明yconsole.log(y); // 输出undefinedy = 2; // 初始化y 为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。 柯里化柯里化，即Currying，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。12345678910111213var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;console.log(add(1)(1)); // 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11 代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。 apply, call与bind方法JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。 三者之中，call方法是最简单的，它等价于指定this值调用函数：1234567891011121314var user = &#123; name: "Rahul Mhatre", whatIsYourName: function() &#123; console.log(this.name); &#125;&#125;;user.whatIsYourName(); // 输出"Rahul Mhatre",var user2 = &#123; name: "Neha Sampat"&#125;;user.whatIsYourName.call(user2); // 输出"Neha Sampat" apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定： apply(thisArg, [argsArray]) call(thisArg, arg1, arg2, …) 12345678910111213var user = &#123; greet: "Hello!", greetUser: function(userName) &#123; console.log(this.greet + " " + userName); &#125;&#125;;var greet1 = &#123; greet: "Hola"&#125;;user.greetUser.call(greet1, "Rahul"); // 输出"Hola Rahul"user.greetUser.apply(greet1, ["Rahul"]); // 输出"Hola Rahul" 使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：123456789101112var user = &#123; greet: "Hello!", greetUser: function(userName) &#123; console.log(this.greet + " " + userName); &#125;&#125;;var greetHola = user.greetUser.bind(&#123;greet: "Hola"&#125;);var greetBonjour = user.greetUser.bind(&#123;greet: "Bonjour"&#125;);greetHola("Rahul") // 输出"Hola Rahul"greetBonjour("Rahul") // 输出"Bonjour Rahul" MemoizationMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。1234567891011121314151617181920function memoizeFunction(func)&#123; var cache = &#123;&#125;; return function()&#123; var key = arguments[0]; if (cache[key])&#123; return cache[key]; &#125;else&#123; var val = func.apply(this, arguments); cache[key] = val; return val; &#125; &#125;;&#125;var fibonacci = memoizeFunction(function(n)&#123; return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;);console.log(fibonacci(100)); // 输出354224848179262000000console.log(fibonacci(100)); // 输出354224848179262000000 代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。 函数重载所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if...else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。 从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。 难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。 由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。 根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function addMethod(object, name, f)&#123; var old = object[name]; object[name] = function()&#123; // f.length为函数定义时的参数个数 // arguments.length为函数调用时的参数个数 if (f.length === arguments.length)&#123; return f.apply(this, arguments); &#125;else if (typeof old === "function")&#123; return old.apply(this, arguments); &#125; &#125;;&#125;// 不传参数时，返回所有namefunction find0()&#123; return this.names;&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++)&#123; if (this.names[i].indexOf(firstName) === 0)&#123; result.push(this.names[i]); &#125; &#125; return result;&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName)&#123; var result = []; for (var i = 0; i &lt; this.names.length; i++)&#123; if (this.names[i] === (firstName + " " + lastName))&#123; result.push(this.names[i]); &#125; &#125; return result;&#125;var people = &#123; names: ["Dean Edwards", "Alex Russell", "Dean Tom"]&#125;;addMethod(people, "find", find0);addMethod(people, "find", find1);addMethod(people, "find", find2);console.log(people.find()); // 输出["Dean Edwards", "Alex Russell", "Dean Tom"]console.log(people.find("Dean")); // 输出["Dean Edwards", "Dean Tom"]console.log(people.find("Dean", "Edwards")); // 输出["Dean Edwards"] 传送门~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典前端面试题(JavaScript)]]></title>
    <url>%2F2017%2F07%2F12%2F%E7%BB%8F%E5%85%B8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98-JavaScript%2F</url>
    <content type="text"><![CDATA[写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉123var reg = /(&lt;\w+&gt;)|(&lt;\/\w+&gt;)/gi;var str = '&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;';alert(str.replace(reg,"")); 编写一个函数,用于统计一个字符串中出现次数最多的字符和其出现的次数？123456789101112131415161718192021var str = 'asdfssaaasasasasaa';function findMaxAppearChar () &#123; var arr = str.split(''); var obj = &#123;&#125;; var maxKey = ''; var maxIndex = 0; for( var i = 0; i &lt; arr.length; i++ ) &#123; if( obj[ arr[i] ] )&#123; obj[ arr[i] ] += 1; &#125;else&#123; obj[ arr[i] ] = 1; &#125; &#125; for( key in obj ) &#123; if(obj[key] &gt; maxIndex) &#123; maxKey = key; maxIndex = obj[key]; &#125; &#125; return ('出现最多字符是' + maxKey + ',一共出现了' + maxIndex + "次");&#125; 闭包是什么? 有什么特性? 对页面有什么影响?(1)闭包是什么:闭包是指有权访问另一个函数作用域中变量的函数.(2)闭包有什么特性:通过闭包,可以提供私有作用域.函数执行完后,内部不会释放通过闭包,可以实现带有存储函数运行时变量的函数.(3)对页面有什么影响:大量使用闭包会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 写一个reverseStr函数来实现字符串反转，如将 ‘12345678’ 变成 ‘87654321’1234var str = '12345678';function reverseStr (str) &#123; return str.split('').reverse().join('');&#125; 将数字 12345678 转化成 RMB形式 如： 12,345,678123456789101112function formatNumberToRMB ( number ) &#123; var str = number + ''; var arr = str.split('').reverse(); //[8,7,6,5,4,3,2,1] var resultArr = []; for( var i = 0; i &lt; arr.length; i++ ) &#123; resultArr.push( arr[i] ); if( (i + 1) % 3 == 0 &amp;&amp; (i + 1) != arr.length )&#123; resultArr.push(','); &#125; &#125; return resultArr.reverse().join('');&#125; 请写一个阻止冒泡的兼容函数12345678function stopPropagation ( e ) &#123; e = window.event ? window.event : e; if( e.stopPropagation ) &#123; e.stopPropagation(); &#125;else&#123; e.cancelBubble = true; &#125;&#125; 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序123456789function getSortedRandomNumber () &#123; var arr = []; for( var i = 0; i &lt; 10; i++ ) &#123; arr.push( Math.floor( Math.random() * 90 ) + 10 ); &#125; return arr.sort(function ( a, b ) &#123; return a - b; &#125;)&#125;; 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{“a”:”1”,”b”:”2”,”c”:””,”d”:”xxx”,”e”:”undefined”}123456789101112131415function getQueryJson ( URLstr ) &#123; var queryIndex = URLstr.indexOf('?') + 1; var queryStr = URLstr.slice( queryIndex ); //a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e var arr = queryStr.split( '&amp;' ); //[ a=1, b=2, c=, d=xxx, e ] var obj = &#123;&#125;; var resultArr = []; for( var i = 0; i &lt; arr.length; i++ ) &#123; var tempArr = arr[ i ].split( '=' ); obj[ tempArr[0] ] = tempArr[1]; &#125; for( var key in obj )&#123; resultArr.push( '"' + key + '"' + ':' + '"' + obj[ key ] + '"' ); &#125; return '&#123;' + resultArr.join(',') + '&#125;'; //&#123;"a":"1","b":"2","c":"","d":"xxx","e":"undefined"&#125;&#125;; 写一个function，清除字符串前后的空格。（兼容所有浏览器）12345if( typeof String.prototype.trim !== 'function' ) &#123; String.prototype.trim = function( ) &#123; return this.replace ( /^\s*|\s*$/g, '' ); &#125;&#125; 获取页面所有的checkbox12345678var resultArr= [];var input = document.querySelectorAll('input');for( var i = 0; i &lt; input.length; i++ ) &#123; if( input[i].type == 'checkbox' ) &#123; resultArr.push( input[i] ); &#125;&#125;//resultArr即中获取到了页面中的所有checkbox 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”123456789101112function getCamelCase ( str ) &#123; var arr = str.split("-"); var resultArr = []; for( var i = 0; i &lt; arr.length; i++ )&#123; if( i === 0 ) &#123; resultArr.push( arr[i] ); &#125;else&#123; resultArr.push( arr[i].charAt( 0 ).toUpperCase() + arr[i].slice( 1 ) ); &#125; &#125; return resultArr.join('');&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你走进Gulp]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9BGulp%2F</url>
    <content type="text"><![CDATA[Gulp是一款前端自动化构建工具。通俗的来说，就是你本来需要很多条指令才可以完成的事情，通过Gulp你可能只需要一条指令。 Gulp是什么鬼首先，我很确定它不是鬼。对于之前接触过Webpack的人来说，很大的一个疑惑可能就是：这两者有什么区别？因为Webpack几乎能做全部我们需要做的事情，Gulp存在的意义是什么？我只能说：存在即合理。Gulp貌似是一款取代Grunt的工具，我没有去了解过Grunt，可能是因为没时间，而且好像也不是很有必要。Gulp的核心功能是自动化任务流程，简化操作。比如你需要做打包、编译、压缩、合并等一些乱七八糟的事情，不用Gulp，你可能需要一步一步的“自己”来，而有了Gulp，你预先将这些乱七八糟的事情定义好交给Gulp，然后在特定时刻，Gulp自动将这些事情全都做了。而Webpack的核心功能应该是集中在模块管理上，不过它同样可以通过各种插件，做很多事情。过于纠结这两者的区别也没什么必要。Gulp简单，学起来也就一两天的事。Webpack相对要复杂很多，而且对于新手也有很多坑，但不可忽略它确实很强大。这里的建议是，都学一下，毕竟这是现在最火的两款开发工具。 很重要的几个概念Gulp不算复杂，去官网也就那么一丁点儿的介绍，所以学习之前有必要先知道一些概念。 配置文件（gulpfile.js）Gulp既然是一款工具，就得做一些事情，具体要做些什么，还得由我们来指定。在哪里指定，就是在它的配置文件gulpfile.js中，该文件位于项目的根目录下。以后所有Gulp相关的配置语句都是写在gulpfile.js文件中。 任务（Task）Gulp把需要做的一些事情定义成一个个的任务，每一个任务都有一个名字，然后通过命令调用这个任务的名字，就可以执行该任务对应的代码。如下：12345678910111213// gulpfile.js 文件中var gulp = require('gulp');// style 任务gulp.task('style', function () &#123; // 一些要做的事情&#125;);// build 任务gulp.task('build', function () &#123; // 要做的事情 &#125;); 插件前面定义的都是一些空任务，啥也不会做。因为Gulp本身不会做任何“事情”，它只负责把那些要做的事情准备（分类、串联）好。具体谁来做，那就是插件。 Gulp有很多插件，几乎能满足你的各种需求。我想对于初学者来说有个疑问：我怎么知道我需要的插件叫什么？那么，我在这里先列出一些插件。我也不知道这些是不是常用的插件，不过看起来好像比较常用。*gulp-connect：可以跑一个本地服务器，貌似现在应该不会有人直接将index.html拖到浏览器来调试吧； gulp-concat：看清了，这是concat，用来合并文件的； gulp-clean：删除文件用的； gulp-rename：重命名文件； gulp-minify-html：压缩html用的； gulp-inject：可以将css样式和js脚本文件插入到html文件中； gulp-minify-css：压缩css； gulp-uglify：压缩js； gulp-imagemin：压缩图片； gulp-postcss：自动添加css中的前缀，很实用的家伙。 就这些吧，看清楚长啥样就好了。正如你看到的那样，Gulp所有的插件都是以gulp-开头。对于那些有点经验的人来说，要什么插件可能一般都是直接去npm或github上搜索。对于不知道怎么搜的（一般都是不知道关键词），就老老实实百度吧。一个很好的习惯就是平时多记录和总结，因为很多插件在不同的工具和平台中，叫法基本上都是一样的。另外，这里还给一个官方收录的插件列表。 具体使用方法Gulp的安装就不说了，需要的直接看看这里。先举一个栗子（玩玩）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 引入gulp，无需解释var gulp = require('gulp');// 引入插件var connect = require('gulp-connect')， sass = require('gulp-sass')， uglify = require('gulp-uglify');// 定义任务gulp.task('server', function () &#123; // 使用 connect 插件创建一个服务器 connect.server(&#123; // 这里是传入的一些配置项 root: 'dist', livereload: true &#125;)&#125;);gulp.task('style', function () &#123; // 匹配资源文件 gulp.src('./src/**/*.scss') // 对匹配到的 文件 传到一个插件中 .pipe(sass(&#123; // 用sass插件处理 匹配到的文件 // 插件的配置项 outputStyle: 'compressed' // 插件的功能 打印错误信息 &#125;).on('error', sass.logError)) // 串联 将sass处理后的文件 传送到下一个插件中 // 将文件 输出到指定目录下 .pipe(gulp.dest('dist')) // 重新加载 服务器 .pipe(connect.reload());&#125;);gulp.task('script', function () &#123; gulp.src('./src/**/*.js') .pipe(uglify()) .pipe(gulp.dest('dist')) .pipe(connect.reload());&#125;);// 默认任务 要等到数组中的任务执行完之后 才执行gulp.task('default', ['style', 'script', 'server'], function () &#123; // 监听 匹配到的文件是否改变 // 一旦变化就执行 数组 中的任务 gulp.watch('./src/js/*.js', ['script']); gulp.watch('./src/css/*.scss', ['style']);&#125;); Gulp的基本使用大概就这些，gulpfile.js文件大概就是这个样子的。对于该配置文件，命令行只需执行一条语句：1gulp 没错，就这样！该指令会自动执行默认的任务。如果要指定具体的任务，后面直接跟上任务名即可，比如：1gulp server 如何使用插件一般典型的用法就是直接将插件传入.pipe函数中，插件的配置项通过一个对象传入插件中：1.pipe(uglify()) 一般若没有特殊要求，可以省略配置项。gulp.src()和.pipe()都会返回一个叫Vinyl files的stream（我也不知道是个什么鬼），所以这些方法是可以串联起来的。 谈几个API这里列出一些比较常用的API接口，详细用法请参阅官方文档 gulp.src：匹配文件用的； gulp.dest：输出文件到指定目录； gulp.task：定义一个任务； gulp.watch：监听文件，改动触发。 好像就这四个？我也是刚发现，还说列几个常用的。所以学起来还是很容易的，不过要全部学通，可能也要花一点时间。反正我是没有认真把官网的文档看完，尽管它一点也不长。我的想法是，掌握基本的使用方法和思想，有实际需求的时候再去参考官方文档。（关键是我现在没这反面的需求啊） 文件匹配原则好像这家伙不是按照常规的正则去匹配的，官方给出了一个参考，有兴趣的自己看看，反正我没看。直接举几个栗子吧： *：能匹配abc.js，a.css，不能匹配a/bc.js； **：能匹配a.js，a/b/cd/d.css； *.*：能匹配aaa.js，b.css； a/**/*.js：能匹配a/b/c/d/ef.js，a/b/c.js。 还要说明一点，语句gulp.dest(&#39;dist&#39;)中的dist表示在项目根目录下生成dist目录。输出的文件路径是*号匹配到的文件名（未被修改的情况下），上面例子中输出的目录结构是这样的：12345678910111213// 假设原文件路径- src - css - a.scss - js - b.js// 输出的文件路径- dist - css - a.css - js - b.js 默认情况下，dist只会替换*号之前的路径，当然也可以自己修改，具体自行参阅官方文档 传送门]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印样式CSS的技巧和要点]]></title>
    <url>%2F2017%2F07%2F09%2F%E6%89%93%E5%8D%B0%E6%A0%B7%E5%BC%8FCSS%E7%9A%84%E6%8A%80%E5%B7%A7%E5%92%8C%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[不经过任何处理而直接打印网站上的页面会得到一个不理想的效果。 我们WEB开发人员可以简单采用几个要点来使之达到较为合适的效果： 使用响应式布局设置打印的效果 在合适的时候打印背景图片和颜色 添加显示的网址或页面链接，以供参考 使用css filter 提高打印的图形效果 针对打印的样式，而不是屏幕显示样式首先，我们需要使用媒体查询（media query）针对打印样式设置。123@media print &#123; // write some styles&#125; 重新针对打印写CSS样式是没有必要的，我们只需要针对差异设置打印的样式覆盖掉之前的默认样式。 大多数的浏览器会自动根据打印更改颜色，以节省打印原料，但是我们还是尽可能的手工设置一下。 为了达到最佳效果，使颜色清晰明了，我们至少需要包含一下基本的打印样式。1@media print &#123; body &#123; color: #000; background: #fff; &#125; &#125; 对于打印，大多数情况下我们不需要打印整个页面，只需要打印一个简洁的能够突出需要信息的页面，那么我们将不相关的部分隐藏掉（如：导航条、背景图片）。1234567891011121314151617/* Default styles */h1 &#123; color: #fff; background: url(banner.jpg);&#125;@media print &#123; h1 &#123; color: #000; background: none; &#125; nav, aside &#123; display: none; &#125;&#125; 在编写打印样式表的时候，你要注意要使用厘米(cm),英寸(inch)或者磅(pt)作为单位而不是屏幕像素单位，实际的单位对打印非常有用。 为了保证打印样式有用，写CSS样式使打印的内容距离纸张边缘，看起来更好，需要使用 @page 这个语法：1234567891011121314151617181920@media print &#123; h1 &#123; color: #000; background: none; &#125; nav, aside &#123; display: none; &#125; body, article &#123; width: 100%; margin: 0; padding: 0; &#125; @page &#123; margin: 2cm; &#125;&#125; 为了保证不被跨页打印，如一个标题和内容在页面底部被分开：1h2, h3 &#123; page-break-after: avoid; &#125; 另一种情况是要防止图片过宽而超出纸张边缘：123img &#123; max-width: 100% !important;&#125; 第三个要点是确保 articles 文章标签的内容，在新的一页开始：123article &#123; page-break-before: always;&#125; 最后，还要注意列表和图片不被分开在不同的页：123ul, img &#123; page-break-inside: avoid;&#125; 背景图片和颜色对于一些网站，颜色和背景图还是非常必要需要遵循的。如果用户是在 webkit 内核浏览器上打印的话，我们可以强制打印机打印屏幕上所看到的颜色（即强制在打印页面上出现任何的背景图和颜色），一般来说彩色打印机可以做到这点，我们需要一个单独的媒体查询：123456@media print and (color) &#123; * &#123; -webkit-print-color-adjust: exact; print-color-adjust: exact; &#125;&#125; 遗憾的是，这不能马上应用于firefox opera 和IE. 传送门~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你豁然开朗的AJAX和JSONP]]></title>
    <url>%2F2017%2F07%2F07%2F%E8%AE%A9%E4%BD%A0%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97%E7%9A%84AJAX%E5%92%8CJSONP%2F</url>
    <content type="text"><![CDATA[先说说JSONP是怎么产生的：1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有src这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）； 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP的客户端具体实现：1.我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。假设远程服务器上有一个remote.js文件，可以使用以下方式调用：12//remote.jsalert('我是远程文件'); 1234567891011//jsonp.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;addScript&lt;/title&gt; &lt;script src='remote.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行以后可以看到一个弹出框：我是远程文件，说明跨域调用成功。 2.现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。12345678910111213141516//jsonp.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;addScript&lt;/title&gt; &lt;script type="text/javascript"&gt; let localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;; &lt;/script&gt; &lt;script src='remote.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 12//remote.jslocalHandler(&#123;"result":"我是远程js带来的数据"&#125;); 运行之后，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。1234567891011121314151617181920//jsonp.html&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;html lang="en"&gt;&lt;title&gt;&lt;/title&gt;&lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 let flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 '+data.price + ' 元，'+'余票 ' + data.tickets + ' 张。'); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） let url = "flightResult.aspx?code=CA1998&amp;callback=flightHandler"; // 创建script标签，设置其属性 let script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.js的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：1flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type="text/javascript" src="jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "remote.js?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？ 补充： 这里针对ajax与jsonp的异同再做一些补充说明：1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ 传送门~]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析let/const在for循环中的作用原理]]></title>
    <url>%2F2017%2F07%2F01%2F%E5%89%96%E6%9E%90let-const%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、先来看一个例子123456var a=[]; for(var i = 0;i&lt;3;i++)&#123; a[i]=function()&#123;console.log(i)&#125; &#125;a[1](); //3a[2](); //3 2、再来看一下For循环的过程1234567for (语句 1; 语句 2; 语句 3)&#123; 被执行的代码块&#125;// 语句 1 在循环（代码块）开始前执行// 语句 2 定义运行循环（代码块）的条件// 语句 3 在循环（代码块）已被执行之后执行 3、例子for循环执行过程伪代码如下：12345678910111213141516171819202122232425262728293031323334var a=[]var i = 0;if(i&lt;3) &#123; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; a[i]=function()&#123;console.log(i)&#125; &#125;i++;/* 数组a此时的状态a = [ function()&#123;console.log(i)&#125;, function()&#123;console.log(i)&#125;, function()&#123;console.log(i)&#125;]*/// a[1] = function()&#123;console.log(i)&#125;a[1](); // 打印3，因为i现在的值是3注：“i现在的值是3”这句话在某种意义上是不准确的，从作用域链的角度来说a[1]在它的if&#123;&#125;块作用域内没有找到i，要去上一级作用域局部作用域中找，这时候找到了i，而局部作用域中i现在的值是3。 4、如果把for循环的var换成let12345678910111213141516171819202122232425262728293031var a=[]; for(let i = 0;i&lt;3;i++)&#123; a[i]=function()&#123;console.log(i)&#125; &#125;a[1](); //1// 执行过程var a=[]let i = 0;if(i&lt;3) &#123; let i = i; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; let i = i; a[i]=function()&#123;console.log(i)&#125; &#125;i++;if(i&lt;3) &#123; let i = i; a[i]=function()&#123;console.log(i)&#125; &#125;i++;// console.log(i)在其块级作用域内就找到了i，每次for循环把当前i值存入块级作用域。所以a[1]()会打印1；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新特性]]></title>
    <url>%2F2017%2F06%2F28%2FES6%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[ES6简介​ 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。​由于ES6是在2015年发布的，所以也叫ES2015。​以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、…. 块级作用域 在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。 块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建： 函数内部 在代码块（即 { }）内部 let声明 使用let声明变量的语法和使用var声明的语法是一样的。但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。 1234567let a = 10;if(a &gt; 5)&#123; console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错） let b = 20; console.log(b);&#125;console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错） 注意：1.用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问2.用let声明的变量也没有声明提前这一特性。3.在同一个块中，let声明的变量也不能重复声明。4.在声明变量的时候尽量使用let，慢慢的抛弃var const声明(Constant Declarations) 在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。 123456var a = 20;if (true) &#123; const b = 20; b = 30; //错误! 常量不能重新赋值 const c; //错误！ 常量声明的同时必须赋值。&#125; 注意:1.const的特性除了声明的是常量为，其他与let一样。2.在let和const声明前的这段区域称之为暂存性死区（The Temporal Dead Zone —TDZ)。3.使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。 循环中的块级绑定 使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。 1234for(let i = 0; i &lt; 3; i++)&#123; // 循环结束之后会立即销毁 i console.log(i);&#125;console.log(i); //此处无法访问到 i 。 循环中的函数 看下面的代码，是输出10个10，而不是0，1，2，… 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;funcs.forEach(function (func) &#123; func(); // 输出 "10" 共10次&#125;); 解决办法需要使用函数的自执行特性。 1234567891011var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push((function(value) &#123; return function() &#123; console.log(value); &#125; &#125;(i)));&#125;funcs.forEach(function(func) &#123; func(); // 输出 0，1，2 ... 9&#125;); 如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用123456789var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function () &#123; console.log(i); &#125;);&#125;funcs.forEach(function (func) &#123; func(); // 输出 0，1，2 ... 9&#125;) 说明：let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。 函数的新增特性带默认参数的函数 JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。 1234function makeRequest(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function() &#123;&#125;;&#125; 其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000. ES6从语言层面面上增加了默认值的支持。看下面的代码： 1234//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 其余代码&#125; 默认参数对 arguments 对象的影响 在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码： 12345678910function foo(a, b) &#123; //非严格模式 console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true&#125;foo(1, 2); 在ES5的严格模式下，arguments只反映参数的初始值，而不再反映命名参数的变化！ 1234567891011function foo(a, b) &#123; //严格模式 "use strict" console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 修改a的值不会影响到arguments[0]的值 console.log(arguments[1] === b); //false&#125;foo(1, 2); 当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码： 123456789function foo(a, b = 30) &#123; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。 console.log(arguments[1] === b); //false。 b使用了默认值，所以表现的和严格模式一样。&#125;foo(1, 2); 注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。 默认参数表达式 (Default Parameter Expressions) 参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码 12345678910function getValue() &#123; return 5;&#125;function add(first, second = getValue()) &#123; //表示使用getValue这个函数的返回值作为second的默认值。 return first + second;&#125;console.log(add(1, 1)); // 2. 调用add函数的时候，传入了第二个参数，则以传入的参数为准。console.log(add(1)); // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。 有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。 123function add(first, second = first) &#123; // 使用第一个参数作为第二个参数的默认值 return first + second; &#125; 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。 未命名参数问题 Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。 12345678910111213141516function foo(a) &#123; console.log(a); console.log(arguments[1]) //取得传入的多余的参数。&#125;foo(2, 3);``` &gt;ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数( Rest Parameters)**语法：function a(a, … b)&#123; &#125;剩余参数使用三个点( … )和变量名来表示。```jsfunction foo(a, ...b) &#123; console.log(a); console.log(b instanceof Array); //true .多余的参数都被放入了b中。b其实就是一个数组。&#125;foo(2, 3, 4, 6); 注意：1.函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。2.虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。3.剩余参数是在函数声明的时候出现的。 函数中的扩展运算符 例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用apply方法。 看下面的代码：12let values = [25, 50, 75, 100] console.log(Math.max.apply(Math, values)); // 100 上面这种方法虽然可行，但是总是不是那么直观使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。 123let values = [25, 50, 75, 100]console.log(Math.max(...values)); //使用扩展运算符。相当于拆解了数组了。console.log(Math.max(...values, 200)); //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。 注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。 全新的函数：箭头函数（=&gt;）箭头函数语法 基本语法如下： 123(形参列表)=&gt;&#123; //函数体&#125; 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。 123456789var sum = (num1, num2) =&gt;&#123; return num1 + num2;&#125;console.log(sum(3, 4));//前面的箭头函数等同于下面的传统函数var add = function (num1, num2) &#123; return num1 + num2;&#125;console.log(add(2, 4)) 如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。如果函数体内有多条语句，则 {} 不能省略。 1234567891011var sum = (num1, num2) =&gt; num1 + num2;console.log(sum(5, 4));//前面的箭头函数等同于下面的传统函数var add = function (num1, num2) &#123; return num1 + num2;&#125;console.log(add(2, 4));//如果这一行代码是没有返回值的，则方法的返回自也是undefinedvar foo = (num1, num2) =&gt; console.log("aaa");console.log(foo(3,4)); //这个地方的返回值就是undefined 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。当然如果不传入参数也不可以省略 12var foo = a=&gt; a+3; //因为只有一个参数，所以()可以省略console.log(foo(4)); // 7 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 () 123456789var foo = ()=&gt;(&#123;name:"lisi", age:30&#125;);console.log(foo());//等同于下面的；var foo1 = ()=&gt;&#123; return &#123; name:"lisi", age : 30 &#125;;&#125; 使用箭头函数实现函数自执行12345678var person = (name =&gt; &#123; return &#123; name: name, age: 30 &#125; &#125;)("zs");console.log(person); 箭头函数中无this绑定(No this Binding) 在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。 123456789101112var PageHandler = &#123; id: "123456", init: function () &#123; document.addEventListener("click", event =&gt; this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。 &#125;, doSomething: function (type) &#123; console.log("Handling " + type + " for " + this.id); &#125;&#125;;PageHandler.init(); 看下面的一段代码：12345var p = &#123; foo:()=&gt;console.log(this) //此处this为window&#125;p.foo(); //输出为 window对象。 并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。 说明：1.箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。2.由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。 无arguments绑定 虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。 123456function foo() &#123; //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。 return ()=&gt;arguments[0]; //箭头函数的返回值是foo函数的第一个参数&#125;var arrow = foo(4, 5);console.log(arrow()); // 4 对象功能的扩展 在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。 对象类别 ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括： 普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。 特异对象（exotic object）的某些内部行为和默认的有所差异。 标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。 内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。 对象字面量的语法扩展简写的属性初始化12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name:name, age:age &#125;&#125;console.log(createPerson("lisi", 30)); // &#123;name:"lisi", age:30&#125; ES6中，上面的写法可以简化成如下形式： 12345678function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name, //当对象属性名和本地变量名相同时，可以省略冒号和值 age &#125;&#125;console.log(createPerson("lisi", 30)); // &#123;name:"lisi", age:30&#125; 当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。 简写的方法声明1234567var person = &#123; name:'lisi', sayHell:function () &#123; console.log("我的名字是：" + this.name); &#125;&#125;person.sayHell() 在ES6中，上面的写法可以简化成如下的形式： 1234567var person = &#123; name:'李四', sayHell() &#123; console.log("我的名字是：" + this.name); &#125;&#125;person.sayHell() 在字面量中动态计算属性名 在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的。123456var p = &#123; name : '李四', age : 20&#125;var attName = 'name';console.log(p[attName]) //这里 attName表示的是一个变量名。 而下面的方式使用时没有办法访问到attName这个变量的。 123456var attName = 'name';var p = &#123; attName : '李四', // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。 age : 20&#125;console.log(p[attName]) // undefined 在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。123456var attName = 'name';var p = &#123; [attName] : '李四', // 引用了变量attName。相当于添加了一个属性名为name的属性 age : 20&#125;console.log(p[attName]) // 李四 新增的方法 ECMAScript从第五版开始避免在Object.prototype上添加新的全局函数或方法，转而去考虑具体的对象类型（如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。ES6 在全局Object上添加了几个新的方法来轻松地完成一些特定任务。 Object.is()在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示： 123456789101112console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == "5"); // trueconsole.log(5 === "5"); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, "5")); // false 很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。 Object.assign() 使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。 123456789101112var p = &#123; name : "lisi", age : 20, friends : ['张三', '李四']&#125;var p1 = &#123;&#125;;Object.assign(p1, p); //则p1中就有了与p相同的属性和方法. p1是接受者，p是提供者console.log(p1);//这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）console.log(p1.friends == p.friends); //true p1和p的friends同事指向了同一个数组。p.friends.push("王五");console.log(p1.friends); //['张三', '李四', '王五'] assign方法可以接受任意多的提供者。意味着后面提供者的同名属性会覆盖前面提供者的属性值。 1234567891011var p = &#123; name : "lisi", age : 20, friends : ['张三', '李四']&#125;var p1 = &#123; name : 'zs',&#125;var p2 = &#123;&#125;;Object.assign(p2, p, p1); //p和p1都是提供者console.log(p2.name); // zs 字符串功能的增强查找子字符串 在以前在字符串中查找字符串的时候，都是使用indexOf方法。ES6新增了三个方法来查找字符串。 includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。 startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。 endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。 每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示： 12345678910111213var msg = "Hello world!";console.log(msg.startsWith("Hello")); // trueconsole.log(msg.endsWith("!")); // trueconsole.log(msg.includes("o")); // trueconsole.log(msg.startsWith("o")); // falseconsole.log(msg.endsWith("world!")); // trueconsole.log(msg.includes("x")); // falseconsole.log(msg.startsWith("o", 4)); // trueconsole.log(msg.endsWith("o", 8)); // trueconsole.log(msg.includes("o", 8)); // false repeat方法 ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如： 123console.log("x".repeat(3)); // "xxx"console.log("hello".repeat(2)); // "hellohello"console.log("abc".repeat(4)); // "abcabcabcabc" 字符串模板字面量 模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应： 多行字符串 针对多行字符串的形式概念（formal concept）。 基本的字符串格式化 将字符串中的变量置换为值的能力。 转义 HTML 能将字符串进行转义并使其安全地插入到 HTML 的能力。 模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。 基本语法 使用一对反引号 ``(tab正上方的按键)来表示模板字面量。 12345let message = `Hello world!`; //使用模板字面量创建了一个字符串console.log(message); // "Hello world!"console.log(typeof message); // "string"console.log(message.length); // 12 多行字符串 在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \） 123var s = "abc \aaaaaa";console.log(s); //但是输出的结果中不包括换行 但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法. 12345var s = `abcaaaaadsalfjadfadfja`;console.log(s); 但是要注意： 反引号中的所有空格和缩进都是有效字符。 字符串置换 置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。语法：${变量名、表达式、任意运算、方法调用等}可以嵌入任何有效的JavaScript代码 123var name = "李四";var msg = `欢迎你$&#123;name&#125;同学`;console.log(msg) 模板标签什么是模板标签 模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示： 1let message = myTag`Hello world`; 在上面的代码中，myTag就是模板标签。myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。 定义模板标签 一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：12345678910111213141516171819let name = '张三', age = 20, message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`;/* 应该定义一个函数show： 参数1：一个字符串数组。在本例中包含三个元素。 0:"我来给大家介绍" 1:"的年龄是" 2:"." 参数2和参数3：表示需要置换的字符串的值。 */function show(stringArr, value1, value2) &#123; console.log(stringArr); // console.log(value1); // 张三 console.log(value2); // 20 return "abc";&#125;console.log(message); //abc 为了简化书写，一般把Value1和Value2写成剩余字符串的形式 123function show(stringArr, ...values)&#123; // blabla...&#125; 解构解构的实用性 在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如： 123456789let options = &#123; repeat: true, save: false &#125;;// 从对象中提取数据let repeat = options.repeat, save = options.save; 这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个数据结构。 这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。 对象解构对象解构的基本形式 对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。 123456789let node = &#123; type: "Identifier", name: "foo" &#125;;//这里就相当于声明了两个变量： type = node.type; name:node.namelet &#123; type, name &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo" 在上面的结构中必须要初始化。否则会出现语法错误。 12345678// 语法错误！var &#123; type, name &#125;;// 语法错误！let &#123; type, name &#125;;// 语法错误！const &#123; type, name &#125;; 解构赋值表达式 如果声明的变量想改变他们的值，也可以使用解构表达式。 123456789101112let node = &#123; type: "Identifier", name: "foo"&#125;,type = "Literal",name = 5;//注意：此处必须要在圆括号内才能使用解构表达式(&#123;type, name&#125; = node);console.log(type); // "Identifier"console.log(name); // "foo"" 对象解构时的默认值 如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined 12345678910let node = &#123; type: "Identifier", name: "foo" &#125;;//因为node中没有叫value的属性，所以valued的值将会是undefinedlet &#123; type, name, value &#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // undefined 不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像） 12345678910let node = &#123; type: "Identifier", name: "foo"&#125;;//手动添加value的默认值为3let &#123; type, name, value = 3&#125; = node;console.log(type); // "Identifier"console.log(name); // "foo"console.log(value); // 3 赋值给不同的变量名 在前面的操作中，都是把对象的属性值，赋值给同名变量。其实也可以赋值给不同名的变量。 123456789let node = &#123; type: "Identifier", name: "foo"&#125;;// localType才是要定义的新的变量。 type是node的属性let &#123;type: localType, name: localName&#125; = node;console.log(localType); // "Identifier"console.log(localName); // "foo" 数组解构数组解构基本语法 数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如： 12345let colors = [ "red", "green", "blue" ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // "red"console.log(secondColor); // "green" 如果只想取数组中的某一项，则可以不用命名。 12345let colors = [ "red", "green", "blue" ];//只取数组中的第三项。let [ , , thirdColor ] = colors;console.log(thirdColor); // "blue" 解构表达式 你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如： 12345678let colors = [ "red", "green", "blue" ], firstColor = "black", secondColor = "purple";[ firstColor, secondColor ] = colors; //可以不用加括号。当然添加也不犯法console.log(firstColor); // "red"console.log(secondColor); // "green" 数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码： 12345678let a = 3, b = 4, temp;temp = a;a = b;b = temp;console.log(a);console.log(b) 那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式 123456let a = 3, b = 4;//左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。[a, b] = [b, a];console.log(a);console.log(b); 新的基本类型：Symbol 以前我们有5种基本数据类型：Number、String、Boolean、Null、UndefinedES6新增了一种新的数据类型：Symbol在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。 创建SymbolSymbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。我们可以使用symbol全局函数来创建Symbol。 12345let firstName = Symbol(); //创建一个Symbollet person = &#123;&#125;;person[firstName] = "张三";console.log(person[firstName]); // "张三" 说明：上面的代码中，firstName作为symbol类型被创建并赋值给 person对象以作其属性。每次访问这个属性时必须使用该 symbol。 在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。 123var s1 = Symbol("abc");var s2 = Symbol("abc");console.log(s1 == s2); //false 注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。 识别Symbol 既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如： 12let symbol = Symbol();console.log(typeof symbol); // "symbol" Symbol作为属性名​由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。12345678var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125; 注意：1,symbol作为对象的属性的时候，只能使用[ ]去访问，不能使用点去访问。2,symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of时无法遍历到这个symbol属性的。 Symbol属性名的遍历​ Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol属性名。123456789var obj = &#123;&#125;;var a = Symbol('a');var b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';// 返回obj对象所有Symbol类型的属性名组成的数组。var objectSymbols = Object.getOwnPropertySymbols(obj);console.log(objectSymbols) //[Symbol(a), Symbol(b)] 看下面代码 12345678var obj = &#123;&#125;;var foo = Symbol("foo");obj[foo] = "lisi";for (var i in obj) &#123; console.log(i); // 无输出 。 因为遍历不到Symbol型的属性 &#125;Object.getOwnPropertyNames(obj);// [] 只能拿到非Symbol类型的属性Object.getOwnPropertySymbols(obj) //[Symbol(foo)] 还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。Reflect.ownKeys() 123456let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj);// ["enum", "nonEnum", Symbol(my_key)] 说明：由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for(字符串)和Symbol.keyFor(symbol类型的值) Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个symbol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。 12345//第一次搜不到，则新创建一个返回，并在全局环境(window)中注册var a = Symbol.for("foo");//第二次搜到上次创建的var b = Symbol.for("foo");console.log(a === b); //因为两次搜到的是同一个Symbol，所以此处是true Symbol.for()和Symbol()都可以创建Symbol类型的数据。二者区别：1，Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。2，Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。123var a = Symbol("foo");var b = Symbol.for("foo");console.log(a == b); //false Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。 1234var a = Symbol("foo");var b = Symbol.for("foo");console.log(Symbol.keyFor(a)); // undefined. 因为a没有想全局环境中登记，所以是undefindedconsole.log(Symbol.keyFor(b)); // foo Set数据结构​JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。 ​因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。 Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 Set中的元素不能重复，而数组中的元素可以重复。 一句话总结：Set类型是一个包含无重复元素的有序列表 创建Set和并添加元素 Set本身是一个构造函数。 12345678//创建Set数据结构对象。var s = new Set();//调用set对象的add方法，向set中添加元素s.add("a");s.add("c");s.add("b");//set的size属性可以获取set中元素的个数console.log(s.size) Set中不能添加重复元素123456var s = new Set();s.add("a");s.add("c");s.add("b");s.add("a"); //重复，所以添加失败。注意这个地方并不会保存。console.log(s.size); // 长度是3 看下面代码： 1234var s = new Set();s.add(5);s.add("5");console.log(s.size); // 长度是2 在上面的代码中，数字5和字符串5都会添加成功。为什么呢？ Set是使用什么机制来判断两个元素是否相等的呢？是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。回忆一下：这个方法除了 +0和-0、NaN和NaN认为相等，其余和三个 === 是完全一样的。 12345678910var s = new Set();s.add(+0);s.add(-0); //重复添加不进去s.add(NaN);s.add(NaN); //重复添加不进去s.add([]);s.add([]); //两个空数组不相等，所以可以添加进去s.add(&#123;&#125;);s.add(&#123;&#125;); // 两个空对象也不重复，所以也可以添加进去console.log(s.size); // 长度是6 使用数组初始化Set123//使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。var s = new Set([2, 3, 2, 2, 4]);console.log(s.size); 判断一个值是否在Set中 使用Set的 has() 方法可以判断一个值是否在这个set中。 123456let set = new Set();set.add(5);set.add("5");console.log(set.has(5)); // trueconsole.log(set.has(6)); // false 移除Set中的元素 delete(要删除的值) ：删除单个值clear()：清空所有的值 123456789101112131415let set = new Set();set.add(5);set.add("5");console.log(set.has(5)); // trueset.delete(5);console.log(set.has(5)); // falseconsole.log(set.size); // 1set.clear();console.log(set.has("5")); // falseconsole.log(set.size); // 0 遍历Set 数组有个方法forEach可以遍历数组。Set也有forEach可以遍历Set。使用Set的forEach遍历时的回调函数有三个参数：function (value, key, ownerSet){ }参数1：遍历到的元素的值参数2：对set集合来说，参数2的值和参数1的值是完全一样的。参数3：这个set自己 1234let set = new Set(["a", "c", "b", 9]);set.forEach(function (v, k, s) &#123; console.log(v + " " + (v === k) + " " + (s === set)); // 永远是true&#125;) 将Set转换为数组 将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。把Set转换为数组使用前面讲到的扩展运算符也很容易 123let set = new Set([1, 2, 3, 3, 3, 4, 5]), arr = [...set]; //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响console.log(arr); // [1,2,3,4,5] 这种情况在需要去数组中重复元素的时候非常好用。 1234567function eliminateDuplicates(items) &#123; return [...new Set(items)];&#125;let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1], //返回的是新的没有重复元素的数组。 noDuplicates = eliminateDuplicates(numbers);console.log(noDuplicates); // [1,2,3,4,5] Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map. Map数据结构​ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。 ​键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。 ​这和使用对象属性做为值的方法大相径庭，因为 对象的属性会被强制转换为字符串类型。 创建Map对象和Map的基本的存取操作 Map创建也是使用Map构造函数向Map存储键值对使用set(key, value);方法可以使用get(key),来获取指定key对应的value 12345678var map = new Map();map.set("a", "lisi");map.set("b", "zhangsan");map.set("b", "zhangsan222"); // 第二次添加，新的value会替换掉旧的console.log(map.get("a"));console.log(map.get("b")); //zhangsan222console.log(map.get("c")); //undefined.如果key不存在，则返回undefinedconsole.log(map.size); //2 Map与Set类似的3个方法 has(key) - 判断给定的 key 是否在 map 中存在 delete(key) - 移除 map 中的 key 及对应的值 clear() - 移除 map 中所有的键值对 初始化Map 创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。也就是传入的实际是一个二维数组！ 123456789//map接受一个二维数组var map = new Map([ //每一个数组中，第一个是map的key，第二个是map的value。如果只有第一个，则值是undefined ["name", "lisi"], ["age", 20], ["sex", "nan"]]);console.log(map.size);console.log(map.get("name")); Map的forEach方法123456789101112131415var map = new Map([ ["name", "李四"], ["age", 20], ["sex", "nan"]]);/* 回调函数有三个参数： 参数1：键值对的value 参数2：键值对的key 参数3：map对象本身 */map.forEach(function (value, key, ownMap) &#123; console.log(`key=$&#123;key&#125; ,vlue=$&#123;value&#125;`); console.log(this);&#125;) 迭代器和for…of循环循环问题12345var colors = ["red", "green", "blue"];for (var i = 0, len = colors.length; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。迭代器就是为了解决这个问题的。 什么是迭代器​ 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。 ​ 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。 我们可以使用ES5知识创建一个迭代器 123456789101112131415161718192021222324function createIterator(items) &#123; var i = 0; return &#123; next: function() &#123; var done = (i &gt;= items.length); var value = !done ? items[i++] : undefined; return &#123; done: done, value: value &#125;; &#125; &#125;;&#125;//创建一个可以在指定数组上面迭代的迭代器对象。var iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// for all further callsconsole.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。 生成器函数 生成器函数就是返回迭代器的函数！生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。看下面代码： 123456789101112//生成器函数。 注意中间的 * 不能丢function * createIterator() &#123; //每个yield的后面的值表示我们迭代到的值。 yield也定义了我们迭代的顺序。 yield 3; yield 4; yield 2;&#125;var it = createIterator();console.log(it.next().value); // 3console.log(it.next().value); // 4console.log(it.next().value); // 2console.log(it.next().value); //undefined 迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。每调用一次迭代器的next方法，如果碰到yield都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用next方法，会从上次停止的地方继续执行。 1234567891011121314151617//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。function * createIterator(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 &#123;value : items[i], done : true&#125; yield items[i]; &#125;&#125;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// 进一步调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 注意：yield 关键字只能 直接用在生成器内部 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。 生成器函数表达式 你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如： 123456789101112131415let createIterator = function *(items) &#123; for (let i = 0; i &lt; items.length; i++) &#123; yield items[i]; &#125;&#125;;let iterator = createIterator([1, 2, 3]);console.log(iterator.next()); // "&#123; value: 1, done: false &#125;"console.log(iterator.next()); // "&#123; value: 2, done: false &#125;"console.log(iterator.next()); // "&#123; value: 3, done: false &#125;"console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;"// 进一步调用console.log(iterator.next()); // "&#123; value: undefined, done: true &#125;" 注意：无法使用箭头函数来创建生成器。 可迭代类型和for-of迭代循环 迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。 ​与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。​该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 for-of 循环而设计的。​换句话说，默认情况下只有 数组、set、Map和字符串才可以使用迭代器去迭代。 (也就可以使用for…of了)​for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！ 使用 for…of 迭代数组： 1234var arr = ["a", "c", "b", "d"];for(var item of arr)&#123; console.log(item)&#125; 使用 for…of 迭代Set: 1234var set = new Set(["a", "c", "b", "d"]);for(var item of set)&#123; console.log(item)&#125; 使用 for…of 迭代Map： 12345var map = new Map([["name", "lisi"],["sex", "男"],["age", 20]]);map.set("aaa", "bbb")for(var item of map)&#123; console.log(item); //注意：这里迭代到的是由key和value组成的数组。&#125; 使用for … of迭代字符串 1234var s = "abcd";for(let c of s)&#123; console.log(c)&#125; 注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常。 说明：以数组为例。 ​ for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。 ​ 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。 访问可迭代类型的默认迭代器 Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。 123let s = "abcd";let it = s[Symbol.iterator](); //调用字符串的Symbol.iterator方法console.log(it.next()); //返回迭代器迭代到的第一个对象 因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代 123456789function isIterable(object) &#123; return typeof object[Symbol.iterator] === "function";&#125;console.log(isIterable([1, 2, 3])); // trueconsole.log(isIterable("Hello")); // trueconsole.log(isIterable(new Map())); // trueconsole.log(isIterable(new Set())); // trueconsole.log(isIterable(&#123;"name":"李四"&#125;)); // false。普通对象不可迭代 自定义可迭代类型 开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如： 1234567891011121314151617let collection = &#123; items: [], *[Symbol.iterator]() &#123; for (let item of this.items) &#123; yield item; &#125; &#125;&#125;;collection.items.push(1);collection.items.push(2);collection.items.push(3);for (let x of collection) &#123; console.log(x);&#125; 类 和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。 ES5之前的模拟的类​在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：12345678910111213function PersonType(name) &#123; this.name = name;&#125;PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person = new PersonType("Nicholas");person.sayName(); // 输出 "Nicholas"console.log(person instanceof PersonType); // trueconsole.log(person instanceof Object); // true 说明：前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。 ES6中基本的类声明 在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。 12345678910111213141516171819//class关键字必须是小写。 后面就是跟的类名class PersonClass &#123; // 等效于 PersonType 构造函数。 constructor(name) &#123; //这个表示类的构造函数。constuctor也是关键字必须小写。 this.name = name; //创建属性。 也叫当前类型的自有属性。 &#125; // 等效于 PersonType.prototype.sayName. 这里的sayName使用了我们前面的简写的方式。 sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass("Nicholas");person.sayName(); // 输出 "Nicholas"console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // "function"console.log(typeof PersonClass.prototype.sayName); // "function" 说明：1，自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 尽可能的将所有自有属性创建在构造函数中，这样当查找属性时可以做到一目了然。2，类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。 虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记:1，类声明和函数定义不同，类的声明是不会被提升的。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。2，类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。3，所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。4，所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。5，不使用 new 来调用类构造函数会抛出错误。也就是 必须使用new 类() 的方式使用6，试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的） 匿名类表达式 函数有函数表达式，类也有类表达式。类表达式的功能和前面的类的声明是一样的。 123456789101112let PersonClass = class &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;;let person = new PersonClass("Nicholas");person.sayName(); // 输出 "Nicholas" 具名类表达式123456789101112let PersonClass = class PersonClass2&#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;; 注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的. 作为一等公民的类型 在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。类也是一等公民。 类可以作为参数传递1234567891011function createObject(classDef) &#123; return new classDef();&#125;let obj = createObject(class &#123; sayHi() &#123; console.log("Hi!"); &#125;&#125;);obj.sayHi(); // "Hi!" 立即调用类构造函数，创建单例12345678910111213let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;("Nicholas");person.sayName(); // "Nicholas" 动态计算类成员的命名 类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算) 123456789101112let methodName = "sayName";class PersonClass &#123; constructor(name) &#123; this.name = name; &#125; [methodName]() &#123; console.log(this.name); &#125;&#125;let me = new PersonClass("Nicholas");me.sayName(); // "Nicholas" 静态成员 在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。 123456789101112function PersonType(name) &#123; this.name = name;&#125;// 静态方法。 直接添加到构造方法上。 (其实是把构造函数当做一个普通的对象来用。)PersonType.create = function(name) &#123; return new PersonType(name);&#125;;// 实例方法PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person = PersonType.create("Nicholas"); 在上面的create方法在其他语言中一般都是作为静态方法来使用的。ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的： 12345678910111213141516171819class PersonClass &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125; // 等效于 PersonType.create。 static create(name) &#123; return new PersonClass(name); &#125;&#125;let person = PersonClass.create("Nicholas"); 注意：静态成员通过实例对象不能访问，只能通过类名访问！！！ ES6中的继承 在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子： 1234567891011121314151617181920function Father(name) &#123; this.name = name;&#125;Father.prototype.sayName = function () &#123; console.log(this.name);&#125;function Son(name,age) &#123; Father.call(this, name); this.age = age;&#125;Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function () &#123; console.log(this.age);&#125;var son1 = new Son("儿子", 20);son1.sayAge(); //20son1.sayName(); //儿子 继承的基本写法 如果在ES6通过类的方式完成继承就简单了很多。需要用到一个新的关键字：extends 123456789101112131415161718192021222324class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125;&#125;class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125;&#125;var son1 = new Son("李四", 30);son1.sayAge();son1.sayName();console.log(son1 instanceof Son); // trueconsole.log(son1 instanceof Father); //true 这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。关于super的使用，有几点需要注意：1，你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。2，你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。3，在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。 在子类中屏蔽父类的方法 如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 ) 123456789101112131415161718192021222324252627class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125;&#125;class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125; //子类中的方法会屏蔽到父类中的同名方法。 sayName()&#123; super.syaName(); //调用被覆盖的父类中的方法。 console.log("我是子类的方法，我屏蔽了父类：" + name); &#125;&#125;var son1 = new Son("李四", 30);son1.sayAge();son1.sayName(); 如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。注意：1，如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法2，普通方法调用需要使用super.父类的方法() 来调用。 静态方法也可以继承123456789class Father&#123; static foo()&#123; console.log("我是父类的静态方法"); &#125;&#125;class Son extends Father&#123;&#125;Son.foo(); //子类也继承了父类的静态方法。 这种方式调用和直接通过父类名调用时一样的。 Moudle JavaScript 采用 “共享一切” 的代码加载方式是该语言中最令人迷惑且容易出错的方面之一。其它语言使用包（package）的概念来定义代码的作用范围，然而在 ECMAScript 6 之前，每个 JavaScript 文件中定义的内容都由全局作用域共享。当 web 应用变得复杂并需要书写更多的 JavaScript 代码时，上述加载方式会出现命名冲突或安全方面的问题。ECMAScript 6 的目标之一就是解决作用域的问题并将 JavaScript 应用中的代码整理得更有条理，于是模块应运而生。 什么是模块​ 模块是指采取不同于现有加载方式的 JavaScript 文件（与 script 这种传统的加载模式相对）。这种方式很有必要，因为它和 script 使用不同的语义： 模块中的代码自动运行在严格模式下，并无任何办法修改为非严格模式。 模块中的顶级（top level）变量不会被添加到全局作用域中。它们只存在于各自的模块中的顶级作用域。 模块顶级作用域中的 this 为 undefined 。 模块不允许存在 HTML 式的注释（JavaScript 历史悠久的遗留特性）。 模块必须输出可被模块外部代码使用的相关内容。 一个模块可以引入另外的模块。 导出模块​ 可以使用 export 关键字来对外暴露模块中的部分代码。​ 一般情况下，可以在任何变量，函数或类声明之前添加这个关键字来输出它们123456789101112131415161718192021222324252627282930// 输出变量export var color = "red";export let name = "Nicholas";export const magicNumber = 7;// 输出函数export function sum(num1, num2) &#123; return num1 + num1;&#125;// 输出类export class Rectangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; &#125;&#125;// 该函数没有使用export关键字 所以该函数是模块私有的。也就是说只能在当前文件访问，出了这个文件就访问不到function subtract(num1, num2) &#123; return num1 - num2;&#125;// 定义一个函数...function multiply(num1, num2) &#123; return num1 * num2;&#125;// 可以把这个函数的引用导出。 和导出函数是一样的。export &#123; multiply &#125;; 引入模块 一旦有了导出内容的模块，则可以在另一个模块中使用import关键字来获取他们。 1import &#123; identifier1, identifier2 &#125; from "./a.js"; ​ import 之后的花括号表示从模块中引入的绑定。from 关键字表示从哪个模块引入这些绑定。模块由一个包含模块路径的字符串表示（称为模块指示符，module sepcifier）。浏览器中的 &lt;script&gt;元素也使用了这个路径形式，意味着它必须包含文件扩展名。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript特效三大系列总结]]></title>
    <url>%2F2017%2F06%2F20%2FJavaScript%E7%89%B9%E6%95%88%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天主要是讲js的DOM元素的位置关系的三大系列：offset系列，scroll系列，client系列。希望你看完之后能更加了解，熟练应用。let’s go~ offset系列offset系列的5个属性123456789101112131415161. offsetLeft : 用于获取元素到最近的定位父盒子的左侧距离 * 计算方式: 当前元素的左边框的左侧到定位父盒子的左边框右侧 * 如果父级盒子没有定位, 那么会接着往上找有定位的盒子 * 如果上级元素都没有定位,那么最后距离是与body的left值2. offsetTop : 用于获取元素到最近定位父盒子的顶部距离 * 计算方式:当前元素的上边框的上侧到定位父盒子的上边框下侧 * 如果父级盒子没有定位,那么会接着往上找有定位的盒子 * 如果上级元素都没有定位,那么最后距离是与body的top值3. offsetWidth :用于获取元素的真实宽度(除了margin以外的宽度)4. offsetHeight : 用于获取元素的真实高度(除了margin以外的高度)5. offsetParent :用于获取该元素中有定位的最近父级元素 * 如果当前元素的父级元素都没有进行定位,那么offsetParent为body 与style.(left/top/width/height)的区别:1231. offset系列的是只读属性,而通过style的方式可以读写2. offset系列返回的数值类型(结果四舍五入),style返回的是字符串3. offsetLeft 和 offsetTop 可以返回没有定位的元素的left值和top值,而style不可以 scroll系列scroll系列的4个属性1234567891. scrollHeight :元素中内容的实际高度(没有边框) * 如果内容不足,就是元素的高度2. scrollWidth: 元素中内容的实际宽度(没有边框) * 如果内容不足,就是元素的宽度3. scrollTop: onscroll事件发生时,元素向上卷曲出去的距离4. scrollLeft : onscroll事件发生时,元素向左卷曲出去的距离 兼容问题123456789101112131415161718192021222324* 未声明 DTD: 谷歌,火狐,IE9+支持 document.body.scrollTop/scrollLeft* 已经声明DTD:IE8以下支持 document.documentElement.scrollTop/scrollLeft * 火狐/谷歌/ie9+以上支持的 window.pageYOffest/pageXOffest// 兼容处理的代码function getScroll() &#123; return &#123; left: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0, top: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0 &#125;;&#125;// 使用方法:1. 取得scrollLeft值: getScroll().left2. 取得scrollTop值: getScroll().top client系列client系列的4个常用属性12345671. clientWidth : 获取网页可视区域的宽度2. clientHeight: 获取网页可视区域的高度3. clientX :获取鼠标事件发生时的应用客户端区域的水平坐标4. clientY :获取鼠标事件发生时的应用客户端区域的垂直坐标 兼容问题clientWidth 和 clientHeight的兼容问题123456789101112131415161718192021222324252627282930313233343536//由浏览器对象不同导致* 未声明 DTD: 谷歌,火狐,IE9+支持document.body.clientWidth/clientHeight* 已经声明DTD:IE8以下支持document.documentElement.clientWidth/clientHeight* 火狐/谷歌/ie9+以上支持的 window.innerWidth/innerHeight// 兼容处理的代码function client()&#123; if(window.innerWidth)&#123; return &#123; "width":window.innerWidth, "height":window.innerHeight &#125;; &#125;else if(document.compatMode === "CSS1Compat")&#123; return &#123; "width":document.documentElement.clientWidth, "height":document.documentElement.clientHeight &#125;; &#125;else&#123; return &#123; "width":document.body.clientWidth, "height":document.body.clientHeight &#125;; &#125;&#125;// 使用方法:1. 取得clientWidth的值: client().width2. 取得clientHeight的值: client().height clientX 和 clientY的兼容问题1234567891011121314151617181920212223242526272829//由事件参数对象的兼容性问题导致1. 谷歌,火狐,IE9+: 事件参数对象随着事件处理函数的参数传入2. IE8以下: event对象必须作为window对象的一个属性(window.event)// 兼容处理的代码//将client和scroll的兼容问题进行对象的封装var evtTools=&#123; //获取兼容的事件参数对象 getEvt:function (e) &#123; return window.event?window.event:e; &#125;, //获取的是可视区域的横坐标 getClientX:function (e) &#123; return this.getEvt(e).clientX; &#125;, //获取的是可视区域的纵坐标 getClientY:function (e) &#123; return this.getEvt(e).clientY; &#125;, //获取向左卷曲出去的距离的横坐标 getScrollLeft:function () &#123; return window.pageXOffset||document.body.scrollLeft||document.documentElement.scrollLeft||0; &#125;, //获取向上卷曲出去的距离的纵坐标 getScrollTop:function () &#123; return window.pageYOffset||document.body.scrollTop||document.documentElement.scrollTop||0; &#125;&#125;; 总结1234567891011121314网页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight;屏幕可用工作区宽度：window.screen.availWidth;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js图片懒加载及优化]]></title>
    <url>%2F2017%2F06%2F18%2Fjs%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为啥要用图片懒加载对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。 原理将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求（指向默认的一张图那就只需请求一次）。可以指向loading的地址。 当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。 注：图片要指定宽高。关于窗口各种宽度，可以看下面两篇文章：scrollWidth,clientWidth,offsetWidth的区别JS中关于clientWidth offsetWidth scrollWidth 等的含义 图片懒加载的实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t" alt=""&gt; &lt;img src="" data-src="http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg" alt=""&gt; &lt;img src="" data-src="http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg" alt=""&gt; &lt;img src="" data-src="http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt;&lt;script&gt; (function()&#123; let num = document.getElementsByTagName('img').length; let img = document.getElementsByTagName("img"); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 window.onscroll = lazyload; function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125; &#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用节流函数进行优化如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。 同时还有以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。1.window对象的resize、scroll事件2.拖拽时的mousemove事件3.射击游戏中的mousedown、keydown事件4.文字输入、自动完成的keyup事件解决这个问题的方法有去抖动和节流的方法 去抖动原理： 当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 不足:当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了 节流原理：预设一个执行周期，如果这个周期结束了都还没触发函数，那就会执行一次函数；如果这个周期还没结束就触发了函数，那定时器将重置，开始新周期。 达到了想要的效果，既没有频繁的执行也没有延迟执行 运用节流函数的图片懒加载代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/17/18/97/01U58PIC4Xr_1024.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p01N203pHTU7/Wr5314kcLAtVCi.jpg!t" alt=""&gt; &lt;img src="" data-src="http://77fkxu.com1.z0.glb.clouddn.com/20160308/1457402219_73571.jpg" alt=""&gt; &lt;img src="" data-src="http://pic1.cxtuku.com/00/16/18/b3809a2ba0f3.jpg" alt=""&gt; &lt;img src="" data-src="http://img.bitscn.com/upimg/allimg/c150708/14363B06253120-6060O.jpg" alt=""&gt; &lt;img src="" data-src="http://cover.read.duokan.com/mfsv2/download/fdsc3/p015trgKM7vw/H0iyDPPneOVrA4.jpg!t" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/baike/pic/item/2f9cbdcc5e0bcf5c00e9283b.jpg" alt=""&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt;&lt;script&gt; (function()&#123; let num = document.getElementsByTagName('img').length; let img = document.getElementsByTagName("img"); let n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 function lazyload() &#123; //监听页面滚动事件 let seeHeight = document.documentElement.clientHeight; //可见区域高度 let scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (let i = n; i &lt; num; i++) &#123; // 图片未出现时距离顶部的距离大于滚动条距顶部的距离+可视区的高度 if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125; // 采用了节流函数 function throttle(fun, delay, time) &#123; let timeout, startTime = new Date(); return function() &#123; let context = this, args = arguments, curTime = new Date(); clearTimeout(timeout); // 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) &#123; fun.apply(context, args); startTime = curTime; // 没达到触发间隔，重新设定定时器 &#125; else &#123; timeout = setTimeout(fun, delay); &#125; &#125;; &#125;; window.addEventListener('scroll',throttle(lazyload,500,1000));&#125;)()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>image-lazyload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂HCJ讲义（一）]]></title>
    <url>%2F2017%2F06%2F15%2F%E7%96%AF%E7%8B%82HCJ%E8%AE%B2%E4%B9%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTML5的常用元素与属性HTML5新增通用属性contentEditable属性HTML5为大部分元素都增加了contentEditable属性,如果将该属性设置为true，浏览器会允许开发者直接在页面编辑该元素。contentEditable属性具有可继承的特点，如果一个HTML元素的父元素是“可编辑”状态，那么它也是默认可编辑的。123&lt;div contentEditable="true" style="width:500px;height:300px;border:1px solid #000"&gt;&lt;/div&gt;&lt;p ondbclick="this.contentEditable=true"&gt;双击编辑内容&lt;/p&gt; designMode属性designMode属性相当于全局的contentEditable属性，如果把整个页面的designMode属性设置为on时，该页面所有支持contentEditable属性的元素都变成可编辑状态。在JavaScript代码中只能修改整个HTML页面的designMode属性。1document.designMode = "on"; hidden属性HTML5所有元素提供了hidden属性，这个hidden属性支持true,false属性，如果把某一元素的hidden设置成true，就意味着浏览器不显示该组件，也不会保留该组件所占用的空间。提示：hidden属性可以代替CSS样式的display=none。12345&lt;body&gt;&lt;div id="target" hidden="true"&gt;这是文字&lt;/div&gt;&lt;button onclick="var target=document.getElementById('target');target.hidden=!target.hidden;"&gt;显示隐藏&lt;/button&gt; spellcheck属性HTML为input,textarea等元素增加了spellcheck属性，支持true,false属性，如果设置spellcheck=”true”,浏览器会负责对用户输入的文本内容执行输入检查，如果检查不通过，浏览器会对拼错的单词进行提示。1&lt;textarea spellcheck="true" rows="3" cols="40" &gt;&lt;/textarea&gt; 注：目前支持spellcheck属性的浏览器有chrome,Safari,Opera.Internet Explorer和Firefox暂不支持。 HTML5新增常用元素&lt;article&gt;侧重于表达一篇独立的，完整的文章；&lt;section&gt;侧重于对页面内容进行分块；&lt;nav&gt;专门用于定义页面上的导航栏&lt;aside&gt;主要用来渲染成侧边栏&lt;footer&gt;主要用于为元素定义‘脚注’部分，包括该文章的版权信息，作者的授权信息等。&lt;figure&gt;用于表示一块独立的图片区域，可包含多个元素所代表的图片，还可包含一个&lt;figcaption&gt;作为定义图片区域的标题。 HTML5头部和元信息&lt;base/&gt;必须是空元素，可以使用id作为其唯一标识，还有以下两个属性：href：指定所有链接的基准链接target：指定超链接默认在哪个窗口打开链接，属性值只能是_blank,_self,_parent,_top。1234567&lt;head&gt; ... &lt;base target="_blank" href="http://www.baidu.com"/&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="index.php"&gt;啦啦啦啦&lt;/a&gt;&lt;/body&gt; &lt;meta/&gt;用于定义页面元信息，也就是一些name-content对，该元素除了可以指定id属性外，还有以下三个属性：http-equiv: 指定元信息的名称，该属性指定的名称具有特殊意义，它可以向浏览器传回一些有用的信息，帮助浏览器正确的处理网页内容。它支持的几个值有以下：Refresh: 指浏览器多长时间自动刷新页面，如：12&lt;!--设置2秒后自动刷新指定网站--&gt;&lt;meta http-equiv="Refresh" content="2,URL=http://www.baidu.com"/&gt; Expires: 指定网页的过期时间，一旦网页过期，必须重新从服务器下载，如：1&lt;meta http-equiv="Expires" content="Sat Sep 27 16:12:33 CST 2008"&gt; name: 指定元信息的名称，该名称可以随意指定content: 指定元信息值 HTML5表单相关元素和属性HTML原有的表单及表单控件表单元素&lt;form.../&gt;元素用于生成输入表单，该元素不会生成可视化部分，在HTML5以前表单控件都必须放在&lt;form.../&gt;之内。其特有属性有：action:指定当点击确定提交表单时，该表单被提交到那个地址。method:指定提交表单时的请求类型。可以是get/post,默认是get.target: 指定使用哪种方式打开目标URL.name: 指定表单的唯一名称，建议和id属性值保持一致。enctype: 指定对表单内容进行编码所使用的字符集。有三个值:application/x-www-form-urlencoded:默认的编码方式。只处理表单控件的value值，采用这种编码方式的表单会将value值处理成URL编码方式。multipart/for-data:这种编码方式会以二进制流的形式处理表单数据，用于上传文件text/plain:主要适用于直接通过表单发送邮件的方式 使用input元素1.单行文本框：指定&lt;input.../&gt;type属性为text2.密码输入框：指定&lt;input.../&gt;type属性为password3.隐藏域：指定&lt;input.../&gt;type属性为hidden4.单选框：指定&lt;input.../&gt;type属性为radio5.复选框：指定&lt;input.../&gt;type属性为checkbox6.图像域：指定&lt;input.../&gt;type属性为image,可以指定width和height属性7.文本上传域：指定&lt;input.../&gt;type属性为file input元素有以下属性：checked:设置单选框和复选框初始状态是否处于选中状态，disabled:设置首次加载时禁用此元素。该元素无法获得输入，无法选中及响应状态。maxlength: 该属性值是一个数字，指定文本框中允许输入的最大字符数。readonly: 指定文本框内的值不允许用户修改src: 指定图像域所显示的图像URL.只有type=image时可指定该属性 HTML5新增的属性和元素HTML5为表单控件新增的属性 form属性：用于定义该表单控件所属的表单，该属性值应该是它所属表单的id。通过为表单控件添加指定的form属性，可以让表单控件定义在&lt;form.../&gt;外，从而提高灵活性。 1234567&lt;body&gt; &lt;form id="addForm" action="add"&gt; 物品名：&lt;input type="text" name="name"&gt; &lt;input type="submit" value="添加"&gt; &lt;/form&gt; 物品描述：&lt;textarea name="desc" form="addForm"&gt;&lt;/textarea&gt;&lt;/body&gt; 当提交该表单时，该多行文本域也会生成对应的请求参数。 formaction属性当页面中的一个表单，包含两个以上的提交按钮，但是程序需要提交到不同的action，这是可以为不同的提交按钮指定对应的formaction,可以动态的让表单提交到不同的URL,省去用js来实现。 123456&lt;form method="post"&gt; 用户名：&lt;input type="text" name="name"&gt;&lt;br/&gt; 密码：&lt;input type="password" name="name"&gt;&lt;br/&gt; &lt;input type="submit" value="注册" formaction="regist"&gt; &lt;input type="submit" value="登录" formaction="login"&gt;&lt;/form&gt; autofocus属性当为某个表单控件添加该属性后，浏览器打开该页面时该组件会自动获得焦点。整个页面最多只能有一个表单控件可以获得该属性。 list属性相当于文本框和下拉菜单组合的组件，既允许用户输入，也允许用户通过下拉菜单进行选择。list属性的值应该是一个&lt;datalist.../&gt;组建的id。意思是list属性必须和&lt;datalist.../&gt;元素一起使用。&lt;datalist.../&gt;元素相当于一个看不见得&lt;select.../&gt;元素，用于生成一个隐藏的下拉菜单。当双击指定了list属性的文本框时，该文本框会显示&lt;datalist.../&gt;生成的下拉菜单。 12345678&lt;form&gt; 请输入图书：&lt;input type="text" name="name" list="books"&gt; &lt;input type="submit" value="购买"&gt;&lt;/form&gt;&lt;datalist id="books"&gt; &lt;option value="java"&gt;疯狂java讲义&lt;/option&gt; &lt;option value="Android"&gt;疯狂Android讲义&lt;/option&gt; &lt;/datalist&gt; 注：目前只有Firefox ,Opera最新版支持该属性。 功能丰富的input元素HTML5为&lt;input.../&gt;元素的tyoe属性新增了如下几种类型color： 让&lt;input.../&gt;元素生成一个元素选择器。date：让&lt;input.../&gt;元素生成一个日期选择器。time：让&lt;input.../&gt;元素生成一个时间选择器。datetime：让&lt;input.../&gt;元素生成一个UTC日期，时间选择器。week：让&lt;input.../&gt;元素生成一个用户选择第几周的文本框。month：让&lt;input.../&gt;元素生成一个月份选择器。email：让&lt;input.../&gt;元素生成一个元素选择器,可指定multiple属性tel：让&lt;input.../&gt;元素生成一个只允许输入手机号文本框。number：让&lt;input.../&gt;元素生成一个只能输入数字的文本框。range：让&lt;input.../&gt;元素生成一个拖动条。可指定min,max,step属性。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JavaScript之DOM操作]]></title>
    <url>%2F2017%2F06%2F11%2F%E5%8E%9F%E7%94%9FJavaScript%E4%B9%8BDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[直接获取元素1234document.getElementById(selector); // 获取指定id的元素document.getElementsByClassName(selector);// 获取指定class的元素的集合document.getElementsByTagName(selector); // 获取指定标签名的元素集合document.getElementsByName(selector); // 获取带有指定名称（name属性）的元素集合 获取父子兄弟元素123456789101112el.parentNode; // 获取直接父元素el.offsetParent; // 用于计算定位的父元素(position属性为relative、absolute或fixed的最近的父元素),若不存在这样的父元素，则为body，但是在低版本IE中可能为htmlel.childNodes; // 所有子节点的集合，包含文本节点(换行或空白)el.children; // 所有子元素的集合，不包含文本节点el.firstChild;el.lastChild;el.nextSibling;el.previousSibling; // 以上四个获取的节点，都包含文本节点el.firstElementChild;el.lastElementChild;el.nextElementSibling;el.previousElementSibling; // 以上四个获取的节点，不包含文本节点，但是在低版本IE里不兼容 增删改元素12345678let element = document.createElement(TagName); // 根据标签名创建标签let textnode = document.createTextNode(content); // 根据内容创建文本节点el.appendChild(element); // 将element标签添加为el的子节点，并且位于最后el.insertBefore(element, child); // 将element标签添加为el的子节点，并且位于child之前，child参数为空则与appendChild方法效果一致el.removeChild(element); // 删除el的子节点el.replaceChild(new, old); // 用new替换old，new可以为新创建的节点也可以为已存在的节点el.hasChildNode(); // 判断节点是否包含子节点，包含返回true，不包含返回false.el.cloneChild(true/false); // 默认为false，只复制当前节点，为true时它的所有子节点也一起复制。它也是存在内存中，也需要向页面里添加。 操作元素属性12345678let attr = document.createAttribute(name); // 创建一个属性节点attr.value = "value"; // 为属性节点添加属性值el.setAttributeNode(attr); // 将一个属性节点添加到el上el.setAttribute(name, value); // 设置el上的属性，若此属性不存在则添加el.getAttribute(name); // 获取el上的属性el.removeAttribute(name); // 删除el上的属性el.id; // 元素的id名el.className; // 元素的class名 获取元素的高宽123456el.style.width/height; // 获取元素content的宽高，但是若未设置style会得到空，这个留待后面再说el.clientWidth/clientHeight; // 获取元素可视区的宽高，即为content+padding 元素相对于视窗可见部分的left和top，el.offsetWidth/offsetHeight; // 获取元素占位宽高，即为content+padding+border 相当于绝对定位的位置left和topel.scrollWidth/scrollHeight; // 与clientWidth类似，不过如果有滚轮会包括滚轮的宽度 // 滚轮的left和top// 注意，margin与以上都无关let W = document.body.clientWidth || window.innerWidth || document.documentElement.clientWidth; // 获取整个浏览器的可视区宽度，由于IE与firefox的实现有差异，所以需要兼容性写法 文档碎片化处理js操作dom是一个很耗性能的过程，在某些情况下，不得不进行dom循环操作，我们每次对dom的操作都会触发”重排”，这严重影响到能耗，一般通常采取的做法是尽可能的减少dom操作来减少”重排”。面对循环操作dom的过程，我们选择使用文档碎片（creatDocumentFragment），将需要添加到dom中的内容都添加到文档碎片中，然后一次性的将文档碎片添加到dom树，这样就可以有效的减少操作dom的次数，减少重排的发生。1234567891011121314&lt;ul id="list"&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function()&#123; var oFragment = document.createDocumentFragment(); var ul = document.getElementById("list"); var oLi = null; for(var i= 0;i&lt;10;i++)&#123; oLi = document.createElement("li"); oLi.appendChild(document.createTextNode('item'+(i))); oFragment.appendChild(oLi); &#125; ul.appendChild(oFragment); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome控制台console用法]]></title>
    <url>%2F2017%2F06%2F07%2FChrome%E4%B8%ADconsole%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面我们来看看console里面具体提供了哪些方法可以供我们平时调试时使用。console.dir(console);可以看到有很多方法，下面主要介绍常用的几种方法。 ## 输出信息的四种方法1234console.log();// 用于输出普通信息console.info();// 用于输出提示性信息（蓝色叹号）console.error();// 用于输出错误信息（红色X号）console.warn();// 用于输出警告信息（黄色叹号） console.count() 统计1234567function fn()&#123; // blah blah.... console.count("fn执行次数：");&#125;fn(); // fn执行次数：1fn(); // fn执行次数：2fn(); // fn执行次数：3 console.dir() 输出DOM树 查看对象方法123456789var myObject = &#123; a:"1", b:2, c:true, myFunc: function()&#123; alert("Hello world"); &#125;&#125;;console.dir(myObject); console.time 计时12345678// console.time()搭配console.timeEnd()一起使用;// 使用console.time统计实例化10000个对象所用时间console.time("Array initalize");var arr = new Array(10000);for(var i = arr.length -1;i&gt;= 0;i--)&#123; arr[i] = new Object();&#125;console.timeEnd("Array initalize"); keys和valueskeys和values 前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组。123var myObj = &#123;"name": "xiaoming","age": 24,"sex":"male"&#125;;keys(myObj); //["name","age","sex"]values(myObj); //["xiaoming",24,"male"] 支持类jQuery选择器Chrome 控制台中原生支持类jQuery的选择器，也就是说你可以用$加上熟悉的css选择器来选择DOM节。如输入$(‘body’)查看对应DOM树。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之非构造函数的继承]]></title>
    <url>%2F2017%2F06%2F01%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%9D%9E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[什么是”非构造函数”的继承？比如，现在有一个对象，叫做”中国人”。123var Chinese = &#123; nation:'中国'&#125;; 还有一个对象，叫做”医生”。123var Doctor =&#123; career:'医生'&#125; 请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。 object()方法json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。使用的时候，第一步先在父对象的基础上，生成子对象：1var Doctor = object(Chinese); 然后，再加上子对象本身的属性：1Doctor.career = '医生'; 这时，子对象已经继承了父对象的属性了。1alert(Doctor.nation); //中国 深拷贝所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 使用的时候这样写：1var Doctor = deepCopy(Chinese); 现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：12Chinese.birthPlaces = ['北京','上海','香港'];Doctor.birthPlaces.push('厦门'); 这时，父对象就不会受到影响了。12alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 目前，jQuery库使用的就是这种继承方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之构造函数的继承]]></title>
    <url>%2F2017%2F05%2F27%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[前言今天要介绍的是，对象之间的”继承”的五种方法。比如，现在有一个”动物”对象的构造函数。123function Animal()&#123; this.species = "动物";&#125; 还有一个”猫”对象的构造函数。1234function Cat(name,color)&#123; this.name = name; this.color = color;&#125; 怎样才能使”猫”继承”动物”呢？ 构造函数绑定第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：1234567function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 prototype模式第二种方法更常见，使用prototype属性。如果”猫”的prototype对象，指向一个Animal的实例，那么所有”猫”的实例，就能继承Animal了。1234Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 代码的第一行，我们将Cat的prototype对象指向一个Animal的实例。1Cat.prototype = new Animal(); 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？1Cat.prototype.constructor = Cat; 原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有”Cat.prototype = new Animal();”这一行，Cat.prototype.constructor是指向Cat的；加了这一行以后，Cat.prototype.constructor指向Animal。1alert(Cat.prototype.constructor == Animal); //true 更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。1alert(cat1.constructor == Cat.prototype.constructor); // true 因此，在运行”Cat.prototype = new Animal();”这一行之后，cat1.constructor也指向Animal！1alert(cat1.constructor == Animal); // true 这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，1o.prototype = &#123;&#125;; 那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。1o.prototype.constructor = o; 直接继承prototype第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。现在，我们先将Animal对象改写：12function Animal()&#123; &#125;Animal.prototype.species = "动物"; 然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。1234Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat;var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。所以，上面这一段代码其实是有问题的。请看第二行1Cat.prototype.constructor = Cat; 这一句实际上把Animal.prototype对象的constructor属性也改掉了！1alert(Animal.prototype.constructor); // Cat 利用空对象作为中介由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。1alert(Animal.prototype.constructor); // Animal 我们将上面的方法，封装成一个函数，便于使用。12345678function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; 使用的时候，方法如下123extend(Cat,Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 这个extend函数，就是YUI库如何实现继承的方法。另外，说明一点，函数体最后一行1Child.uber = Parent.prototype; 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。 拷贝继承上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。首先，还是把Animal的所有不变属性，都放到它的prototype对象上。12function Animal()&#123;&#125;Animal.prototype.species = "动物"; 然后，再写一个函数，实现属性拷贝的目的。12345678function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p;&#125; 这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。使用的时候，这样写：123extend2(Cat, Animal);var cat1 = new Cat("大毛","黄色");alert(cat1.species); // 动物 原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript面向对象编程之封装]]></title>
    <url>%2F2017%2F05%2F24%2FJavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？ 生成实例对象的原始模式假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。1234var Cat = &#123; name : '', color : ''&#125; 现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。123456var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = "大毛"; // 按照原型对象的属性赋值cat1.color = "黄色";var cat2 = &#123;&#125;;cat2.name = "二毛";cat2.color = "黑色"; 好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。 原始模式的改进我们可以写一个函数，解决代码重复的问题。123456function Cat(name,color) &#123; return &#123; name:name, color:color &#125;&#125; 然后生成实例对象，就等于是在调用函数：12var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); 这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 构造函数模式为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。比如，猫的原型对象现在可以这样写:1234function Cat(name,color)&#123; this.name=name; this.color=color;&#125; 我们现在就可以生成实例对象了。1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.name); // 大毛alert(cat1.color); // 黄色 这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。12alert(cat1.constructor == Cat); //truealert(cat2.constructor == Cat); //true Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。12alert(cat1 instanceof Cat); //truealert(cat2 instanceof Cat); //true 构造函数模式的问题构造函数方法很好用，但是存在一个浪费内存的问题。请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：123456function Cat(name,color)&#123; this.name = name; this.color = color; this.type = "猫科动物"; this.eat = function()&#123;alert("吃老鼠");&#125;;&#125; 还是采用同样的方法，生成实例：1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat ("二毛","黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。1alert(cat1.eat == cat2.eat); //false 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。 Prototype模式Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。123456function Cat(name,color)&#123; this.name = name; this.color = color;&#125;Cat.prototype.type = "猫科动物";Cat.prototype.eat = function()&#123;alert("吃老鼠")&#125;; 然后，生成实例。1234var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠 这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。1alert(cat1.eat == cat2.eat); //true Prototype模式的验证方法为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。 isPrototypeOf()这个方法用来判断，某个proptotype对象和某个实例之间的关系。12alert(Cat.prototype.isPrototypeOf(cat1)); //truealert(Cat.prototype.isPrototypeOf(cat2)); //true hasOwnProperty()每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。12alert(cat1.hasOwnProperty("name")); // truealert(cat1.hasOwnProperty("type")); // false in运算符in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。12alert("name" in cat1); // truealert("type" in cat1); // true in运算符还可以用来遍历某个对象的所有属性。``js for(var prop in cat1){ alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery设计思想]]></title>
    <url>%2F2017%2F05%2F22%2FjQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[jQuery是目前使用最广泛的javascript函数库。 选择网页元素jQuery的基本设计思想和主要用法，就是 “选择某个网页元素，然后对其进行某种操作”。这是它区别于其他Javascript库的根本特点。使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。选择表达式可以是CSS选择器：1234$(document) //选择整个文档对象$('#myId') //选择ID为myId的网页元素$('div.myClass') // 选择class为myClass的div元素$('input[name=first]') // 选择name属性等于first的input元素 也可以是jQuery特有的表达式：123456$('a:first') //选择网页中第一个a元素$('tr:odd') //选择表格的奇数行$('#myForm :input') // 选择表单中的input元素$('div:visible') //选择可见的div元素$('div:gt(2)') // 选择所有的div元素，除了前三个$('div:animated') // 选择当前处于动画状态的div元素 改变结果集jQuery设计思想之二，就是提供各种强大的过滤器，对结果集进行筛选，缩小选择结果。12345$('div').has('p'); // 选择包含p元素的div元素$('div').not('.myClass'); //选择class不等于myClass的div元素$('div').filter('.myClass'); //选择class等于myClass的div元素$('div').first(); //选择第1个div元素$('div').eq(5); //选择第6个div元素 有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery也提供了在DOM树上的移动方法：12345$('div').next('p'); //选择div元素后面的第一个p元素$('div').parent(); //选择div元素的父元素$('div').closest('form'); //选择离div最近的那个form父元素$('div').children(); //选择div的所有子元素$('div').siblings(); //选择div的同级元素 链式操作jQuery设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如：1$('div').find('h3').eq(2).html('Hello'); 分解开来，就是下面这样：1234$('div') //找到div元素 .find('h3') //选择其中的h3元素 .eq(2) //选择第3个h3元素 .html('Hello'); //将它的内容改为Hello 这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。jQuery还提供了.end()方法，使得结果集可以后退一步：1234567$('div') .find('h3') .eq(2) .html('Hello') .end() //退回到选中所有的h3元素的那一步 .eq(0) //选中第一个h3元素 .html('World'); //将它的内容改为World 元素的操作：取值和赋值操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。jQuery设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即”取值器”与”赋值器”合一。到底是取值还是赋值，由函数的参数决定。12$('h1').html(); //html()没有参数，表示取出h1的值$('h1').html('Hello'); //html()有参数Hello，表示对h1进行赋值 常见的取值和赋值函数如下：123456.html() //取出或设置html内容.text() //取出或设置text内容.attr() //取出或设置HTML某个我们自定义DOM属性的值.prop() 取出或设置HTML某个本身固有属性的值.width() //取出或设置某个元素的宽度.height() //取出或设置某个元素的高度.val() //取出某个表单元素的值 需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。 元素的操作：移动jQuery设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。假定我们选中了一个div元素，需要把它移动到p元素后面。第一种方法是使用.insertAfter()，把div元素移动p元素后面：1$('div').insertAfter($('p')); 第二种方法是使用.after()，把p元素加到div元素前面：1$('p').after($('div')); 表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。使用这种模式的操作方法，一共有四对：1234.insertAfter()和.after()：//在现存元素的外部，从后面插入元素.insertBefore()和.before()：//在现存元素的外部，从前面插入元素.appendTo()和.append()：//在现存元素的内部，从后面插入元素.prependTo()和.prepend()：//在现存元素的内部，从前面插入元素 元素的操作：复制、删除和创建除了元素的位置移动之外，jQuery还提供其他几种操作元素的重要方法。复制元素使用.clone()。删除元素使用.remove()和.detach()。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。清空元素内容（但是不删除该元素）使用.empty()。创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：123$('&lt;p&gt;Hello&lt;/p&gt;');$('&lt;li class="new"&gt;new list item&lt;/li&gt;');$('ul').append('&lt;li&gt;list item&lt;/li&gt;'); 工具方法jQuery设计思想之六：除了对选中的元素进行操作以外，还提供一些与元素无关的工具方法（utility）。不必选中元素，就可以直接使用这些方法。如果你懂得Javascript语言的继承原理，那么就能理解工具方法的实质。它是定义在jQuery构造函数上的方法，即jQuery.method()，所以可以直接使用。而那些操作元素的方法，是定义在构造函数的prototype对象上的方法，即jQuery.prototype.method()，所以必须生成实例（即选中元素）后使用。如果不理解这种区别，问题也不大，只要把工具方法理解成，是像javascript原生函数那样，可以直接使用的方法就行了。常用的工具方法有以下几种：123456789101112$.trim() //去除字符串两端的空格。$.each() //遍历一个数组或对象。$.inArray() //返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。$.grep() //返回数组中符合某种标准的元素。$.extend() //将多个对象，合并到第一个对象。$.makeArray() //将对象转化为数组。$.type() //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。$.isArray() //判断某个参数是否为数组。$.isEmptyObject() //判断某个对象是否为空（不含有任何属性）。$.isFunction() //判断某个参数是否为函数。$.isPlainObject() //判断某个参数是否为用"&#123;&#125;"或"new Object"建立的对象。$.support() //判断浏览器是否支持某个特性。 事件操作jQuery设计思想之七，就是把事件直接绑定在网页元素之上。123$('p').click(function()&#123; alert('Hello');&#125;); 目前，jQuery主要支持以下事件：1234567891011121314151617181920212223242526.blur() //表单元素失去焦点。.change() //表单元素的值发生变化.click() //鼠标单击.dblclick() //鼠标双击.focus() //表单元素获得焦点.focusin() //子元素获得焦点.focusout() //子元素失去焦点.hover() //同时为mouseenter和mouseleave事件指定处理函数.keydown() //按下键盘（长时间按键，只返回一个事件）.keypress() //按下键盘（长时间按键，将返回多个事件）.keyup() //松开键盘.load() //元素加载完毕.mousedown() //按下鼠标.mouseenter() //鼠标进入（进入子元素不触发）.mouseleave() //鼠标离开（离开子元素不触发）.mousemove() //鼠标在元素内部移动.mouseout() //鼠标离开（离开子元素也触发）.mouseover() //鼠标进入（进入子元素也触发）.mouseup()//松开鼠标.ready() //DOM加载完成.resize() //浏览器窗口的大小发生改变.scroll() //滚动条的位置发生变化.select() //用户选中文本框中的内容.submit() //用户递交表单.toggle() //根据鼠标点击的次数，依次运行多个函数.unload() //用户离开页面 以上这些事件在jQuery内部，都是.bind()的便捷方式。使用.bind()可以更灵活地控制事件，比如为多个事件绑定同一个函数：123456$('input').bind( 'click change', //同时绑定click和change事件 function() &#123; alert('Hello'); &#125;); 现在应该是使用on代替bind了。。有时，你只想让事件运行一次，这时可以使用.one()方法。123$("p").one("click", function() &#123; alert("Hello"); //只运行一次，以后的点击不会运行&#125;); .unbind()用来解除事件绑定。1$('p').unbind('click'); 所有的事件处理函数，都可以接受一个事件对象（event object）作为参数，比如下面例子中的e：123$("p").click(function(e) &#123; alert(e.type); // "click"&#125;); 这个事件对象有一些很有用的属性和方法：12345678event.pageX //事件发生时，鼠标距离网页左上角的水平距离event.pageY //事件发生时，鼠标距离网页左上角的垂直距离event.type //事件的类型（比如click）event.which //按下了哪一个键event.data //在事件对象上绑定数据，然后传入事件处理函数event.target //事件针对的网页元素event.preventDefault() //阻止事件的默认行为（比如点击链接，会自动打开新页面）event.stopPropagation() //停止事件向上层元素冒泡 在事件处理函数中，可以用this关键字，返回事件针对的DOM元素：123456$('a').click(function(e) &#123; if ($(this).attr('href').match('evil')) &#123; //如果确认为有害链接 e.preventDefault(); //阻止打开 $(this).addClass('evil'); //加上表示有害的class &#125;&#125;); 有两种方法，可以自动触发一个事件。一种是直接使用事件函数，另一种是使用.trigger()或.triggerHandler()。12$('a').click();$('a').trigger('click'); 特殊效果最后，jQuery允许对象呈现某些特殊效果。常用的特殊效果如下：123456789.fadeIn() //淡入.fadeOut() //淡出.fadeTo() //调整透明度.hide() //隐藏元素.show() //显示元素.slideDown() //向下展开.slideUp() //向上卷起.slideToggle() //依次展开或卷起某个元素.toggle() //依次展示或隐藏某个元素 除了.show()和.hide()，所有其他特效的默认执行时间都是400ms（毫秒），但是你可以改变这个设置。12$('h1').fadeIn(300); // 300毫秒内淡入$('h1').fadeOut('slow'); // 缓慢地淡出 在特效结束后，可以指定执行某个函数。1$('p').fadeOut(300, function() &#123; $(this).remove(); &#125;); 更复杂的特效，可以用.animate()自定义。12345678$('div').animate( &#123; left : "+=50", //不断右移 opacity : 0.25 //指定透明度 &#125;, 300, // 持续时间 function() &#123; alert('done!'); &#125; //回调函数); .stop()和.delay()用来停止或延缓特效的执行。$.fx.off如果设置为true，则关闭所有网页特效。原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的this用法]]></title>
    <url>%2F2017%2F05%2F21%2FJavaScript%E7%9A%84this%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。比如:123function test()&#123; this.x = 1;&#125; 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。下面分四种情况，详细讨论this的用法。 纯粹的函数调用这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。请看下面这段代码，它的运行结果是1。12345function test()&#123; this.x = 1; alert(this.x);&#125;test(); // 1 为了证明this就是全局对象，我对代码做一些改变：12345var x = 1;function test()&#123; alert(this.x);&#125;test(); // 1 运行结果还是1。再变一下：123456var x = 1;function test()&#123; this.x = 0;&#125;test();alert(x); //0 作为对象方法的调用函数还可以作为某个对象的方法调用，这时this就指这个上级对象。1234567function test()&#123; alert(this.x);&#125;var o = &#123;&#125;;o.x = 1;o.m = test;o.m(); // 1 作为构造函数调用所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。12345function test()&#123; this.x = 1;&#125;var o = new test();alert(o.x); // 1 运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：123456var x = 2;function test()&#123; this.x = 1;&#125;var o = new test();alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 apply调用apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。12345678var x = 0;function test()&#123; alert(this.x);&#125;var o=&#123;&#125;;o.x = 1;o.m = test;o.m.apply(); //0 apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。如果把最后一行代码修改为1o.m.apply(o); // 1 运行结果就变成了1，证明了这时this代表的是对象o。 原文传送门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用缓存解决js递归调用性能问题]]></title>
    <url>%2F2017%2F05%2F20%2F%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3js%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述斐波那契序列通常是用来解释递归调用。12345function fibonacci(n) &#123; if(n==0 || n == 1) return n; return fibonacci(n-1) + fibonacci(n-2);&#125; 这个算法以教学为目的,但非常低效的,不仅因为递归,而且两次调用fibonacci函数,在函数里面右侧调用的fibonacci(n-2) 在表达式左侧调用fibonacci(n-1)时就已完全计算过一遍。 这个算法效率是如此之低,斐波纳契数超过50的实在太多了。你可以去喝杯咖啡或去睡午觉时等待答案。但如果你就用这个代码在codewars上很可能得到一个超时错误。 对于这个特定卡塔(类似打怪升级里面的级数)，我们想实现缓存的解决方案。这是特别酷的,因为它将让我们继续使用递归算法,同时仍然保持足够迅速的得到一个答案。 memoize的版本的诀窍是,保持一个缓存数据结构(最有可能的关联数组),将斐波纳契数列的值缓存。当获取一个斐波那契数列值时,首先在缓存中查找，如果有则直接返回值,如果没有,再计算并把它放进缓存。 使用memoize的数据结构重构函数的递归Fibonacci以避免递归调用的缺陷。 分析斐波那契数列里面不断的递归调用自身，列入输入的是 70，那么需要计算69和68的值。在计算69的过程中又计算了 68、67、、、、、1。 计算 68的过程又计算了 67、66、、、、、、、1的值，如此重复计算的值太多了，花费的时间也就比较多。 缓存思想恰好可以减少不必要的重复计算。当第一遍计算69的值时就递归计算了 68、67、66、、、1的值，之后的每次都先查看是否有缓存，有就直接返回缓存值，避免了重复计算。 代码12345678910let cache = &#123;&#125;;let fibonacci = function(n) &#123; if(n==0 || n == 1) return n; if(cache[n])&#123; return cache[n]; &#125; return cache[n] = fibonacci(n-1) + fibonacci(n-2);&#125; 性能测试1234567891011121314151617181920212223242526272829//没有缓存时let tesetNum = 40;console.time('NoCache');function fibonacci1(n) &#123; if(n==0 || n == 1) return n; return fibonacci1(n-1) + fibonacci1(n-2);&#125;fibonacci1(tesetNum);console.timeEnd('NoCache');// 使用缓存时console.time("HasCache");let cache = &#123;&#125;;let fibonacci = function(n) &#123; if(n==0 || n == 1) return n; if(cache[n])&#123; return cache[n]; &#125; return cache[n] = fibonacci(n-1) + fibonacci(n-2);&#125;fibonacci(tesetNum);console.timeEnd('HasCache');// 输出// NoCache: 1717.834ms// HasCache: 0.159ms 通过性能测试可以看到，当测试数是40时不适用缓存消耗的时间就是使用缓存的1700多倍(好可怕的数据)，我试了下当测试数据是300时，，，，，，，，我就等不急它的执行了。 使用场景当递归调用里有大量重复计算的情景，或者组件、数据等重复加载的情况下，使用缓存是个不错的选择(典型的以空间换时间)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组去重的6中方法]]></title>
    <url>%2F2017%2F05%2F17%2FJavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%846%E4%B8%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目说明:题目123声明一个数组,将数组中的相同元素过滤掉,然后存入到一个新数组resultArr = []中;var arr = [1, 2, 3, 1, 3, 4, 5, 5];var resultArr = []//该数组的结果应该为1,2,3,4,5 基本思路:1.采用循环嵌套2.外层循环将数组中的值赋给新的数组3.内层循环通过if语句判断新数组中是否有该值,如果有,则在外层循环中通过if语句判断,让元素不赋给新数组. 方法解析比较内层循环变量的值.12345678910111213141516var arr = [1, 2, 3, 1, 3, 4, 5, 5];var resultArr = [];//外层循环进行赋值for (i = 0; i &lt; arr.length; i++) &#123; //内层循环进行重复判断 for (j = 0; j &lt; resultArr.length; j++) &#123; if (resultArr[j] == arr[i]) &#123; break;//一旦有重复arr[i],跳出循环 &#125; &#125; //如果resultArr这个数组中没有arr[i],那么j经过内层循环后没有break,值应为resultArr.length if (j == resultArr.length) &#123; resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr); //1,2,3,4,5 计数法.1234567891011121314151617var arr = [1, 2, 3, 1, 3, 4, 5, 5];var count; //声明一个变量,用来计数var resultArr = [];for (i = 0; i &lt; arr.length; i++) &#123; count = 0; //每次初始化计数变量 for (j = 0; j &lt; resultArr.length; j++) &#123; if (resultArr[j] == arr[i]) &#123; count++; //一旦进入该if语句,则计数变量自加 break; &#125; &#125; //如果count等于0 ,那么说明内层循环中没有进入if语句,则resultArr中没有和arr[i]重复的元素 if (count == 0) &#123; resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr); //1,2,3,4,5 flag标志法(也叫假设成立法)1234567891011121314151617var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr = []; //[1,2,3]var flag; //声明一个变量,用来当做假设变量for (var i = 0; i &lt; arr.length; i++) &#123; flag = true; //每次初始化假设变量,假设result中没有和arr[i]重复的元素,赋值true, for (j = 0; j &lt; resultArr.length; j++) &#123; if (resultArr[j] == arr[i]) &#123; flag = false; //一旦进入该if语句,则表示resultArr中有重复的的arr[i],则假设不成立,赋值false break; &#125; &#125; //如果flag为ture,赋值给resultArr这个数组 if (flag) &#123; resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr);//1,2,3,4,5 使用sort()方法排序后比较12345678910111213141516var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr = [];//使用数组的sort()方法对arr进行排序,也可以使用冒泡排序arr.sort(function (a, b) &#123; return a - b;&#125;);//排序后,arr变成了[1, 1, 2, 2, 3, 3, 4, 5, 5]//使用for循环,从上面的数组可以看出,如果数组元素arr[i]和arr[i+1]不相等,则表示arr[i]之后不再有与arr[i]相等的重复元素for (i = 0; i &lt; arr.length; i++) &#123; if (arr[i] != arr[i + 1]) &#123; //将arr[i]赋值给resultArr数组. resultArr[resultArr.length] = arr[i]; &#125;&#125;console.log(resultArr); //1,2,3,4,5 使用filter()方法比较123456789var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr;//采用filter()方法过滤掉数组中重复的元素,filter()方法中传入一个过滤函数作为参数.resultArr = arr.filter(function (item, index, self) &#123; //indexOf返回的是arr中的第一个元素的索引值,所以下面语句过滤掉了arr中重复的元素. return self.indexOf(item) == index;&#125;);console.log(resultArr); //1,2,3,4,5 使用缓存对象方法比较12345678910var arr = [1, 2, 3, 1, 2, 3, 4, 5, 5];var resultArr = [];var cache = &#123;&#125;; //声明一个缓存对象for(var i = 0 ; i &lt; arr.length; i ++)&#123;//循环数组arr if(!cache[arr[i]])&#123;//进行判断,如果缓存对象中没有这个属性名的话,我们就把该数组赋值给resultArr,并把该属性名赋值为true cache[arr[i]] = true; resultArr.push(arr[i]); &#125;&#125;console.log(resultArr);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F05%2F12%2Fcanvas%2F</url>
    <content type="text"><![CDATA[初识首先，先获取canvas对象：var canvas = document.getElementById(&quot;canvas&quot;);context:一直觉得这个翻译成“上下文”真够蛋疼的，context是一个封装了很多绘图功能的对象，获取这个对象的方法是:var context = canvas.getContext(&quot;2d&quot;);canvas元素绘制图像的时候有两种方法，分别是:context.fill(); // 填充context.stroke(); // 绘制边框style:在进行图像绘制之前，需要先设置好绘制的样式context.fillStyle //填充的样式context.strokeStyle // 边框的样式 context.lineWidth //边框的宽度 html5 canvas 详细使用教程]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue之入门]]></title>
    <url>%2F2017%2F05%2F11%2Fvue%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[安装(1) 前提是下载安装好git和node,在此不赘述。12// 安装vue-clinpm install vue-cli -g (2) 创建一个基于webpack模板的项目123vue init webpack my-project// 其中webpack是使用模板// mu-project 是项目名称 (3)安装依赖1234// 进入项目根目录下cd my-project// 安装依赖npm install (4)运行1234// 在命令行下输入npm run dev//在浏览器下输入localhost:8080]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid布局]]></title>
    <url>%2F2017%2F05%2F03%2Fgrid%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;CSS网格布局（又称“网格”），是一种二维网格布局系统。CSS在处理网页布局方面一直做的不是很好。一开始我们用的是table（表格）布局，然后用float(浮动)，position（定位）和inline-block（行内块）布局，但是这些方法本质上是hack，遗漏了很多功能，例如垂直居中。后来出了flexbox(盒子布局)，解决了很多布局问题，但是它仅仅是一维布局，而不是复杂的二维布局，实际上它们（flexbox与grid）能很好的配合使用。Grid布局是第一个专门为解决布局问题而创建的CSS模块,2012年11月06日成立草案。 初步了解和浏览器支持&emsp;&emsp;使用Grid布局非常简单，你只需要给容器（container）定义：display:grid，并设置列（grid-template-columns）和 行（grid-template-rows）的大小，然后用grid-column和grid-row定义容器子元素（grid-item项目）的位置。与flexbox布局类似，一开始项目的排列顺序并不重要，可以放置在容器的任何位置，这也使得你非常容易通过媒体查询重新排列你的项目。想象一下，当你定义整个页面的布局时，你只需要几行CSS就可以完成页面重排以便适应各种屏幕宽度，这得有多么神奇！&emsp;&emsp;目前浏览器还不支持Grid布局，IE10和IE11支持老的语法。如果你想体验Grid布局的强大，推荐使用开通过“体验新功能”的Chrome, Opera 或 Firefox， Chrome:打开浏览器，输入chrome://flags，找到”experimental web platform features”，启用并重启浏览器；Opera：输入opera://flags，与Chrome一样；Firefox:输入layout.css.grid.enabled。浏览器支持情况：| Chome | safari | FireFox | Opera | IE | Android/iOS || :— | :—-: | —-: | :— | :—-: | —-: || 29+ | Not supported | 40+ | 28+ | 10+ | Not supported | 重要术语&emsp;&emsp;在深入了解Grid布局概念之前，我们先了解一些术语。因为这些术语在概念上很相似，如果你不记住Grid定义的含义，会很容易将它们混淆，但是不用担心，这里术语很少。 .网格容器（Grid Container）元素应用display:grid，它是其所有网格项的父元素。下面例子container就是网格容器。12345&lt;div class="container"&gt; &lt;div class="item item-1"&gt;&lt;/div&gt; &lt;div class="item item-2"&gt;&lt;/div&gt; &lt;div class="item item-3"&gt;&lt;/div&gt;&lt;/div&gt; .网格项（Grid Item）网格容器的子元素，下面的item元素是网格项，但sub-item不是。1234567&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt; &lt;p class="sub-item"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt;&lt;/div&gt; .网格线（Grid Line）&emsp;&emsp;组成网格线的分界线。它们可以是列网格线（column grid lines），也可以是行网格线（row grid lines）并且居于行或列的任意一侧，下面黄色线就是列网格线。 .网格轨道（Grid Track）&emsp;&emsp;两个相邻的网格线之间为网格轨道。你可以认为它们是网格的列或行，下面在第二个和第三个网格线之间的黄色部分为网格轨道。 .网格单元（Grid Cell）&emsp;&emsp;两个相邻的列网格线和两个相邻的行网格线组成的是网格单元，它是最小的网格单元。下面行网格线1（row grid lines 1）、行网格线2（row grid lines 2）和列网格线1（column grid lines 1）、列网格线2（column grid lines2）组成的黄色区域为网格单元。 .网格区（Grid Area）&emsp;&emsp;网格区是由任意数量网格单元组成，下面行网格线1（row grid lines 1）、行网格线3（row grid lines 3）和列网格线1（column grid lines 1）、列网格线3（column grid lines3）组成的黄色区域为网格区。 设置在网格容器上的属性 display grid-template-columns grid-template-rows grid-template-areas grid-column-gap grid-row-gap 点击这里进入原创~]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async详解之流程控制]]></title>
    <url>%2F2017%2F05%2F02%2Fasync%E8%AF%A6%E8%A7%A3(1)%2F</url>
    <content type="text"><![CDATA[“流程控制”本来是件比较简单的事，但是由于Nodejs的异步架构的实现方法，对于需要同步的业务逻辑，实现起来就比较麻烦。嵌套3-4层，代码就会变得的支离破碎了！ Async介绍Async是一个流程控制工具包，提供了直接而强大的异步功能。基于Javascript为Node.js设计，同时也可以直接在浏览器中使用。Async提供了大约20个函数，包括常用的 map, reduce, filter, forEach 等，异步流程控制模式包括，串行(series)，并行(parallel)，瀑布(waterfall)等。 安装与调用 安装1npm install --save async 调用123var async = require("async");// 或者var waterfall = require("async/waterfall"); 使用由于nodejs是异步编程模型，有一些在同步编程中很容易做到的事情，现在却变得很麻烦。Async的流程控制就是为了简化这些操作。 series(tasks, [callback]) （多个函数依次执行，之间没有数据交换）有多个异步函数需要依次调用，一个完成之后才能执行下一个。各函数之间没有数据的交换，仅仅需要保证其执行顺序。这时可使用series。纯js代码：1234567step1(function(err, v1) &#123; step2(function(err, v2) &#123; step3(function(err, v3) &#123; // do somethig with the err or values v1/v2/v3 &#125; &#125;&#125;); 从中可以看到这嵌套还是比较多深的，如果再多几步，会更深。在代码中忽略对了每一层err的处理，否则还都等加上 if(err) return callback(err)，那就更麻烦了。对于这种情况，使用async来处理，就是这样的：12345678910111213141516171819202122232425262728293031// 数组形式async.series([ function(callback) &#123; // do some stuff ... callback(null, 'one'); &#125;, function(callback) &#123; // do some more stuff ... callback(null, 'two'); &#125;],// optional callbackfunction(err, results) &#123; // results is now equal to ['one', 'two']&#125;);// json形式（可读性更高）async.series(&#123; one: function(callback) &#123; setTimeout(function() &#123; callback(null, 1); &#125;, 200); &#125;, two: function(callback)&#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;&#125;, function(err, results) &#123; // results is now equal to: &#123;one: 1, two: 2&#125;&#125;); 该函数的详细解释为： 依次执行一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。 如果任何一个函数向它的回调函数中传了一个error，则后面的函数都不会被执行，并且将会立刻会将该error以及已经执行了的函数的结果，传给series中最后那个callback。 当所有的函数执行完后（没有出错），则会把每个函数传给其回调函数的结果合并为一个数组，传给series最后的那个callback。 还可以json的形式来提供tasks。每一个属性都会被当作函数来执行，并且结果也会以json形式传给series最后的那个callback。这种方式可读性更高一些。另外还需要注意的是：多个series调用之间是不分先后的，因为series本身也是异步调用。详细示例 parallel(tasks, [callback]) （多个函数并行执行）并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。如果某个函数出错，则立刻将err和已经执行完的函数的结果值传给parallel最终的callback。其它未执行完的函数的值不会传到最终数据，但要占个位置。同时支持json形式的tasks，其最终callback的结果也为json形式。示例代码：12345678910111213141516171819202122232425262728293031323334// 数组形式async.parallel([ function(callback) &#123; setTimeout(function() &#123; callback(null, 'one'); &#125;, 200); &#125;, function(callback) &#123; setTimeout(function() &#123; callback(null, 'two'); &#125;, 100); &#125;],// optional callbackfunction(err, results) &#123; // the results array will equal ['one','two'] even though // the second function had a shorter timeout.&#125;);// an example using an object instead of an arrayasync.parallel(&#123; one: function(callback) &#123; setTimeout(function() &#123; callback(null, 1); &#125;, 200); &#125;, two: function(callback) &#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;&#125;, function(err, results) &#123; // results is now equals to: &#123;one: 1, two: 2&#125;&#125;); 详细示例 waterfall(tasks, [callback]) （多个函数依次执行，且前一个的输出为后一个的输入）与seires相似，按顺序依次执行多个函数。不同之处，每一个函数产生的值，都将传给下一个函数。如果中途出错，后面的函数将不会被执行。错误信息以及之前产生的结果，将传给waterfall最终的callback。这个函数名为waterfall(瀑布)，可以想像瀑布从上到下，中途冲过一层层突起的石头。注意，该函数不支持json格式的tasks。123456789101112131415161718192021222324252627282930313233343536async.waterfall([ function(callback) &#123; callback(null, 'one', 'two'); &#125;, function(arg1, arg2, callback) &#123; // arg1 now equals 'one' and arg2 now equals 'two' callback(null, 'three'); &#125;, function(arg1, callback) &#123; // arg1 now equals 'three' callback(null, 'done'); &#125;], function (err, result) &#123; // result now equals 'done'&#125;);// Or, with named functions:async.waterfall([ myFirstFunction, mySecondFunction, myLastFunction,], function (err, result) &#123; // result now equals 'done'&#125;);function myFirstFunction(callback) &#123; callback(null, 'one', 'two');&#125;function mySecondFunction(arg1, arg2, callback) &#123; // arg1 now equals 'one' and arg2 now equals 'two' callback(null, 'three');&#125;function myLastFunction(arg1, callback) &#123; // arg1 now equals 'three' callback(null, 'done');&#125; 详细示例 auto(tasks, [callback]) （多个函数有依赖关系，有的并行执行，有的依次执行）用来处理有依赖关系的多个任务的执行。比如某些任务之间彼此独立，可以并行执行；但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。虽然我们可以使用async.parallel和async.series结合起来实现该功能，但如果任务之间关系复杂，则代码会相当复杂，以后如果想添加一个新任务，也会很麻烦。这时使用async.auto，则会事半功倍。如果有任务中途出错，则会把该错误传给最终callback，所有任务（包括已经执行完的）产生的数据将被忽略。这里假设我要写一个程序，它要完成以下几件事：(1) 从某处取得数据(2) 在硬盘上建立一个新的目录(3) 将数据写入到目录下某文件(4) 发送邮件，将文件以附件形式发送给其它人。分析该任务，可以知道1与2可以并行执行，3需要等1和2完成，4要等3完成。12345678910111213141516171819202122232425262728293031async.auto(&#123; get_data: function(callback) &#123; console.log('in get_data'); // async code to get some data callback(null, 'data', 'converted to array'); &#125;, make_folder: function(callback) &#123; console.log('in make_folder'); // async code to create a directory to store a file in // this is run at the same time as getting the data callback(null, 'folder'); &#125;, write_file: ['get_data', 'make_folder', function(results, callback) &#123; console.log('in write_file', JSON.stringify(results)); // once there is some data and the directory exists, // write the data to a file in the directory callback(null, 'filename'); &#125;], email_link: ['write_file', function(results, callback) &#123; console.log('in email_link', JSON.stringify(results)); // once the file is written let's email a link to it... // results.write_file contains the filename returned by write_file. callback(null, &#123;'file':results.write_file, 'email':'user@example.com'&#125;); &#125;]&#125;, function(err, results) &#123; console.log('err = ', err); console.log('results = ', results); // -&gt; &#123; makeFolder: undefined, // getData: undefined, // writeFile: 'myfile', // emailFiles: 'myfile' &#125;&#125;); 详细示例]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>async</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组操作总结]]></title>
    <url>%2F2017%2F04%2F30%2FJavaScript%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数组的创建数组的创建有两种方法，一种是通过字面量，另一种是通过Array构造函数。 字面量1var num1 = [1,2,3]; 值得注意的是，利用字面量创建数组时，不可在最后一个数组元素添加“,”，因为在老版本的浏览器中，会出现bug。 Array构造函数1var num2 = new Array();//空数组 Array()可接收包含项作为参数，这时，会创建包含传入项的数组，如num3。也可接收一个类型为number的数字作为参数，这时，会创建数组长度为该数字的数组，如num5。123var num3 = new Array("1","2","3");//相当于["1","2","3"]var num4 = new Array(3);//length为3，元素均为undefined的数组var num5 = new Array(3).fill("1",0,2); //["1","1","1",undefined] 数组的转换关于数组的转换，这里只提数组转换成字符串的两种方法。分别是toString()和join()。 toString()该方法会返回数组各个项以逗号隔开的字符串。在使用alert(array)方法打印数组时，会隐性调用toString()方法。123var num6 = [1,2,3];var num6Str = num6.toString();//"1,2,3"alert(num6);//"1,2,3" join()join()只接收一个参数，该参数为数组中各项拼接的字符串，若不传参，默认为用“,”作为分隔符，效果相当于toString()方法。123var num7 = [1,2,3];num7.join("$");//"1$2$3"num7.join();//"1,2,3" 栈方法栈是一种先进先出的数据结构，而数组提供的push()和pop()方法类似栈的行为，所以叫栈方法。 push()push()方法可以接收多个参数，把它们依次添加至数组末尾，并返回修改后数组长度。1234var num8 = [1,2,3];var num8Length = num8.push(4,5);alert(num8);//1,2,3,4,5alert(num8Length);//5 pop()pop()方法是将数组的最后一项移除，并返回移除项。12var num9 = [1,2,3];var last = num9.pop();//3 队列方法shift()shift()方法是将数组的第一项移除，并返回移除项。12var num10 = [1,2,3];var first = num10.shift();//1 unshift()unshift()方法与shift()方法用途相反，该方法可以接收多个参数，将参数依次加入数组的前端，并返回修改后数组的长度。12var num11 = [1,2,3];var addArray = num11.unshift("-1","0");//5 重排序方法reverse()reverse()方法是使数组中的项进行反转，并返回经过排序后的数组。12var num12 = [1,2,3];num12.reverse();//[3,2,1] sort()sort()方法是默认为按照ASCII码进行顺序排序。在使用sort()方法时，会先隐性调用toString()方法将数组中的每一项进行字符串转化，实际上是进行字符串ASCII进行排序，并返回排序后的数组。 对于数组项中均为number类型的数据，我们可以在sort()中传入一个比较函数，该比较函数接收两个参数，第一个参数为前一项，第二个参数为后一项。将两个参数进行对比，若return的值&gt;0,则将两个对比项进行调换位置，调换位置的项，再与较前的一项进行对比，依次类推，直到return值返回为0或者&lt;0为止。 在比较函数中，return值&gt;0，数组项调换位置；return值]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Browsersync的安装及使用方法]]></title>
    <url>%2F2017%2F04%2F27%2FBrowsersync%2F</url>
    <content type="text"><![CDATA[Browsersync介绍Browsersync是浏览器同步测试工具，Browsersync能让浏览器实时、快速响应文件更改（html、js、css、sass、less等）并自动刷新页面。省去手动F5的事件，更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试。即在任何一设备上操作，其他设备也随之改变，大大提高了测试效率。效果图： Browsersync安装Browsersync是基于node.js的，所以首先确定安装了node.js。(1) Global Install（全局安装）如果你想在任何目录的命令行中运行Browsersync ，可通过global命令进行全局安装。1npm install -g browser-sync (2) Local Install （本地安装）推荐这种方式来安装 Browsersync - 通过本地安装到每个项目。这种方式的可以使依赖被添加到你的package.json文件里（gulp或grunt构建方式）1npm install browser-sync --save-dev 启动BrowerSync如果你只需要将css文件修改后同步到浏览器里，只需要在命令行里输入即可静态网站12// --files 路径是相对于运行该命令的项目（目录） browser-sync start --server --files &quot;css/*.css&quot; 监听多个类型的文件，需要用逗号隔开。例如我们在加入一个.html文件。1234//--files 路径是相对于运行该命令的项目(目录)brower-sync start --server --files &quot;css/*.css,*.html&quot;// 如果你的文件层级比较深，您可以考虑使用 **（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 browser-sync start --server --files &quot;**/*.css, **/*.html&quot; 运行命令后，Browsersync将创建一个本地服务器并自动打开你的浏览器后访问http://localhost:3000地址，这一切都会在命令行工具里显示。动态网站如果你已经有其他本地服务器环境PHP或类似的，需要使用代理模式。 BrowserSync将通过代理URL(localhost:3000)来查看。1234// 主机名可以是ip或域名browser-sync start --proxy &quot;ip/域名&quot; &quot;css/*.css&quot;// 比如：browser-sync start --proxy &quot;localhost:8081&quot; &quot;css/*.css&quot; Browersync + gulp安装1npm install -g --save-dev gulp browser-sync gulpfile.js代码静态服务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//加载gulp模块var gulp = require('gulp');//加载browser-sync模块var browserSync = require('browser-sync').creat();var reload = browserSync.reload;//加载sass模块var sass = require('gulp-sass');//加载pug模块var pug = require('gulp-pug');//加载gulp-autoprefixer模块var autoprefixer = require('gulp-autoprefixer');/** * 这里静态服务器 + 监听 scss/pug/js 文件 */gulp.task('server',['sass','pug'],function()&#123; browserSync.init(&#123; server:'./', //这里指的是根目录，如果你的index.html在根目录下，会直接打开index页面，不然会显示Get Not，自己写路径就行 port:8081 //默认打开localhost:3000,现在改成localhost:8081 &#125;); //监听 scss/pug/js 文件 gulp.watch('sass/**/*.scss',['sass']); gulp.watch('jade/**/*.pug',['pug']); gulp.watch('page/**/*.js').on('change',reload);&#125;);/** * 编译sass */gulp.task('sass',function()&#123; return gulp.src('sass/**/*.scss') .pipe(sass().on('error', plugins.sass.logError)) .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4')) //这个插件是用来加浏览器前缀的 .pipe(gulp.dest('./page')) .pipe(reload(&#123;stream:true&#125;));&#125;);/** * 编译pug */gulp.task('pug',function()&#123; return gulp.src('jade/**/*.pug') .pipe(pug(&#123;pretty:true&#125;)) .pipe(gulp.dest('./page')) .pipe(reload(&#123;stream:true&#125;));&#125;);/** * 默认运行 */gulp.task('default',['server']); 动态服务上面的例子中只涉及到了静态服务，但是项目中肯定是要把服务跑起来的，所以就要用到代理服务proxy123456789101112/** * 代理服务器 + 监听 scss/pug/js 文件 */gulp.task('server',['sass','pug'],function()&#123; browserSync.init(&#123; proxy:'http://localhost:8081/court-digital-library-search/page/portal/portalHomepage.html', port:8083 &#125;); gulp.watch('sass/**/*.scss',['sass']); gulp.watch('jade/**/*.pug',['pug']); gulp.watch(['page/**/*.js','lar-ui/**/*.js']).on('change',reload);&#125;); 我们项目使用tomcat跑起来的，原本tomcat的访问地址是哪里，proxy指向哪里，browser-sync会生成一个新的带自动刷新的地址。运行1gulp]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Browsersync</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp知识点]]></title>
    <url>%2F2017%2F04%2F27%2Fgulp-01%2F</url>
    <content type="text"><![CDATA[gulp安装 安装node.js 说明：gulp是基于nodejs，理所当然需要安装nodejs 全局安装gulp 说明：全局安装gulp目的是为了通过她执行gulp任务； 安装：命令提示符执行npm install gulp -g； 查看是否正确安装：命令提示符执行gulp -v，出现版本号即为正确安装。 新建package.json文件 说明：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件； 执行命令提示符执行npm init进行手动安装 安装本地gulp及其插件 执行命令行npm install gulp –save-dev安装本地gulp 安装gulp插件：以gulp—sass为例执行命令npm install gulp-sass即可安装gulp-sass插件，安装完成后即可在node_modules文件夹下查看到新安装的插件 新建gulpfile.js文件（重要） 说明：gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件（其实将gulpfile.js放入其他文件夹下亦可） gulpfile.js文件用法（以gulp-sass为例） 导入工具包 require(‘node_modules里对应模块’) 12var gulp = require("gulp");var gulp-sass = require("gulp-sass"); 定义一个testLess任务(自定义) 123456789gulp.task('testLess',function()&#123;gulp.src('src/less/index.less') //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css &#125;);gulp.task("default",["watch"],function()&#123; //定义默认任务 并让gulp监视文件变化自动执行 gulp.watch("sass/*.scss",["sass"]); &#125;) gulp常用插件 gulp-uglify(JS压缩)安装：npm install –save-dev gulp-uglify 12345678910111213var gulp = require('gulp'),var rename= require('gulp-rename')var uglify= require("gulp-uglify");gulp.task('rename',function() &#123; gulp.src('src/**/*.js') .pipe(uglify())//压缩 .pipe(rename('index.min.js')) .pipe(gulp.dest('build/js'));&#125;);gulp.task('default',['rename']);uglify= require("gulp-uglify"); gulp-minify-html（html压缩）安装：npm install –save-dev gulp-minify-html 12345678910var gulp = require('gulp'),var minifyHtml= require("gulp-minify-html");gulp.task('minify-html',function() &#123; gulp.src('src/**/*.html')//要压缩的html文件 .pipe(minifyHtml())//压缩 .pipe(gulp.dest('build'));&#125;);gulp.task('default',['minify-html']); gulp-concat (js文件合并)安装：npm install –save-dev gulp-concat 12345678910var gulp = require('gulp'),concat= require("gulp-concat");gulp.task('concat',function() &#123; gulp.src('src/**/*.js') //要合并的文件 .pipe(concat('index.js'))//合并匹配到的js文件并命名为"index.js" .pipe(gulp.dest('build/js'));&#125;);gulp.task('default',['concat']); gulp-less安装：npm install –save-dev gulp-less 12345678910var gulp = require('gulp'),var less= require("gulp-less");gulp.task('compile-less',function() &#123; gulp.src('src/less/*.less') .pipe(less()) .pipe(gulp.dest('build/css'));&#125;);gulp.task('default',['compile-less']); gulp-sass安装：npm install –save-dev gulp-sass 12345678910var gulp = require('gulp'),var sass= require("gulp-sass");gulp.task('compile-sass',function() &#123; gulp.src('src/sass/*.sass') .pipe(sass()) .pipe(gulp.dest('build/css'));&#125;);gulp.task('default',['compile-sass']); gulp-imagemin（图片压缩）安装：npm install –save-dev gulp-imagemin 123456789var gulp = require('gulp');var imagemin = require('gulp-imagemin');gulp.task('uglify-imagemin',function() &#123;returngulp.src('src/images/*') .pipe(imagemin()) .pipe(gulp.dest('build/images'));&#125;);gulp.task('default',['uglify-imagemin']);]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5本地存储——IndexedDB]]></title>
    <url>%2F2017%2F04%2F26%2FIndexedDB%2F</url>
    <content type="text"><![CDATA[IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。 最近有一项业务需求，就是可以离线存储数据，等到有网络信号的时候可以上传表单和图片。所以研究了一下HTML5的IndexedDB。对于只存储某些字段的需求来说，可以使用Local Storage和 Session Storage来完成。但是一旦存储大量的数据，Local Storage和 Session Storage就远远不能满足需求了。这时，IndexedDB的强大之处就会体现出来了。(1).创建或者打开数据库1234/* 对不同浏览器的indexedDB进行兼容 */const indexeddb = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;/* 创建或连接数据库 */const request = indexeddb.open(name, version); // name：数据库名，version：数据库版本号 因为indexedDB在不同的浏览器上有兼容性，所以我们需要些一个兼容函数来兼容indexedDB。 (2). 连接到数据库的回调函数1234567891011request.addEventListener('success', function(event)&#123; // 打开或创建数据库成功&#125;, false);request.addEventListener('error', function(event)&#123; // 打开或创建数据库失败&#125;, false);request.addEventListener('upgradeneeded', function(event)&#123; // 更新数据库时执行&#125;, false); 在连接到数据库后，request会监听三种状态： success：打开或创建数据库成功 error：打开或创建数据库失败 upgradeneeded：更新数据库upgradeneeded状态是在indexedDB创建新的数据库时和indexeddb.open(name, version) version（数据库版本号）发生变化时才能监听到此状态。当版本号不发生变化时，不会触发此状态。数据库的ObjectStore的创建、删除等都是在这个监听事件下执行的。 (3).创建、删除ObjectStore在indexedDB中，ObjectStore类似于数据库的表。1234567891011121314request.addEventListener('upgradeneeded', function(event)&#123; // 创建数据库实例 const db = event.target.result; // 关闭数据库 db.close(); // 判断是否有ObjectStore db.objectStoreNames.contains(objectStoreName); // 删除ObjectStore db.deleteObjectStore(objectStoreName); &#125;, false); 可以用如下方法创建一个ObjectStore12345678910111213141516171819request.addEventListener('upgradeneeded', function(event)&#123; // 创建数据库实例 const db = event.target.result; // 判断是否有ObjectStore if(!db.objectStoreNames.contains(objectStoreName))&#123; const store = db.createObjectStore(objectStoreName, &#123; keyPath: keyPath // keyPath 作为ObjectStore的搜索关键字 &#125;); // 为ObjectStore创造索引 store.createIndex(name, // 索引 index, // 键值 &#123; unique: unique // 索引是否唯一 &#125;); &#125; &#125;, false); (4).数据的增删改查12345678910request.addEventListener('success', function(event)&#123; // 创建数据库实例 const db = event.target.result; // 查找一个ObjectStore db.transaction(objectStoreName, wa); // wa为'readwrite'时，数据可以读写 // wa为'readonly'时，数据只读 const store = transaction.objectStore(objectStoreName);&#125;, false); 数据库的增删改查12345678910111213// 添加数据，当关键字存在时数据不会添加store.add(obj);// 更新数据，当关键字存在时覆盖数据，不存在时会添加数据store.put(obj);// 删除数据，删除指定的关键字对应的数据store.delete(value);// 清除ObjectStorestore.clear();// 查找数据，根据关键字查找指定的数据const g = store.get(value);g.addEventListener('success', function(event)&#123; // 异步查找后的回调函数&#125;, false); 按索引查找数据12345678910const index = store.index(indexName);const cursor = index.openCursor(range);cursor.addEventListener('success', function(event)&#123; const result = event.target.result; if(result)&#123; result.value // 数据 result.continue(); // 迭代，游标下移 &#125;&#125;, false); 按索引的范围查找数据123456789101112131415const index = store.index(indexName);const cursor = index.openCursor(range);/** * range为null时，查找所有数据 * range为指定值时，查找索引满足该条件的对应的数据 * range为IDBKeyRange对象时，根据条件查找满足条件的指定范围的数据 */// 大于或大于等于 range = IDBKeyRange.lowerBound(value, true) // (value, +∞)，&gt; valuerange = IDBKeyRange.lowerBound(value, false) // [value, +∞)，&gt;= value// 小于或小于等于，isOpen：true，开区间；false，闭区间range = IDBKeyRange.upperBound(value, isOpen)// 大于或大于等于value1，小于或小于等于value2IDBKeyRange.bound(value1, value2, isOpen1, isOpen2) 文章转载于前端网,如有侵权，即刻删除。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mygitbook]]></title>
    <url>%2F2017%2F04%2F23%2Fmygitbook%2F</url>
    <content type="text"><![CDATA[我的gitbook JavaScript半知半解]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2017%2F04%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[第一次写博客还是挺有感觉的，建立github pages, 使用hexo+next搭建博客，然后再把代码同步到github分支上，最后熬夜学习使用markdown写第一篇博客，本文末注有原文章地址，如有侵犯，请联系我，即刻纠错。下面一起来学习markdown语法吧。 目录区块元素 标题 列表 区块引用 代码区块 分隔线 段落和换行 首行缩进区段元素 链接 强调 代码 图片 转义 内容标题 分为两种形式：类Setext 和 atx形式 类Setext示例： 1234This is an H1===This is an H2--- atx形式示例: 12# This is an H1## This is an H2 列表 有序列表有序列表使用数字接着一个英文句点，以第一个数字为开始，依次增加，和你所写无关。示例： 123. Bird2. McHale 效果： Bird McHale 无序列表无序列表是使用, + , - , * 中任意一种来表示示例： 123+ red- green* blue 效果： red red1 green blue 引用 区块引用是使用类似email中用&gt;来表示示例：1234567891011121314&gt; 简单引用1&gt; 简单引用2&gt; &gt; 多行引用&gt;&gt; 嵌套引用&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec("echo $input | $markdown_script"); 效果： 简单引用1简单引用2 多行引用 嵌套引用 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $input | $markdown_script”); 代码区块建立代码区块,只需要简单地缩进4个空格或是1个制表符就可以代码块一直持续到没有缩进的那一行(或是文件的结尾)也可以使用 ` 来表示 代码块缩进 这是使用表示 的1在代码前后分别使用```表示 代码块1与原来使用缩进来添加代码块的语法不同，这里使用``` ```来包含多行代码： 1&lt;p&gt;hello world&lt;/p&gt; 代码高亮1在上面的代码块语法基础上，在第一组```之后添加代码的语言，如 &apos;javascript&apos; 或 &apos;js&apos;，即可将代码标记为 JavaScript： 123window.addEventListener('load', function() &#123; console.log('window loaded');&#125;); 分割线一行中用三个以上的星号、减号、底线来建立一个分隔线,行内不能有其他东西,也可以在星号或是减号中间插入空格。*** - - - * * * ___ 段落和换行 段落段落是由一个或多个连续的文本行组成，它的上下要一个以上的空行(显示上看起来像是空的) 换行Mardown允许段落内的强迫换行(插入换行符)要依赖Markdown来插入&lt;br/&gt;标签的话,在&lt;br/&gt;插入处要先按入两个以上的空格然后回车 链接支持两种形式的连接语法: 行内式和参考式 链接字符不区分大小写 行内式(推荐)This is baidu 1This is [baidu](http://www.baidu.com/) 参考式 12345This is [baidu example][id] reference-style link.标记: [id]: https://www.baidu.com/ &quot;度娘&quot;或者: [id]: https://www.baidu.com/ &apos;度娘&apos; (简书不支持)或者 [id]: https://www.baidu.com/ (度娘)(简书不支持使用对文本描述使用单引号) 隐式链接标记功能 12[Baidu][]标记可以这样写:[Baidu]: http://baidu.com 参考式链接范例 1234567891011--I get 10 times more traffic from [Google] [1] than from --[Yahoo] [2] or [MSN] [3]. --[1]: http://google.com/ &quot;Google&quot;--[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;--[3]: http://search.msn.com/ &quot;MSN Search&quot;--I get 10 times more traffic from [Google][] than from--[Yahoo][] or [MSN][].--[google]: http://google.com/ &quot;Google&quot;--[yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot;--[msn]: http://search.msn.com/ &quot;MSN Search&quot;(备注: 上述代码在使用时需删掉前面的--) 自动链接 1&lt;http:\\www.baidu.com&gt; 强调Markdown使用性星号(*)和底线()作为标记强调字词的符号 两端被一个或_包围的单词会被转换成斜体 两端被两个或包围的单词会被转换成粗体 *或的两端不能有空白 用什么符号就以什么符号结尾。_1234*斜体*_斜体_**粗体**__粗体__ 图片Markdown使用一种和链接很相似的语法来标记图片 允许两种样式:行内式和参考式 行内式（推荐） 12![Overload 仓助](http://img4.duitang.com/uploads/item/201508/19/20150819131018_vYPyR.thumb.224_0.png) ![Overload 仓助](http://img4.duitang.com/uploads/item/201508/19/20150819131018_vYPyR.thumb.224_0.png &quot;森林贤王&quot;) 自定义图片位置大小 1234// 直接在md文件中嵌入HTML代码&lt;div align='center'&gt; &lt;img src="./xx.jpg" width = "400" height = "300" alt="图片名称" /&gt;&lt;/div&gt; 参考式 123--![Overload 仓助][xd]--[xd]:http://img4.duitang.com/uploads/item/201508/19/20150819131018_vYPyR.thumb.224_0.png &quot;森林贤王&quot;(备注: 上述代码在使用时需删掉前面的--) 转义使用反斜杠来插入一些在语法中有其它意义的符号,如* 需要转义的字符:123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 首行缩进&emsp;&emsp;写文章时，我们常常希望能够首行缩进，这时可以在段首加入&amp;ensp;来输入一个空格.加入&amp;emsp;来输入两个空格。 本文参考自http://www.jianshu.com/p/075d7cac8fef 删除线这就是~~删除线~~ 这就是删除线 表格单元格和表头使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：1234name | age---- | ---LearnShare | 12Mike | 32 name age LearnShare 12 Mike 32 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界：1234| name | age || ---------- | --- || LearnShare | 12 || Mike | 32 | name age LearnShare 12 Mike 32 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 对齐在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： :— 代表左对齐 :–: 代表居中对齐 —: 代表右对齐 1234| left | center | right || :--- | :----: | ----: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。 插入其他内容表格中可以插入其他 Markdown 中的行内标记：1234| name | age | blog || ------------ | --- | ------------------------------- || _LearnShare_ | 12 | [LearnShare](http://xianbai.me) || __Mike__ | 32 | [Mike](http://mike.me) | name age blog LearnShare 12 LearnShare Mike 32 Mike]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + hexo + next]]></title>
    <url>%2F2017%2F04%2F19%2FgithubPages%2F</url>
    <content type="text"><![CDATA[如何配置hexo + github page,请点击Github Pages + Hexo 搭建博客如何搭建一个独立博客——简明Github Pages与Hexo教程Markdown语法教程使用hexo，如果换了电脑怎么更新博客？ let’s go!]]></content>
      <categories>
        <category>GitHub Pages</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F02%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" #新建文件 More info: Writing Generate static files1$ hexo generate #生成静态页面至public目录 More info: Generating Run server1$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） More info: Server Deploy to remote sites1$ hexo deploy #将.deploy目录部署到GitHub More info: Deployment by my self1$ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo的简写形式1234hexo n "我的博客" == hexo new "我的博客"hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
  </entry>
</search>