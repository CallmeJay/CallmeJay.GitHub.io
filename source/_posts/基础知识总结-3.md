---
title: 基础知识总结-3
date: 2019-06-10 16:50:37
tags: 基础
---
> 主要是针对面试中口述问题

### 说一下JS的Event Loop

简单总结如下：

1. JS是单线程的，其上面的所有任务都是在两个地方执行：执行栈和任务队列。前者是存放同步任务；后者是异步任务有结果后，就在其中放入一个事件。
2. 当执行栈的任务都执行完了（栈空），js会读取任务队列，并将可以执行的任务从任务队列丢到执行栈中执行。
3. 这个过程是循环进行，所以称作Loop。

<!-- more -->

### 解释下js的闭包

直接上MDN的解释：`闭包是函数和声明该函数的词法环境的组合`。

而在JavaScript中，函数是被作为一级对象使用的，它既可以本当作值返回，还可以当作参数传递。理解了：`“Js中的函数运行在它们被定义的作用域，而不是它们被执行的作用域”`（摘自《JavaScript语言精粹》） 这句话即可。

### 解释下Set和Map

* Set元素不允许重复
* Map类似对象，但是它的键（key）可以是任意数据类型

Set的常用方法

```js
// 实例化一个set
const set = new Set([1, 2, 3, 4]);

// 遍历set
for (let item of set) {
  console.log(item);
}

// 添加元素，返回Set本身
set.add(5).add(6);

// Set大小
console.log(set.size);

// 检查元素存在
console.log(set.has(0));

// 删除指定元素，返回bool
let success = set.delete(1);
console.log(success);

set.clear();
```

Map接口基本和Set一致。不同的是增加/获取新元素的API是：set/get(key, value)

```js
const map = new Map();

// 以任意对象为 Key 值
// 这里以 Date 对象为例
let key = new Date();
map.set(key, "today");

console.log(map.get(key));
```

### JS隐式转换及应用场景

* -、*、/、% ：一律转换成数值后计算
* +：

  数字 + 字符串 = 字符串， 运算顺序是从左到右

  数字 + 对象， 优先调用对象的valueOf -> toString

  数字 + boolean/null -> 数字

  数字 + undefined -> NaN

* [1].toString() === '1'
* {}.toString() === '[object object]'
* NaN !== NaN 、+undefined 为 NaN
* null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN

### BFC

BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。

#### 哪些元素可以产生BFC

* 根元素
* float属性不为none
* position为absolute或fixed
* display为inline-block, table-cell, table-caption, flex, inline-flex
* overflow不为visible

#### BFC的布局规则

* 内部的Box会在垂直方向，一个接一个地放置
* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
* 每个元素的margin-box的左边， 与包含块border-box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
* BFC的区域不会与float box重叠。

### 调用栈

调用栈是解析器(如浏览器中的的javascript解析器)的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数正在执行，什么函数被这个函数调用，下一个调用的函数是谁）

* 当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。
* 任何被这个函数调用的函数会进一步添加到调用栈中，并且运行到它们被上个程序调用的位置。
* 当函数运行结束后，解释器将它从堆栈中移除，并在主代码列表中继续执行代码。
* 如果栈占用的空间比分配给它的空间还大，那么则会导致“栈溢出”错误。
