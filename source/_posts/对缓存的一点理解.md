---
title: 对缓存的一点理解
date: 2018-02-07 21:44:29
categories: 浏览器
tags: cache
---
> 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。

### 缓存的种类
很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。
<!--more-->
实际上所谓的缓存只有一种——它是请求资源的副本。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，HTTP呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。

缓存好处有很多：
* 缓解服务器压力(不用每次去请求资源)；
* 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；
* 减少带宽消耗(我相信你可以理解)；

### 浏览器的缓存策略
**缓存的目标:**
* 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；
* 不变的重定向: 响应状态码：301；
* 可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；
* 错误响应: 响应状态码：404 的一个页面；
* 不完全的响应: 响应状态码 206，只返回局部的信息；
* 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；

**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。**
那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。
例如：
```
Age:23146
Cache-Control:max-age=2592000
Date:Tue, 28 Nov 2017 12:26:41 GMT
ETag:W/"5a1cf09a-63c6"
Expires:Thu, 28 Dec 2017 05:27:45 GMT
Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT
Vary:Accept-Encoding
```
#### 强缓存阶段
以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，`Expires`是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。`Cache-Control:max-age=2592000`是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，`max-age > Expires`。

这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️

Firefox浏览器表现为一个灰色的200状态码。

Chrome浏览器状态码表现为:
```
200 (from disk cache)或是200 OK (from memory cache)
```
**多说一点：**关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很低会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是`from memory cache`有时是`from disk cache`的问题了。
#### 协商缓存阶段
那么当这个CSS文件过期了怎么办?`ETag`和`Last-Modified`就该闪亮登场了。

先说`Last-Modified`，这个字段是文件最后一次修改的时间；

`ETag`呢？`ETag`是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。

利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带`If-Moified-Since`和`If-None-Match`这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑

具体两个字段携带的内容如下(分别和上面的`Last-Modified`、`ETag`携带的值对应)：
```
If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT
If-None-Match: W/"5a1cf09a-63c6"
```
到这协商缓存结束。
#### 启发式缓存阶段
我们把上面的响应头改下：
```
Age:23146
Cache-Control: public
Date:Tue, 28 Nov 2017 12:26:41 GMT
Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT
Vary:Accept-Encoding
```
发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带`If-Moified-Since`呗，不是的，浏览器还有个启发式缓存阶段。

**根据响应头中2个时间字段`Date`和`Last-Modified`之间的时间差值，取其值的10%作为缓存时间周期**。

这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种`默认缓存`的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。
下面用一张图，来解释浏览器整个缓存策略的过程：
![浏览器缓存过程](http://oonulpk6h.bkt.clouddn.com/broswer_cache)
对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。
>> [传送门](https://juejin.im/post/5a6c87c46fb9a01ca560b4d7?utm_source=gold_browser_extension)

