---
title: 面试知识总结（1)
date: 2018-10-30 20:49:11
tags: 面试
---
### new 语法糖的实现

1, 创建一个新的对象
2, 链接到原型
3, 绑定this
4, 返回新的对象

<!-- more -->

```js
function create(){
  // 创建一个新的对象
  var obj = new Object();
  // 获得构造函数
  var fn = [].shift.call(arguments);
  // 链接到原型
  obj.__proto__ = fn.prototype;
  // 绑定this 执行构造函数
  var result = fn.apply(obj,arguments);
  // 确保返回的是对象
  return typeof(result) === 'object' ? result : obj;
}
```

### 模拟实现Call 和 apply

可以从以下几点来考虑如何实现

* 不传入第一个参数，那么默认为 window
* 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？

```js
Function.prototype.myCall = function(context){
  var context = context || window;
  // 给 context 添加一个属性
  // getValue.call(a, 'yck', '24') => a.fn = getValue
  context.fn = this; // this就是调用call的函数
  // 将 context 后面的参数取出来
  var args = [...arguments].slice(1);
  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
  var result = context.fn(...args);

  // 删除fn
  delete context.fn;
  return result;
}
```

以上就是 call 的思路，apply 的实现也类似

```js
Function.prototype.myApply = function(context){
  var context = context || window
  context.fn = this

  // 判断是否存在第二个参数 且为数组
  if(arguments[1] && Array.isArray(arguments[1])){
    var result = context.fn(...arguments[1]);
  }else {
    var result = context.fn();
  }

  delete context.fn;
  return result;
}
```

bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  var _this = this
  var args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```

### Vue双向绑定的简单实现（数据劫持和发布订阅）

Vue内部实现实用了`Object.defineProperty()`和发布订阅模式来实现双向数据绑定。

```js
function observe(data){

  // 判断是不是对象
  if(!obj || typeof data !== 'object'){
    return;
  }

  // 遍历对象，
  for(key in data){
    defineReactive(data,key,obj[key]);
  }
}

function defineReactive(data,key,value){

  // 递归子属性值
  observe(value);

  Object.defineProperty(data,key,{
    enumerable: true,
    configurable: true,
    get: function reactiveGetter(){
      return value;
    },
    set:function reactiveSetter(newVal){
      value = newVal;
    }
  })
}

var data = {name: 'Jay'};

observe(data);

data.name = 'John';  // set value
data.name; // get value
```

以上代码简单的实现了如何监听数据的 `set` 和 `get` 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅。

```html
<div>{{name}}</div>
```

在解析compile如上模板代码时，遇上 `{{name}}` 就会给属性 `name` 添加发布订阅。

```js
// 通过 Dep 解耦
class Dep(){
  constructor(){
    this.subs = [];
  }

  // 订阅
  addSub( sub ){
    // sub 是 Watcher 实例
    this.subs.push(sub)
  }

  // 发布
  notify(){
    this.subs.forEach( sub => {
      sub.update();
    })
  }
}

// 全局属性，通过该属性配置 Watcher 是watcher和dep关联的唯一桥梁，任何时候，都必须保证Dep.target只有一个值。
Dep.target = null;

function update(){
  document.querySelector('div').innerText = value
}

class Watcher(){
  constructor(obj,key,cb){
    // 将 Dep.target 指向自己
    Dep.target = this;
    this.cb = cb;
    this.obj = obj;
    this.key = key;
    this.value = obj[key]; // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空 保证只有一个
    Dep.target = null;
  }

  update(){
    // 获得新值
    // this.value = this.obj[this.key]; ？？ 上面已经获取 这里应该不用二次获取了
    // 调用 update 更新Dom
    this.cb(this.value);
  }
}

var data = { name: 'yck' };
observe(data);
// 模拟解析到 `{{name}}` 触发的操作
new Watcher(data, 'name', update);
// update Dom innerText
data.name = 'yyy';

```

接下来对 `defineReactive`改造

```js
function defineReactive(data,key,value){

  observe(value);

  var dp = new Dep();

  Object.defineProperty(data,key,{
    enumerable: true,
    configurable: true,
    get: function reactiveGetter(){

      console.log('get value')
      // 将 Watcher 添加到订阅
      if(Dep.target){
        dp.addSub(Dep.target);
      }

      return value;
    },

    set: function reactiveSetter(newVal){
      console.log('set value')
      value = newVal;
      // 执行 watcher 的 update 方法
      dp.notify();
    }
  })
}
```

以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。
